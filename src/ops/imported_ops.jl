# Autogenerated on 2017-04-03T18:32:19.696

module Ops
import TensorFlow
const tf = TensorFlow
"""
     avg_pool_grad(orig_input_shape, grad; data_format=NHWC)

Computes gradients of the average pooling function.


"""
function avg_pool_grad(v3583, v3584; name=nothing, ksize=nothing, strides=nothing, padding=nothing, data_format=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("AvgPoolGrad") 
                begin  
                    begin  
                        if v3583 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3583)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3583)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3584 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3584)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3584)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if ksize !== nothing 
                            desc["ksize"] = ksize
                        end
                    end
                    begin  
                        if strides !== nothing 
                            desc["strides"] = strides
                        end
                    end
                    begin  
                        if padding !== nothing 
                            desc["padding"] = padding
                        end
                    end
                    begin  
                        if data_format !== nothing 
                            desc["data_format"] = data_format
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "AvgPoolGrad") 
    tf.Tensor(tf.Operation(desc))
end

"""
     reduce_join(inputs, reduction_indices; keep_dims=false, separator=)

Joins a string Tensor across the given dimensions.

Computes the string join across dimensions in the given string Tensor of shape
`[d_0, d_1, ..., d_n-1]`.  Returns a new Tensor created by joining the input
strings with the given separator (default: empty string).  Negative indices are
counted backwards from the end, with `-1` being equivalent to `n - 1`.

For example:

```
# tensor `a` is [["a", "b"], ["c", "d"]]
tf.reduce_join(a, 0) ==> ["ac", "bd"]
tf.reduce_join(a, 1) ==> ["ab", "cd"]
tf.reduce_join(a, -2) = tf.reduce_join(a, 0) ==> ["ac", "bd"]
tf.reduce_join(a, -1) = tf.reduce_join(a, 1) ==> ["ab", "cd"]
tf.reduce_join(a, 0, keep_dims=True) ==> [["ac", "bd"]]
tf.reduce_join(a, 1, keep_dims=True) ==> [["ab"], ["cd"]]
tf.reduce_join(a, 0, separator=".") ==> ["a.c", "b.d"]
tf.reduce_join(a, [0, 1]) ==> ["acbd"]
tf.reduce_join(a, [1, 0]) ==> ["abcd"]
tf.reduce_join(a, []) ==> ["abcd"]
```
"""
function reduce_join(v3585, v3586; name=nothing, keep_dims=nothing, separator=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ReduceJoin") 
                begin  
                    begin  
                        if v3585 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3585)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3585)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3586 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3586)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3586)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if keep_dims !== nothing 
                            desc["keep_dims"] = keep_dims
                        end
                    end
                    begin  
                        if separator !== nothing 
                            desc["separator"] = separator
                        end
                    end
                end
            end), name, "ReduceJoin") 
    tf.Tensor(tf.Operation(desc))
end

"""
     restore_v2(prefix, tensor_names, shape_and_slices)

Restores tensors from a V2 checkpoint.

For backward compatibility with the V1 format, this Op currently allows
restoring from a V1 checkpoint as well:
  - This Op first attempts to find the V2 index file pointed to by "prefix", and
    if found proceed to read it as a V2 checkpoint;
  - Otherwise the V1 read path is invoked.
Relying on this behavior is not recommended, as the ability to fall back to read
V1 might be deprecated and eventually removed.

By default, restores the named tensors in full.  If the caller wishes to restore
specific slices of stored tensors, "shape_and_slices" should be non-empty
strings and correspondingly well-formed.

Callers must ensure all the named tensors are indeed stored in the checkpoint.
"""
function restore_v2(v3587, v3588, v3589; name=nothing, dtypes=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("RestoreV2") 
                begin  
                    begin  
                        if v3587 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3587)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3587)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3588 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3588)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3588)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3589 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3589)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3589)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if dtypes !== nothing 
                            desc["dtypes"] = dtypes
                        end
                    end
                end
            end), name, "RestoreV2") 
    tf.Tensor(tf.Operation(desc))
end

"""
     relu_6(features)

Computes rectified linear 6: `min(max(features, 0), 6)`.


"""
function relu_6(v3590; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Relu6") 
                begin  
                    begin  
                        if v3590 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3590)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3590)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Relu6") 
    tf.Tensor(tf.Operation(desc))
end

"""
     sparse_apply_rmsp(var, ms, mom, lr, rho, momentum, epsilon, grad, indices; use_locking=false)

Update '*var' according to the RMSProp algorithm.

Note that in dense implementation of this algorithm, ms and mom will
update even if the grad is zero, but in this sparse implementation, ms
and mom will not update in iterations during which the grad is zero.

mean_square = decay * mean_square + (1-decay) * gradient ** 2
Delta = learning_rate * gradient / sqrt(mean_square + epsilon)

ms <- rho * ms_{t-1} + (1-rho) * grad * grad
mom <- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)
var <- var - mom
"""
function sparse_apply_rmsp(v3591, v3592, v3593, v3594, v3595, v3596, v3597, v3598, v3599; name=nothing, T=nothing, Tindices=nothing, use_locking=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SparseApplyRMSProp") 
                begin  
                    begin  
                        if v3591 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3591)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3591)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3592 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3592)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3592)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3593 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3593)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3593)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3594 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3594)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3594)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3595 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3595)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3595)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3596 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3596)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3596)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3597 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3597)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3597)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3598 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3598)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3598)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3599 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3599)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3599)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tindices !== nothing 
                            desc["Tindices"] = Tindices
                        end
                    end
                    begin  
                        if use_locking !== nothing 
                            desc["use_locking"] = use_locking
                        end
                    end
                end
            end), name, "SparseApplyRMSProp") 
    tf.Tensor(tf.Operation(desc))
end

"""
     recv(; client_terminated=false)

Receives the named tensor from send_device on recv_device.


"""
function recv(; name=nothing, tensor_type=nothing, tensor_name=nothing, send_device=nothing, send_device_incarnation=nothing, recv_device=nothing, client_terminated=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("_Recv") 
                begin  
                end 
                begin  
                    begin  
                        if tensor_type !== nothing 
                            desc["tensor_type"] = tensor_type
                        end
                    end
                    begin  
                        if tensor_name !== nothing 
                            desc["tensor_name"] = tensor_name
                        end
                    end
                    begin  
                        if send_device !== nothing 
                            desc["send_device"] = send_device
                        end
                    end
                    begin  
                        if send_device_incarnation !== nothing 
                            desc["send_device_incarnation"] = send_device_incarnation
                        end
                    end
                    begin  
                        if recv_device !== nothing 
                            desc["recv_device"] = recv_device
                        end
                    end
                    begin  
                        if client_terminated !== nothing 
                            desc["client_terminated"] = client_terminated
                        end
                    end
                end
            end), name, "_Recv") 
    tf.Tensor(tf.Operation(desc))
end

"""
     max_pool(input; T=Float32, data_format=NHWC)

Performs max pooling on the input.


"""
function max_pool(v3600; name=nothing, T=nothing, ksize=nothing, strides=nothing, padding=nothing, data_format=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("MaxPool") 
                begin  
                    begin  
                        if v3600 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3600)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3600)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if ksize !== nothing 
                            desc["ksize"] = ksize
                        end
                    end
                    begin  
                        if strides !== nothing 
                            desc["strides"] = strides
                        end
                    end
                    begin  
                        if padding !== nothing 
                            desc["padding"] = padding
                        end
                    end
                    begin  
                        if data_format !== nothing 
                            desc["data_format"] = data_format
                        end
                    end
                end
            end), name, "MaxPool") 
    tf.Tensor(tf.Operation(desc))
end

"""
     host_recv(; client_terminated=false)

Receives the named tensor from send_device on recv_device.

_HostRecv requires its input on host memory whereas _Recv requires its
input on device memory.
"""
function host_recv(; name=nothing, tensor_type=nothing, tensor_name=nothing, send_device=nothing, send_device_incarnation=nothing, recv_device=nothing, client_terminated=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("_HostRecv") 
                begin  
                end 
                begin  
                    begin  
                        if tensor_type !== nothing 
                            desc["tensor_type"] = tensor_type
                        end
                    end
                    begin  
                        if tensor_name !== nothing 
                            desc["tensor_name"] = tensor_name
                        end
                    end
                    begin  
                        if send_device !== nothing 
                            desc["send_device"] = send_device
                        end
                    end
                    begin  
                        if send_device_incarnation !== nothing 
                            desc["send_device_incarnation"] = send_device_incarnation
                        end
                    end
                    begin  
                        if recv_device !== nothing 
                            desc["recv_device"] = recv_device
                        end
                    end
                    begin  
                        if client_terminated !== nothing 
                            desc["client_terminated"] = client_terminated
                        end
                    end
                end
            end), name, "_HostRecv") 
    tf.Tensor(tf.Operation(desc))
end

"""
     merge_summary(inputs)

Merges summaries.

This op creates a
[`Summary`](https://www.tensorflow.org/code/tensorflow/core/framework/summary.proto)
protocol buffer that contains the union of all the values in the input
summaries.

When the Op is run, it reports an `InvalidArgument` error if multiple values
in the summaries to merge use the same tag.
"""
function merge_summary(v3601; name=nothing, N=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("MergeSummary") 
                begin  
                    begin  
                        if v3601 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3601)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3601)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if N !== nothing 
                            desc["N"] = N
                        end
                    end
                end
            end), name, "MergeSummary") 
    tf.Tensor(tf.Operation(desc))
end

"""
     fake_queue(resource)

Deprecated. Do not use.


"""
function fake_queue(v3602; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("FakeQueue") 
                begin  
                    begin  
                        if v3602 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3602)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3602)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "FakeQueue") 
    tf.Tensor(tf.Operation(desc))
end

"""
     irfft(input, fft_length)

Compute the inverse 1-dimensional discrete Fourier Transform of a real-valued

signal over the inner-most dimension of `input`.

The inner-most dimension of `input` is assumed to be the result of `RFFT`: the
`fft_length / 2 + 1` unique components of the DFT of a real-valued signal. If
`fft_length` is not provided, it is computed from the size of the inner-most
dimension of `input` (`fft_length = 2 * (inner - 1)`). If the FFT length used to
compute `input` is odd, it should be provided since it cannot be inferred
properly.
"""
function irfft(v3603, v3604; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("IRFFT") 
                begin  
                    begin  
                        if v3603 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3603)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3603)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3604 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3604)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3604)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "IRFFT") 
    tf.Tensor(tf.Operation(desc))
end

"""
     batch_cholesky(input)




"""
function batch_cholesky(v3605; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("BatchCholesky") 
                begin  
                    begin  
                        if v3605 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3605)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3605)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "BatchCholesky") 
    tf.Tensor(tf.Operation(desc))
end

"""
     bias_add(value, bias; data_format=NHWC)

Adds `bias` to `value`.

This is a special case of `tf.add` where `bias` is restricted to be 1-D.
Broadcasting is supported, so `value` may have any number of dimensions.
"""
function bias_add(v3606, v3607; name=nothing, T=nothing, data_format=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("BiasAdd") 
                begin  
                    begin  
                        if v3606 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3606)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3606)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3607 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3607)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3607)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if data_format !== nothing 
                            desc["data_format"] = data_format
                        end
                    end
                end
            end), name, "BiasAdd") 
    tf.Tensor(tf.Operation(desc))
end

"""
     svd(input; compute_uv=true, full_matrices=false)

Computes the singular value decompositions of one or more matrices.

Computes the SVD of each inner matrix in `input` such that
`input[..., :, :] = u[..., :, :] * diag(s[..., :, :]) * transpose(v[..., :, :])`

```prettyprint
# a is a tensor containing a batch of matrices.
# s is a tensor of singular values for each matrix.
# u is the tensor containing of left singular vectors for each matrix.
# v is the tensor containing of right singular vectors for each matrix.
s, u, v = svd(a)
s, _, _ = svd(a, compute_uv=False)
```
"""
function svd(v3608; name=nothing, compute_uv=nothing, full_matrices=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Svd") 
                begin  
                    begin  
                        if v3608 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3608)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3608)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if compute_uv !== nothing 
                            desc["compute_uv"] = compute_uv
                        end
                    end
                    begin  
                        if full_matrices !== nothing 
                            desc["full_matrices"] = full_matrices
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Svd") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2), tf.Tensor(op, 3))
    end
end

"""
     parse_tensor(serialized)

Transforms a serialized tensorflow.TensorProto proto into a Tensor.


"""
function parse_tensor(v3609; name=nothing, out_type=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ParseTensor") 
                begin  
                    begin  
                        if v3609 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3609)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3609)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if out_type !== nothing 
                            desc["out_type"] = out_type
                        end
                    end
                end
            end), name, "ParseTensor") 
    tf.Tensor(tf.Operation(desc))
end

"""
     ref_enter(data; is_constant=false, parallel_iterations=10)

Creates or finds a child frame, and makes `data` available to the child frame.

The unique `frame_name` is used by the `Executor` to identify frames. If
`is_constant` is true, `output` is a constant in the child frame; otherwise
it may be changed in the child frame. At most `parallel_iterations` iterations
are run in parallel in the child frame.
"""
function ref_enter(v3610; name=nothing, T=nothing, frame_name=nothing, is_constant=nothing, parallel_iterations=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("RefEnter") 
                begin  
                    begin  
                        if v3610 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3610)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3610)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if frame_name !== nothing 
                            desc["frame_name"] = frame_name
                        end
                    end
                    begin  
                        if is_constant !== nothing 
                            desc["is_constant"] = is_constant
                        end
                    end
                    begin  
                        if parallel_iterations !== nothing 
                            desc["parallel_iterations"] = parallel_iterations
                        end
                    end
                end
            end), name, "RefEnter") 
    tf.Tensor(tf.Operation(desc))
end

"""
     erf(x)

Computes the Gauss error function of `x` element-wise.


"""
function erf(v3611; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Erf") 
                begin  
                    begin  
                        if v3611 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3611)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3611)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Erf") 
    tf.Tensor(tf.Operation(desc))
end

"""
     round(x)

Rounds the values of a tensor to the nearest integer, element-wise.

Rounds half to even.  Also known as bankers rounding. If you want to round
according to the current system rounding mode use std::cint.
"""
function round(v3612; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Round") 
                begin  
                    begin  
                        if v3612 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3612)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3612)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Round") 
    tf.Tensor(tf.Operation(desc))
end

"""
     diag(diagonal)

Returns a diagonal tensor with a given diagonal values.

Given a `diagonal`, this operation returns a tensor with the `diagonal` and
everything else padded with zeros. The diagonal is computed as follows:

Assume `diagonal` has dimensions [D1,..., Dk], then the output is a tensor of
rank 2k with dimensions [D1,..., Dk, D1,..., Dk] where:

`output[i1,..., ik, i1,..., ik] = diagonal[i1, ..., ik]` and 0 everywhere else.

For example:

```prettyprint
# 'diagonal' is [1, 2, 3, 4]
tf.diag(diagonal) ==> [[1, 0, 0, 0]
                       [0, 2, 0, 0]
                       [0, 0, 3, 0]
                       [0, 0, 0, 4]]
```
"""
function diag(v3613; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Diag") 
                begin  
                    begin  
                        if v3613 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3613)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3613)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Diag") 
    tf.Tensor(tf.Operation(desc))
end

"""
     merge(inputs)

Forwards the value of an available tensor from `inputs` to `output`.

`Merge` waits for at least one of the tensors in `inputs` to become available.
It is usually combined with `Switch` to implement branching.

`Merge` forwards the first tensor for become available to `output`, and sets
`value_index` to its index in `inputs`.
"""
function merge(v3614; name=nothing, T=nothing, N=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Merge") 
                begin  
                    begin  
                        if v3614 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3614)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3614)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if N !== nothing 
                            desc["N"] = N
                        end
                    end
                end
            end), name, "Merge") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2))
    end
end

"""
     quantized_instance_norm(x, x_min, x_max; output_range_given=false, given_y_min=nothing, given_y_max=nothing, variance_epsilon=nothing, min_separation=nothing)

Quantized Instance normalization.


"""
function quantized_instance_norm(v3615, v3616, v3617; name=nothing, T=nothing, output_range_given=nothing, given_y_min=nothing, given_y_max=nothing, variance_epsilon=nothing, min_separation=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("QuantizedInstanceNorm") 
                begin  
                    begin  
                        if v3615 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3615)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3615)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3616 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3616)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3616)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3617 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3617)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3617)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if output_range_given !== nothing 
                            desc["output_range_given"] = output_range_given
                        end
                    end
                    begin  
                        if given_y_min !== nothing 
                            desc["given_y_min"] = given_y_min
                        end
                    end
                    begin  
                        if given_y_max !== nothing 
                            desc["given_y_max"] = given_y_max
                        end
                    end
                    begin  
                        if variance_epsilon !== nothing 
                            desc["variance_epsilon"] = variance_epsilon
                        end
                    end
                    begin  
                        if min_separation !== nothing 
                            desc["min_separation"] = min_separation
                        end
                    end
                end
            end), name, "QuantizedInstanceNorm") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2), tf.Tensor(op, 3))
    end
end

"""
     random_uniform_int(shape, minval, maxval; seed=0, seed2=0)

Outputs random integers from a uniform distribution.

The generated values are uniform integers in the range `[minval, maxval)`.
The lower bound `minval` is included in the range, while the upper bound
`maxval` is excluded.

The random integers are slightly biased unless `maxval - minval` is an exact
power of two.  The bias is small for values of `maxval - minval` significantly
smaller than the range of the output (either `2^32` or `2^64`).
"""
function random_uniform_int(v3618, v3619, v3620; name=nothing, seed=nothing, seed2=nothing, Tout=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("RandomUniformInt") 
                begin  
                    begin  
                        if v3618 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3618)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3618)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3619 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3619)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3619)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3620 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3620)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3620)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if seed !== nothing 
                            desc["seed"] = seed
                        end
                    end
                    begin  
                        if seed2 !== nothing 
                            desc["seed2"] = seed2
                        end
                    end
                    begin  
                        if Tout !== nothing 
                            desc["Tout"] = Tout
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "RandomUniformInt") 
    tf.Tensor(tf.Operation(desc))
end

"""
     tensor_array_write_v3(handle, index, value, flow_in)

Push an element onto the tensor_array.


"""
function tensor_array_write_v3(v3621, v3622, v3623, v3624; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("TensorArrayWriteV3") 
                begin  
                    begin  
                        if v3621 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3621)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3621)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3622 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3622)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3622)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3623 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3623)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3623)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3624 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3624)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3624)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "TensorArrayWriteV3") 
    tf.Tensor(tf.Operation(desc))
end

"""
     asin(x)

Computes asin of x element-wise.


"""
function asin(v3625; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Asin") 
                begin  
                    begin  
                        if v3625 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3625)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3625)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Asin") 
    tf.Tensor(tf.Operation(desc))
end

"""
     any(input, reduction_indices; keep_dims=false, Tidx=Int32)

Computes the "logical or" of elements across dimensions of a tensor.

Reduces `input` along the dimensions given in `reduction_indices`. Unless
`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in
`reduction_indices`. If `keep_dims` is true, the reduced dimensions are
retained with length 1.
"""
function any(v3626, v3627; name=nothing, keep_dims=nothing, Tidx=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Any") 
                begin  
                    begin  
                        if v3626 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3626)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3626)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3627 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3627)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3627)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if keep_dims !== nothing 
                            desc["keep_dims"] = keep_dims
                        end
                    end
                    begin  
                        if Tidx !== nothing 
                            desc["Tidx"] = Tidx
                        end
                    end
                end
            end), name, "Any") 
    tf.Tensor(tf.Operation(desc))
end

"""
     rsqrt_grad(x, y)

Computes the gradient for the rsqrt of `x` wrt its input.

Specifically, `grad = dy * -0.5 * y^3`, where `y = rsqrt(x)`, and `dy`
is the corresponding input gradient.
"""
function rsqrt_grad(v3628, v3629; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("RsqrtGrad") 
                begin  
                    begin  
                        if v3628 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3628)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3628)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3629 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3629)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3629)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "RsqrtGrad") 
    tf.Tensor(tf.Operation(desc))
end

"""
     encode_jpeg(image; format=, quality=95, progressive=false, optimize_size=false, chroma_downsampling=true, density_unit=in, x_density=300, y_density=300, xmp_metadata=)

JPEG-encode an image.

`image` is a 3-D uint8 Tensor of shape `[height, width, channels]`.

The attr `format` can be used to override the color format of the encoded
output.  Values can be:

*   `''`: Use a default format based on the number of channels in the image.
*   `grayscale`: Output a grayscale JPEG image.  The `channels` dimension
    of `image` must be 1.
*   `rgb`: Output an RGB JPEG image. The `channels` dimension
    of `image` must be 3.

If `format` is not specified or is the empty string, a default format is picked
in function of the number of channels in `image`:

*   1: Output a grayscale image.
*   3: Output an RGB image.
"""
function encode_jpeg(v3630; name=nothing, format=nothing, quality=nothing, progressive=nothing, optimize_size=nothing, chroma_downsampling=nothing, density_unit=nothing, x_density=nothing, y_density=nothing, xmp_metadata=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("EncodeJpeg") 
                begin  
                    begin  
                        if v3630 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3630)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3630)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if format !== nothing 
                            desc["format"] = format
                        end
                    end
                    begin  
                        if quality !== nothing 
                            desc["quality"] = quality
                        end
                    end
                    begin  
                        if progressive !== nothing 
                            desc["progressive"] = progressive
                        end
                    end
                    begin  
                        if optimize_size !== nothing 
                            desc["optimize_size"] = optimize_size
                        end
                    end
                    begin  
                        if chroma_downsampling !== nothing 
                            desc["chroma_downsampling"] = chroma_downsampling
                        end
                    end
                    begin  
                        if density_unit !== nothing 
                            desc["density_unit"] = density_unit
                        end
                    end
                    begin  
                        if x_density !== nothing 
                            desc["x_density"] = x_density
                        end
                    end
                    begin  
                        if y_density !== nothing 
                            desc["y_density"] = y_density
                        end
                    end
                    begin  
                        if xmp_metadata !== nothing 
                            desc["xmp_metadata"] = xmp_metadata
                        end
                    end
                end
            end), name, "EncodeJpeg") 
    tf.Tensor(tf.Operation(desc))
end

"""
     fused_pad_conv_2d(input, paddings, filter)

Performs a padding as a preprocess during a convolution.

Similar to FusedResizeAndPadConv2d, this op allows for an optimized
implementation where the spatial padding transformation stage is fused with the
im2col lookup, but in this case without the bilinear filtering required for
resizing. Fusing the padding prevents the need to write out the intermediate
results as whole tensors, reducing memory pressure, and we can get some latency
gains by merging the transformation calculations.
The data_format attribute for Conv2D isn't supported by this op, and 'NHWC'
order is used instead.
Internally this op uses a single per-graph scratch buffer, which means that it
will block if multiple versions are being run in parallel. This is because this
operator is primarily an optimization to minimize memory usage.
"""
function fused_pad_conv_2d(v3631, v3632, v3633; name=nothing, T=nothing, mode=nothing, strides=nothing, padding=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("FusedPadConv2D") 
                begin  
                    begin  
                        if v3631 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3631)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3631)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3632 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3632)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3632)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3633 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3633)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3633)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if mode !== nothing 
                            desc["mode"] = mode
                        end
                    end
                    begin  
                        if strides !== nothing 
                            desc["strides"] = strides
                        end
                    end
                    begin  
                        if padding !== nothing 
                            desc["padding"] = padding
                        end
                    end
                end
            end), name, "FusedPadConv2D") 
    tf.Tensor(tf.Operation(desc))
end

"""
     tensor_array_scatter(handle, indices, value, flow_in)




"""
function tensor_array_scatter(v3634, v3635, v3636, v3637; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("TensorArrayScatter") 
                begin  
                    begin  
                        if v3634 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3634)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3634)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3635 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3635)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3635)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3636 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3636)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3636)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3637 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3637)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3637)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "TensorArrayScatter") 
    tf.Tensor(tf.Operation(desc))
end

"""
     dynamic_partition(data, partitions)

Partitions `data` into `num_partitions` tensors using indices from `partitions`.

For each index tuple `js` of size `partitions.ndim`, the slice `data[js, ...]`
becomes part of `outputs[partitions[js]]`.  The slices with `partitions[js] = i`
are placed in `outputs[i]` in lexicographic order of `js`, and the first
dimension of `outputs[i]` is the number of entries in `partitions` equal to `i`.
In detail,

```python
    outputs[i].shape = [sum(partitions == i)] + data.shape[partitions.ndim:]

    outputs[i] = pack([data[js, ...] for js if partitions[js] == i])
```

`data.shape` must start with `partitions.shape`.

For example:

```python
    # Scalar partitions.
    partitions = 1
    num_partitions = 2
    data = [10, 20]
    outputs[0] = []  # Empty with shape [0, 2]
    outputs[1] = [[10, 20]]

    # Vector partitions.
    partitions = [0, 0, 1, 1, 0]
    num_partitions = 2
    data = [10, 20, 30, 40, 50]
    outputs[0] = [10, 20, 50]
    outputs[1] = [30, 40]
```

<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="../../images/DynamicPartition.png" alt>
</div>
"""
function dynamic_partition(v3638, v3639; name=nothing, num_partitions=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("DynamicPartition") 
                begin  
                    begin  
                        if v3638 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3638)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3638)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3639 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3639)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3639)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if num_partitions !== nothing 
                            desc["num_partitions"] = num_partitions
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "DynamicPartition") 
    tf.Tensor(tf.Operation(desc))
end

"""
     add_sparse_to_tensors_map(sparse_indices, sparse_values, sparse_shape; container=, shared_name=)

Add a `SparseTensor` to a `SparseTensorsMap` return its handle.

A `SparseTensor` is represented by three tensors: `sparse_indices`,
`sparse_values`, and `sparse_shape`.

This operator takes the given `SparseTensor` and adds it to a container
object (a `SparseTensorsMap`).  A unique key within this container is generated
in the form of an `int64`, and this is the value that is returned.

The `SparseTensor` can then be read out as part of a minibatch by passing
the key as a vector element to `TakeManySparseFromTensorsMap`.  To ensure
the correct `SparseTensorsMap` is accessed, ensure that the same
`container` and `shared_name` are passed to that Op.  If no `shared_name`
is provided here, instead use the *name* of the Operation created by calling
`AddSparseToTensorsMap` as the `shared_name` passed to
`TakeManySparseFromTensorsMap`.  Ensure the Operations are colocated.
"""
function add_sparse_to_tensors_map(v3640, v3641, v3642; name=nothing, T=nothing, container=nothing, shared_name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("AddSparseToTensorsMap") 
                begin  
                    begin  
                        if v3640 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3640)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3640)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3641 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3641)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3641)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3642 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3642)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3642)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if container !== nothing 
                            desc["container"] = container
                        end
                    end
                    begin  
                        if shared_name !== nothing 
                            desc["shared_name"] = shared_name
                        end
                    end
                end
            end), name, "AddSparseToTensorsMap") 
    tf.Tensor(tf.Operation(desc))
end

"""
     dense_to_dense_set_operation(set1, set2; validate_indices=true)

Applies set operation along last dimension of 2 `Tensor` inputs.

See SetOperationOp::SetOperationFromContext for values of `set_operation`.

Output `result` is a `SparseTensor` represented by `result_indices`,
`result_values`, and `result_shape`. For `set1` and `set2` ranked `n`, this
has rank `n` and the same 1st `n-1` dimensions as `set1` and `set2`. The `nth`
dimension contains the result of `set_operation` applied to the corresponding
`[0...n-1]` dimension of `set`.
"""
function dense_to_dense_set_operation(v3643, v3644; name=nothing, set_operation=nothing, validate_indices=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("DenseToDenseSetOperation") 
                begin  
                    begin  
                        if v3643 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3643)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3643)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3644 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3644)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3644)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if set_operation !== nothing 
                            desc["set_operation"] = set_operation
                        end
                    end
                    begin  
                        if validate_indices !== nothing 
                            desc["validate_indices"] = validate_indices
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "DenseToDenseSetOperation") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2), tf.Tensor(op, 3))
    end
end

"""
     quantized_relu(features, min_features, max_features; out_type=?)

Computes Quantized Rectified Linear: `max(features, 0)`


"""
function quantized_relu(v3645, v3646, v3647; name=nothing, Tinput=nothing, out_type=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("QuantizedRelu") 
                begin  
                    begin  
                        if v3645 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3645)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3645)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3646 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3646)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3646)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3647 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3647)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3647)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if Tinput !== nothing 
                            desc["Tinput"] = Tinput
                        end
                    end
                    begin  
                        if out_type !== nothing 
                            desc["out_type"] = out_type
                        end
                    end
                end
            end), name, "QuantizedRelu") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2), tf.Tensor(op, 3))
    end
end

"""
     sparse_softmax_cross_entropy_with_logits(features, labels; Tlabels=Int64)

Computes softmax cross entropy cost and gradients to backpropagate.

Unlike `SoftmaxCrossEntropyWithLogits`, this operation does not accept
a matrix of label probabilities, but rather a single label per row
of features.  This label is considered to have probability 1.0 for the
given row.

Inputs are the logits, not probabilities.
"""
function sparse_softmax_cross_entropy_with_logits(v3648, v3649; name=nothing, T=nothing, Tlabels=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SparseSoftmaxCrossEntropyWithLogits") 
                begin  
                    begin  
                        if v3648 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3648)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3648)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3649 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3649)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3649)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tlabels !== nothing 
                            desc["Tlabels"] = Tlabels
                        end
                    end
                end
            end), name, "SparseSoftmaxCrossEntropyWithLogits") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2))
    end
end

"""
     tensor_array_read_v2(handle, index, flow_in)

Deprecated. Use TensorArrayReadV3


"""
function tensor_array_read_v2(v3650, v3651, v3652; name=nothing, dtype=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("TensorArrayReadV2") 
                begin  
                    begin  
                        if v3650 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3650)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3650)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3651 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3651)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3651)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3652 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3652)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3652)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if dtype !== nothing 
                            desc["dtype"] = dtype
                        end
                    end
                end
            end), name, "TensorArrayReadV2") 
    tf.Tensor(tf.Operation(desc))
end

"""
     reader_serialize_state(reader_handle)

Produce a string tensor that encodes the state of a Reader.

Not all Readers support being serialized, so this can produce an
Unimplemented error.
"""
function reader_serialize_state(v3653; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ReaderSerializeState") 
                begin  
                    begin  
                        if v3653 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3653)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3653)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "ReaderSerializeState") 
    tf.Tensor(tf.Operation(desc))
end

"""
     gather_nd(params, indices)

Gather values or slices from `params` according to `indices`.

`params` is a Tensor of rank `P` and `indices` is a Tensor of rank `Q`.

`indices` must be integer tensor, containing indices into `params`.
It must be shape `[d_0, ..., d_{Q-2}, K]` where `0 < K <= P`.

The innermost dimension of `indices` (with length `K`) corresponds to
indices into elements (if `K = P`) or slices (if `K < P`) along the `K`th
dimension of `params`.

Produces an output tensor with shape

```
[d_0, ..., d_{Q-2}, params.shape[K], ..., params.shape[P-1]].
```

Some examples below.

Simple indexing into a matrix:

```python
    indices = [[0, 0], [1, 1]]
    params = [['a', 'b'], ['c', 'd']]
    output = ['a', 'd']
```

Slice indexing into a matrix:

```python
    indices = [[1], [0]]
    params = [['a', 'b'], ['c', 'd']]
    output = [['c', 'd'], ['a', 'b']]
```

Indexing into a 3-tensor:

```python
    indices = [[1]]
    params = [[['a0', 'b0'], ['c0', 'd0']],
              [['a1', 'b1'], ['c1', 'd1']]]
    output = [[['a1', 'b1'], ['c1', 'd1']]]


    indices = [[0, 1], [1, 0]]
    params = [[['a0', 'b0'], ['c0', 'd0']],
              [['a1', 'b1'], ['c1', 'd1']]]
    output = [['c0', 'd0'], ['a1', 'b1']]


    indices = [[0, 0, 1], [1, 0, 1]]
    params = [[['a0', 'b0'], ['c0', 'd0']],
              [['a1', 'b1'], ['c1', 'd1']]]
    output = ['b0', 'b1']
```

Batched indexing into a matrix:

```python
    indices = [[[0, 0]], [[0, 1]]]
    params = [['a', 'b'], ['c', 'd']]
    output = [['a'], ['b']]
```

Batched slice indexing into a matrix:

```python
    indices = [[[1]], [[0]]]
    params = [['a', 'b'], ['c', 'd']]
    output = [[['c', 'd']], [['a', 'b']]]
```

Batched indexing into a 3-tensor:

```python
    indices = [[[1]], [[0]]]
    params = [[['a0', 'b0'], ['c0', 'd0']],
              [['a1', 'b1'], ['c1', 'd1']]]
    output = [[[['a1', 'b1'], ['c1', 'd1']]],
              [[['a0', 'b0'], ['c0', 'd0']]]]

    indices = [[[0, 1], [1, 0]], [[0, 0], [1, 1]]]
    params = [[['a0', 'b0'], ['c0', 'd0']],
              [['a1', 'b1'], ['c1', 'd1']]]
    output = [[['c0', 'd0'], ['a1', 'b1']],
              [['a0', 'b0'], ['c1', 'd1']]]


    indices = [[[0, 0, 1], [1, 0, 1]], [[0, 1, 1], [1, 1, 0]]]
    params = [[['a0', 'b0'], ['c0', 'd0']],
              [['a1', 'b1'], ['c1', 'd1']]]
    output = [['b0', 'b1'], ['d0', 'c1']]
```
"""
function gather_nd(v3654, v3655; name=nothing, Tparams=nothing, Tindices=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("GatherNd") 
                begin  
                    begin  
                        if v3654 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3654)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3654)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3655 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3655)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3655)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if Tparams !== nothing 
                            desc["Tparams"] = Tparams
                        end
                    end
                    begin  
                        if Tindices !== nothing 
                            desc["Tindices"] = Tindices
                        end
                    end
                end
            end), name, "GatherNd") 
    tf.Tensor(tf.Operation(desc))
end

"""
     reader_read_up_to(reader_handle, queue_handle, num_records)

Returns up to `num_records` (key, value) pairs produced by a Reader.

Will dequeue from the input queue if necessary (e.g. when the
Reader needs to start reading from a new file since it has finished
with the previous file).
It may return less than `num_records` even before the last batch.
"""
function reader_read_up_to(v3656, v3657, v3658; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ReaderReadUpTo") 
                begin  
                    begin  
                        if v3656 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3656)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3656)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3657 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3657)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3657)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3658 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3658)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3658)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "ReaderReadUpTo") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2))
    end
end

"""
     avg_pool_3d(input)

Performs 3D average pooling on the input.


"""
function avg_pool_3d(v3659; name=nothing, ksize=nothing, strides=nothing, padding=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("AvgPool3D") 
                begin  
                    begin  
                        if v3659 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3659)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3659)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if ksize !== nothing 
                            desc["ksize"] = ksize
                        end
                    end
                    begin  
                        if strides !== nothing 
                            desc["strides"] = strides
                        end
                    end
                    begin  
                        if padding !== nothing 
                            desc["padding"] = padding
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "AvgPool3D") 
    tf.Tensor(tf.Operation(desc))
end

"""
     placeholder(; shape=TensorShape[])

A placeholder op for a value that will be fed into the computation.

N.B. This operation will fail with an error if it is executed. It is
intended as a way to represent a value that will always be fed, and to
provide attrs that enable the fed value to be checked at runtime.
"""
function placeholder(; name=nothing, dtype=nothing, shape=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Placeholder") 
                begin  
                end 
                begin  
                    begin  
                        if dtype !== nothing 
                            desc["dtype"] = dtype
                        end
                    end
                    begin  
                        if shape !== nothing 
                            desc["shape"] = shape
                        end
                    end
                end
            end), name, "Placeholder") 
    tf.Tensor(tf.Operation(desc))
end

"""
     unsafe_read_variable(resource)

Reads the value of a variable without any memory model.

The tensor returned by this operation aliases a mutable Tensor, and its value
can be observed to be different by different ops.

Internal and private to the tensorflow implementation.
"""
function unsafe_read_variable(v3660; name=nothing, dtype=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("_UnsafeReadVariable") 
                begin  
                    begin  
                        if v3660 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3660)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3660)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if dtype !== nothing 
                            desc["dtype"] = dtype
                        end
                    end
                end
            end), name, "_UnsafeReadVariable") 
    tf.Tensor(tf.Operation(desc))
end

"""
     rgbt_hsv(images; T=Float32)

Converts one or more images from RGB to HSV.

Outputs a tensor of the same shape as the `images` tensor, containing the HSV
value of the pixels. The output is only well defined if the value in `images`
are in `[0,1]`.

`output[..., 0]` contains hue, `output[..., 1]` contains saturation, and
`output[..., 2]` contains value. All HSV values are in `[0,1]`. A hue of 0
corresponds to pure red, hue 1/3 is pure green, and 2/3 is pure blue.
"""
function rgbt_hsv(v3661; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("RGBToHSV") 
                begin  
                    begin  
                        if v3661 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3661)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3661)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "RGBToHSV") 
    tf.Tensor(tf.Operation(desc))
end

"""
     encode_png(image; compression=-1, T=?)

PNG-encode an image.

`image` is a 3-D uint8 or uint16 Tensor of shape `[height, width, channels]`
where `channels` is:

*   1: for grayscale.
*   2: for grayscale + alpha.
*   3: for RGB.
*   4: for RGBA.

The ZLIB compression level, `compression`, can be -1 for the PNG-encoder
default or a value from 0 to 9.  9 is the highest compression level, generating
the smallest output, but is slower.
"""
function encode_png(v3662; name=nothing, compression=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("EncodePng") 
                begin  
                    begin  
                        if v3662 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3662)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3662)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if compression !== nothing 
                            desc["compression"] = compression
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "EncodePng") 
    tf.Tensor(tf.Operation(desc))
end

"""
     image_summary(tag, tensor; max_images=3, T=Float32, bad_color=?)

Outputs a `Summary` protocol buffer with images.

The summary has up to `max_images` summary values containing images. The
images are built from `tensor` which must be 4-D with shape `[batch_size,
height, width, channels]` and where `channels` can be:

*  1: `tensor` is interpreted as Grayscale.
*  3: `tensor` is interpreted as RGB.
*  4: `tensor` is interpreted as RGBA.

The images have the same number of channels as the input tensor. For float
input, the values are normalized one image at a time to fit in the range
`[0, 255]`.  `uint8` values are unchanged.  The op uses two different
normalization algorithms:

*  If the input values are all positive, they are rescaled so the largest one
   is 255.

*  If any input value is negative, the values are shifted so input value 0.0
   is at 127.  They are then rescaled so that either the smallest value is 0,
   or the largest one is 255.

The `tag` argument is a scalar `Tensor` of type `string`.  It is used to
build the `tag` of the summary values:

*  If `max_images` is 1, the summary value tag is '*tag*/image'.
*  If `max_images` is greater than 1, the summary value tags are
   generated sequentially as '*tag*/image/0', '*tag*/image/1', etc.

The `bad_color` argument is the color to use in the generated images for
non-finite input values.  It is a `unit8` 1-D tensor of length `channels`.
Each element must be in the range `[0, 255]` (It represents the value of a
pixel in the output image).  Non-finite values in the input tensor are
replaced by this tensor in the output image.  The default value is the color
red.
"""
function image_summary(v3663, v3664; name=nothing, max_images=nothing, T=nothing, bad_color=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ImageSummary") 
                begin  
                    begin  
                        if v3663 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3663)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3663)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3664 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3664)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3664)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if max_images !== nothing 
                            desc["max_images"] = max_images
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if bad_color !== nothing 
                            desc["bad_color"] = bad_color
                        end
                    end
                end
            end), name, "ImageSummary") 
    tf.Tensor(tf.Operation(desc))
end

"""
     strided_slice_grad(shape, begin, end, strides, dy; begin_mask=0, end_mask=0, ellipsis_mask=0, new_axis_mask=0, shrink_axis_mask=0)

Returns the gradient of `StridedSlice`.

Since `StridedSlice` cuts out pieces of its `input` which is size
`shape`, its gradient will have the same shape (which is passed here
as `shape`). The gradient will be zero in any element that the slice
does not select.

Arguments are the same as StridedSliceGrad with the exception that
`dy` is the input gradient to be propagated and `shape` is the
shape of `StridedSlice`'s `input`.
"""
function strided_slice_grad(v3665, v3666, v3667, v3668, v3669; name=nothing, T=nothing, Index=nothing, begin_mask=nothing, end_mask=nothing, ellipsis_mask=nothing, new_axis_mask=nothing, shrink_axis_mask=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("StridedSliceGrad") 
                begin  
                    begin  
                        if v3665 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Int32}, v3665)
                        else  
                            converted = convert(TensorFlow.Tensor{Int32}, v3665)
                        end 
                        begin  
                            converted = converted - 1
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3666 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Int32}, v3666)
                        else  
                            converted = convert(TensorFlow.Tensor{Int32}, v3666)
                        end 
                        begin  
                            converted = converted - 1
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3667 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Int32}, v3667)
                        else  
                            converted = convert(TensorFlow.Tensor{Int32}, v3667)
                        end 
                        begin  
                            converted = converted - 1
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3668 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Int32}, v3668)
                        else  
                            converted = convert(TensorFlow.Tensor{Int32}, v3668)
                        end 
                        begin  
                            converted = converted - 1
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3669 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3669)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3669)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Index !== nothing 
                            desc["Index"] = Index
                        end
                    end
                    begin  
                        if begin_mask !== nothing 
                            desc["begin_mask"] = begin_mask
                        end
                    end
                    begin  
                        if end_mask !== nothing 
                            desc["end_mask"] = end_mask
                        end
                    end
                    begin  
                        if ellipsis_mask !== nothing 
                            desc["ellipsis_mask"] = ellipsis_mask
                        end
                    end
                    begin  
                        if new_axis_mask !== nothing 
                            desc["new_axis_mask"] = new_axis_mask
                        end
                    end
                    begin  
                        if shrink_axis_mask !== nothing 
                            desc["shrink_axis_mask"] = shrink_axis_mask
                        end
                    end
                end
            end), name, "StridedSliceGrad") 
    tf.Tensor(tf.Operation(desc))
end

"""
     string_join(inputs; separator=)

Joins the strings in the given list of string tensors into one tensor;

with the given separator (default is an empty separator).
"""
function string_join(v3670; name=nothing, N=nothing, separator=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("StringJoin") 
                begin  
                    begin  
                        if v3670 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3670)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3670)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if N !== nothing 
                            desc["N"] = N
                        end
                    end
                    begin  
                        if separator !== nothing 
                            desc["separator"] = separator
                        end
                    end
                end
            end), name, "StringJoin") 
    tf.Tensor(tf.Operation(desc))
end

"""
     imag(input; T=?, Tout=Float32)

Returns the imaginary part of a complex number.

Given a tensor `input` of complex numbers, this operation returns a tensor of
type `float` that is the imaginary part of each element in `input`. All
elements in `input` must be complex numbers of the form \\(a + bj\\), where *a*
is the real part and *b* is the imaginary part returned by this operation.

For example:

```
# tensor 'input' is [-2.25 + 4.75j, 3.25 + 5.75j]
tf.imag(input) ==> [4.75, 5.75]
```
"""
function imag(v3671; name=nothing, T=nothing, Tout=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Imag") 
                begin  
                    begin  
                        if v3671 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3671)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3671)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tout !== nothing 
                            desc["Tout"] = Tout
                        end
                    end
                end
            end), name, "Imag") 
    tf.Tensor(tf.Operation(desc))
end

"""
     concat_offset(concat_dim, shape)

Computes offsets of concat inputs within its output.

For example:

```prettyprint
# 'x' is [2, 2, 7]
# 'y' is [2, 3, 7]
# 'z' is [2, 5, 7]
concat_offset(2, [x, y, z]) => [0, 0, 0], [0, 2, 0], [0, 5, 0]
```
"""
function concat_offset(v3672, v3673; name=nothing, N=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ConcatOffset") 
                begin  
                    begin  
                        if v3672 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3672)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3672)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3673 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3673)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3673)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if N !== nothing 
                            desc["N"] = N
                        end
                    end
                end
            end), name, "ConcatOffset") 
    tf.Tensor(tf.Operation(desc))
end

"""
     as_string(input; precision=-1, scientific=false, shortest=false, width=-1, fill=)

Converts each entry in the given tensor to strings.  Supports many numeric

types and boolean.
"""
function as_string(v3674; name=nothing, T=nothing, precision=nothing, scientific=nothing, shortest=nothing, width=nothing, fill=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("AsString") 
                begin  
                    begin  
                        if v3674 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3674)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3674)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if precision !== nothing 
                            desc["precision"] = precision
                        end
                    end
                    begin  
                        if scientific !== nothing 
                            desc["scientific"] = scientific
                        end
                    end
                    begin  
                        if shortest !== nothing 
                            desc["shortest"] = shortest
                        end
                    end
                    begin  
                        if width !== nothing 
                            desc["width"] = width
                        end
                    end
                    begin  
                        if fill !== nothing 
                            desc["fill"] = fill
                        end
                    end
                end
            end), name, "AsString") 
    tf.Tensor(tf.Operation(desc))
end

"""
     stage(values; container=, shared_name=)

Stage values similar to a lightweight Enqueue.  The basic functionality of this

Op is similar to a queue with many fewer capabilities and options.  This Op is
optimized for performance.
"""
function stage(v3675; name=nothing, dtypes=nothing, container=nothing, shared_name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Stage") 
                begin  
                    begin  
                        if v3675 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3675)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3675)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if dtypes !== nothing 
                            desc["dtypes"] = dtypes
                        end
                    end
                    begin  
                        if container !== nothing 
                            desc["container"] = container
                        end
                    end
                    begin  
                        if shared_name !== nothing 
                            desc["shared_name"] = shared_name
                        end
                    end
                end
            end), name, "Stage") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     queue_enqueue_many(handle, components; timeout_ms=-1)

Enqueues zero or more tuples of one or more tensors in the given queue.

This operation slices each component tensor along the 0th dimension to
make multiple queue elements. All of the tuple components must have the
same size in the 0th dimension.

The components input has k elements, which correspond to the components of
tuples stored in the given queue.

N.B. If the queue is full, this operation will block until the given
elements have been enqueued (or 'timeout_ms' elapses, if specified).
"""
function queue_enqueue_many(v3676, v3677; name=nothing, Tcomponents=nothing, timeout_ms=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("QueueEnqueueMany") 
                begin  
                    begin  
                        if v3676 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3676)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3676)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3677 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3677)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3677)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if Tcomponents !== nothing 
                            desc["Tcomponents"] = Tcomponents
                        end
                    end
                    begin  
                        if timeout_ms !== nothing 
                            desc["timeout_ms"] = timeout_ms
                        end
                    end
                end
            end), name, "QueueEnqueueMany") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     switch(data, pred)

Forwards `data` to the output port determined by `pred`.

If `pred` is true, the `data` input is forwarded to `output_true`. Otherwise,
the data goes to `output_false`.

See also `RefSwitch` and `Merge`.
"""
function switch(v3678, v3679; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Switch") 
                begin  
                    begin  
                        if v3678 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3678)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3678)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3679 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3679)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3679)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Switch") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2))
    end
end

"""
     sign(x)

Returns an element-wise indication of the sign of a number.

`y = sign(x) = -1` if `x < 0`; 0 if `x == 0`; 1 if `x > 0`.

For complex numbers, `y = sign(x) = x / |x|` if `x != 0`, otherwise `y = 0`.
"""
function sign(v3680; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Sign") 
                begin  
                    begin  
                        if v3680 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3680)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3680)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Sign") 
    tf.Tensor(tf.Operation(desc))
end

"""
     neg(x)

Computes numerical negative value element-wise.

I.e., \\(y = -x\\).
"""
function neg(v3681; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Neg") 
                begin  
                    begin  
                        if v3681 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3681)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3681)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Neg") 
    tf.Tensor(tf.Operation(desc))
end

"""
     queue_dequeue_many_v2(handle, n; timeout_ms=-1)

Dequeues n tuples of one or more tensors from the given queue.

If the queue is closed and there are fewer than n elements, then an
OutOfRange error is returned.

This operation concatenates queue-element component tensors along the
0th dimension to make a single component tensor.  All of the components
in the dequeued tuple will have size n in the 0th dimension.

This operation has k outputs, where k is the number of components in
the tuples stored in the given queue, and output i is the ith
component of the dequeued tuple.

N.B. If the queue is empty, this operation will block until n elements
have been dequeued (or 'timeout_ms' elapses, if specified).
"""
function queue_dequeue_many_v2(v3682, v3683; name=nothing, component_types=nothing, timeout_ms=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("QueueDequeueManyV2") 
                begin  
                    begin  
                        if v3682 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3682)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3682)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3683 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3683)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3683)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if component_types !== nothing 
                            desc["component_types"] = component_types
                        end
                    end
                    begin  
                        if timeout_ms !== nothing 
                            desc["timeout_ms"] = timeout_ms
                        end
                    end
                end
            end), name, "QueueDequeueManyV2") 
    tf.Tensor(tf.Operation(desc))
end

"""
     segment_prod(data, segment_ids)

Computes the product along segments of a tensor.

Read [the section on
Segmentation](../../api_docs/python/math_ops.md#segmentation) for an explanation
of segments.

Computes a tensor such that
\\(output_i = \prod_j data_j\\) where the product is over `j` such
that `segment_ids[j] == i`.

If the product is empty for a given segment ID `i`, `output[i] = 1`.

<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="../../images/SegmentProd.png" alt>
</div>
"""
function segment_prod(v3684, v3685; name=nothing, T=nothing, Tindices=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SegmentProd") 
                begin  
                    begin  
                        if v3684 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3684)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3684)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3685 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3685)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3685)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tindices !== nothing 
                            desc["Tindices"] = Tindices
                        end
                    end
                end
            end), name, "SegmentProd") 
    tf.Tensor(tf.Operation(desc))
end

"""
     ifft_3d(input)

Compute the inverse 3-dimensional discrete Fourier Transform over the inner-most

3 dimensions of `input`.
"""
function ifft_3d(v3686; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("IFFT3D") 
                begin  
                    begin  
                        if v3686 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3686)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3686)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "IFFT3D") 
    tf.Tensor(tf.Operation(desc))
end

"""
     sparse_reduce_sum(input_indices, input_values, input_shape, reduction_axes; keep_dims=false)

Computes the sum of elements across dimensions of a SparseTensor.

This Op takes a SparseTensor and is the sparse counterpart to
`tf.reduce_sum()`.  In particular, this Op also returns a dense `Tensor`
instead of a sparse one.

Reduces `sp_input` along the dimensions given in `reduction_axes`.  Unless
`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in
`reduction_axes`. If `keep_dims` is true, the reduced dimensions are retained
with length 1.

If `reduction_axes` has no entries, all dimensions are reduced, and a tensor
with a single element is returned.  Additionally, the axes can be negative,
which are interpreted according to the indexing rules in Python.
"""
function sparse_reduce_sum(v3687, v3688, v3689, v3690; name=nothing, keep_dims=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SparseReduceSum") 
                begin  
                    begin  
                        if v3687 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3687)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3687)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3688 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3688)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3688)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3689 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3689)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3689)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3690 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3690)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3690)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if keep_dims !== nothing 
                            desc["keep_dims"] = keep_dims
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "SparseReduceSum") 
    tf.Tensor(tf.Operation(desc))
end

"""
     approximate_equal(x, y; tolerance=nothing)

Returns the truth value of abs(x-y) < tolerance element-wise.


"""
function approximate_equal(v3691, v3692; name=nothing, T=nothing, tolerance=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ApproximateEqual") 
                begin  
                    begin  
                        if v3691 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3691)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3691)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3692 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3692)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3692)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if tolerance !== nothing 
                            desc["tolerance"] = tolerance
                        end
                    end
                end
            end), name, "ApproximateEqual") 
    tf.Tensor(tf.Operation(desc))
end

"""
     conv_3d(input, filter)

Computes a 3-D convolution given 5-D `input` and `filter` tensors.

In signal processing, cross-correlation is a measure of similarity of
two waveforms as a function of a time-lag applied to one of them. This
is also known as a sliding dot product or sliding inner-product.

Our Conv3D implements a form of cross-correlation.
"""
function conv_3d(v3693, v3694; name=nothing, T=nothing, strides=nothing, padding=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Conv3D") 
                begin  
                    begin  
                        if v3693 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3693)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3693)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3694 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3694)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3694)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if strides !== nothing 
                            desc["strides"] = strides
                        end
                    end
                    begin  
                        if padding !== nothing 
                            desc["padding"] = padding
                        end
                    end
                end
            end), name, "Conv3D") 
    tf.Tensor(tf.Operation(desc))
end

"""
     conv_2d(input, filter; use_cudnn_on_gpu=true, data_format=NHWC)

Computes a 2-D convolution given 4-D `input` and `filter` tensors.

Given an input tensor of shape `[batch, in_height, in_width, in_channels]`
and a filter / kernel tensor of shape
`[filter_height, filter_width, in_channels, out_channels]`, this op
performs the following:

1. Flattens the filter to a 2-D matrix with shape
   `[filter_height * filter_width * in_channels, output_channels]`.
2. Extracts image patches from the input tensor to form a *virtual*
   tensor of shape `[batch, out_height, out_width,
   filter_height * filter_width * in_channels]`.
3. For each patch, right-multiplies the filter matrix and the image patch
   vector.

In detail, with the default NHWC format,

    output[b, i, j, k] =
        sum_{di, dj, q} input[b, strides[1] * i + di, strides[2] * j + dj, q] *
                        filter[di, dj, q, k]

Must have `strides[0] = strides[3] = 1`.  For the most common case of the same
horizontal and vertices strides, `strides = [1, stride, stride, 1]`.
"""
function conv_2d(v3695, v3696; name=nothing, T=nothing, strides=nothing, use_cudnn_on_gpu=nothing, padding=nothing, data_format=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Conv2D") 
                begin  
                    begin  
                        if v3695 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3695)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3695)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3696 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3696)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3696)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if strides !== nothing 
                            desc["strides"] = strides
                        end
                    end
                    begin  
                        if use_cudnn_on_gpu !== nothing 
                            desc["use_cudnn_on_gpu"] = use_cudnn_on_gpu
                        end
                    end
                    begin  
                        if padding !== nothing 
                            desc["padding"] = padding
                        end
                    end
                    begin  
                        if data_format !== nothing 
                            desc["data_format"] = data_format
                        end
                    end
                end
            end), name, "Conv2D") 
    tf.Tensor(tf.Operation(desc))
end

"""
     apply_adagrad(var, accum, lr, grad; use_locking=false)

Update '*var' according to the adagrad scheme.

accum += grad * grad
var -= lr * grad * (1 / sqrt(accum))
"""
function apply_adagrad(v3697, v3698, v3699, v3700; name=nothing, T=nothing, use_locking=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ApplyAdagrad") 
                begin  
                    begin  
                        if v3697 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3697)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3697)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3698 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3698)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3698)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3699 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3699)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3699)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3700 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3700)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3700)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if use_locking !== nothing 
                            desc["use_locking"] = use_locking
                        end
                    end
                end
            end), name, "ApplyAdagrad") 
    tf.Tensor(tf.Operation(desc))
end

"""
     ref_select(index, inputs)

Forwards the `index`th element of `inputs` to `output`.


"""
function ref_select(v3701, v3702; name=nothing, T=nothing, N=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("RefSelect") 
                begin  
                    begin  
                        if v3701 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3701)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3701)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3702 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3702)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3702)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if N !== nothing 
                            desc["N"] = N
                        end
                    end
                end
            end), name, "RefSelect") 
    tf.Tensor(tf.Operation(desc))
end

"""
     sparse_mat_mul(a, b; transpose_a=false, transpose_b=false, a_is_sparse=false, b_is_sparse=false, Ta=Float32, Tb=Float32)

Multiply matrix "a" by matrix "b".

The inputs must be two-dimensional matrices and the inner dimension of "a" must
match the outer dimension of "b". This op is optimized for the case where at
least one of "a" or "b" is sparse. The breakeven for using this versus a dense
matrix multiply on one platform was 30% zero values in the sparse matrix.
"""
function sparse_mat_mul(v3703, v3704; name=nothing, transpose_a=nothing, transpose_b=nothing, a_is_sparse=nothing, b_is_sparse=nothing, Ta=nothing, Tb=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SparseMatMul") 
                begin  
                    begin  
                        if v3703 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3703)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3703)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3704 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3704)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3704)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if transpose_a !== nothing 
                            desc["transpose_a"] = transpose_a
                        end
                    end
                    begin  
                        if transpose_b !== nothing 
                            desc["transpose_b"] = transpose_b
                        end
                    end
                    begin  
                        if a_is_sparse !== nothing 
                            desc["a_is_sparse"] = a_is_sparse
                        end
                    end
                    begin  
                        if b_is_sparse !== nothing 
                            desc["b_is_sparse"] = b_is_sparse
                        end
                    end
                    begin  
                        if Ta !== nothing 
                            desc["Ta"] = Ta
                        end
                    end
                    begin  
                        if Tb !== nothing 
                            desc["Tb"] = Tb
                        end
                    end
                end
            end), name, "SparseMatMul") 
    tf.Tensor(tf.Operation(desc))
end

"""
     igammac(a, x)

Compute the upper regularized incomplete Gamma function `Q(a, x)`.

The upper regularized incomplete Gamma function is defined as:

```
Q(a, x) = Gamma(a, x) / Gamma(a) = 1 - P(a, x)
```
where
```
Gamma(a, x) = int_{x}^{\infty} t^{a-1} exp(-t) dt
```
is the upper incomplete Gama function.

Note, above `P(a, x)` (`Igamma`) is the lower regularized complete
Gamma function.
"""
function igammac(v3705, v3706; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Igammac") 
                begin  
                    begin  
                        if v3705 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3705)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3705)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3706 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3706)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3706)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Igammac") 
    tf.Tensor(tf.Operation(desc))
end

"""
     batch_mat_mul(x, y; adj_x=false, adj_y=false)

Multiplies slices of two tensors in batches.

Multiplies all slices of `Tensor` `x` and `y` (each slice can be
viewed as an element of a batch), and arranges the individual results
in a single output tensor of the same batch size. Each of the
individual slices can optionally be adjointed (to adjoint a matrix
means to transpose and conjugate it) before multiplication by setting
the `adj_x` or `adj_y` flag to `True`, which are by default `False`.

The input tensors `x` and `y` are 3-D or higher with shape `[..., r_x, c_x]`
and `[..., r_y, c_y]`.

The output tensor is 3-D or higher with shape `[..., r_o, c_o]`, where:

    r_o = c_x if adj_x else r_x
    c_o = r_y if adj_y else c_y

It is computed as:

    output[..., :, :] = matrix(x[..., :, :]) * matrix(y[..., :, :])
"""
function batch_mat_mul(v3707, v3708; name=nothing, T=nothing, adj_x=nothing, adj_y=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("BatchMatMul") 
                begin  
                    begin  
                        if v3707 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3707)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3707)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3708 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3708)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3708)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if adj_x !== nothing 
                            desc["adj_x"] = adj_x
                        end
                    end
                    begin  
                        if adj_y !== nothing 
                            desc["adj_y"] = adj_y
                        end
                    end
                end
            end), name, "BatchMatMul") 
    tf.Tensor(tf.Operation(desc))
end

"""
     batch_ifft_2d(input)




"""
function batch_ifft_2d(v3709; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("BatchIFFT2D") 
                begin  
                    begin  
                        if v3709 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3709)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3709)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "BatchIFFT2D") 
    tf.Tensor(tf.Operation(desc))
end

"""
     apply_adam(var, m, v, beta1_power, beta2_power, lr, beta1, beta2, epsilon, grad; use_locking=false)

Update '*var' according to the Adam algorithm.

lr_t <- learning_rate * sqrt(1 - beta2^t) / (1 - beta1^t)
m_t <- beta1 * m_{t-1} + (1 - beta1) * g_t
v_t <- beta2 * v_{t-1} + (1 - beta2) * g_t * g_t
variable <- variable - lr_t * m_t / (sqrt(v_t) + epsilon)
"""
function apply_adam(v3710, v3711, v3712, v3713, v3714, v3715, v3716, v3717, v3718, v3719; name=nothing, T=nothing, use_locking=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ApplyAdam") 
                begin  
                    begin  
                        if v3710 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3710)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3710)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3711 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3711)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3711)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3712 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3712)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3712)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3713 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3713)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3713)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3714 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3714)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3714)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3715 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3715)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3715)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3716 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3716)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3716)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3717 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3717)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3717)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3718 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3718)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3718)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3719 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3719)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3719)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if use_locking !== nothing 
                            desc["use_locking"] = use_locking
                        end
                    end
                end
            end), name, "ApplyAdam") 
    tf.Tensor(tf.Operation(desc))
end

"""
     adjust_contrast(images, contrast_factor, min_value, max_value)

Deprecated. Disallowed in GraphDef version >= 2.


"""
function adjust_contrast(v3720, v3721, v3722, v3723; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("AdjustContrast") 
                begin  
                    begin  
                        if v3720 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3720)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3720)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3721 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3721)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3721)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3722 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3722)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3722)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3723 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3723)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3723)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "AdjustContrast") 
    tf.Tensor(tf.Operation(desc))
end

"""
     tensor_array_pack(handle, flow_in; element_shape=TensorShape[unknown])




"""
function tensor_array_pack(v3724, v3725; name=nothing, dtype=nothing, element_shape=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("TensorArrayPack") 
                begin  
                    begin  
                        if v3724 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3724)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3724)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3725 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3725)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3725)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if dtype !== nothing 
                            desc["dtype"] = dtype
                        end
                    end
                    begin  
                        if element_shape !== nothing 
                            desc["element_shape"] = element_shape
                        end
                    end
                end
            end), name, "TensorArrayPack") 
    tf.Tensor(tf.Operation(desc))
end

"""
     reader_restore_state(reader_handle, state)

Restore a reader to a previously saved state.

Not all Readers support being restored, so this can produce an
Unimplemented error.
"""
function reader_restore_state(v3726, v3727; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ReaderRestoreState") 
                begin  
                    begin  
                        if v3726 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3726)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3726)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3727 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3727)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3727)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "ReaderRestoreState") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     queue_close_v2(handle; cancel_pending_enqueues=false)

Closes the given queue.

This operation signals that no more elements will be enqueued in the
given queue. Subsequent Enqueue(Many) operations will fail.
Subsequent Dequeue(Many) operations will continue to succeed if
sufficient elements remain in the queue. Subsequent Dequeue(Many)
operations that would block will fail immediately.
"""
function queue_close_v2(v3728; name=nothing, cancel_pending_enqueues=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("QueueCloseV2") 
                begin  
                    begin  
                        if v3728 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3728)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3728)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if cancel_pending_enqueues !== nothing 
                            desc["cancel_pending_enqueues"] = cancel_pending_enqueues
                        end
                    end
                end
            end), name, "QueueCloseV2") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     tensor_array_gather(handle, indices, flow_in; element_shape=TensorShape[unknown])




"""
function tensor_array_gather(v3729, v3730, v3731; name=nothing, dtype=nothing, element_shape=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("TensorArrayGather") 
                begin  
                    begin  
                        if v3729 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3729)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3729)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3730 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3730)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3730)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3731 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3731)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3731)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if dtype !== nothing 
                            desc["dtype"] = dtype
                        end
                    end
                    begin  
                        if element_shape !== nothing 
                            desc["element_shape"] = element_shape
                        end
                    end
                end
            end), name, "TensorArrayGather") 
    tf.Tensor(tf.Operation(desc))
end

"""
     extract_image_patches(images)

Extract `patches` from `images` and put them in the "depth" output dimension.


"""
function extract_image_patches(v3732; name=nothing, ksizes=nothing, strides=nothing, rates=nothing, T=nothing, padding=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ExtractImagePatches") 
                begin  
                    begin  
                        if v3732 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3732)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3732)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if ksizes !== nothing 
                            desc["ksizes"] = ksizes
                        end
                    end
                    begin  
                        if strides !== nothing 
                            desc["strides"] = strides
                        end
                    end
                    begin  
                        if rates !== nothing 
                            desc["rates"] = rates
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if padding !== nothing 
                            desc["padding"] = padding
                        end
                    end
                end
            end), name, "ExtractImagePatches") 
    tf.Tensor(tf.Operation(desc))
end

"""
     variable_v2(; container=, shared_name=)

Holds state in the form of a tensor that persists across steps.

Outputs a ref to the tensor state so it may be read or modified.
TODO(zhifengc/mrry): Adds a pointer to a more detail document
about sharing states in tensorflow.
"""
function variable_v2(; name=nothing, shape=nothing, dtype=nothing, container=nothing, shared_name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("VariableV2") 
                begin  
                end 
                begin  
                    begin  
                        if shape !== nothing 
                            desc["shape"] = shape
                        end
                    end
                    begin  
                        if dtype !== nothing 
                            desc["dtype"] = dtype
                        end
                    end
                    begin  
                        if container !== nothing 
                            desc["container"] = container
                        end
                    end
                    begin  
                        if shared_name !== nothing 
                            desc["shared_name"] = shared_name
                        end
                    end
                end
            end), name, "VariableV2") 
    tf.Tensor(tf.Operation(desc))
end

"""
     elu(features)

Computes exponential linear: `exp(features) - 1` if < 0, `features` otherwise.

See [Fast and Accurate Deep Network Learning by Exponential Linear Units (ELUs)
](http://arxiv.org/abs/1511.07289)
"""
function elu(v3733; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Elu") 
                begin  
                    begin  
                        if v3733 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3733)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3733)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Elu") 
    tf.Tensor(tf.Operation(desc))
end

"""
     irfft_3d(input, fft_length)

Compute the inverse 3-dimensional discrete Fourier Transform of a real-valued

signal over the inner-most 3 dimensions of `input`.

The inner-most 3 dimensions of `input` are assumed to be the result of `RFFT3D`:
The inner-most dimension contains the `fft_length / 2 + 1` unique components of
the DFT of a real-valued signal. If `fft_length` is not provided, it is computed
from the size of the inner-most 3 dimensions of `input`. If the FFT length used
to compute `input` is odd, it should be provided since it cannot be inferred
properly.
"""
function irfft_3d(v3734, v3735; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("IRFFT3D") 
                begin  
                    begin  
                        if v3734 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3734)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3734)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3735 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3735)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3735)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "IRFFT3D") 
    tf.Tensor(tf.Operation(desc))
end

"""
     scatter_update(ref, indices, updates; use_locking=true)

Applies sparse updates to a variable reference.

This operation computes

    # Scalar indices
    ref[indices, ...] = updates[...]

    # Vector indices (for each i)
    ref[indices[i], ...] = updates[i, ...]

    # High rank indices (for each i, ..., j)
    ref[indices[i, ..., j], ...] = updates[i, ..., j, ...]

This operation outputs `ref` after the update is done.
This makes it easier to chain operations that need to use the reset value.

If values in `ref` is to be updated more than once, because there are
duplicate entries in `indices`, the order at which the updates happen
for each value is undefined.

Requires `updates.shape = indices.shape + ref.shape[1:]`.

<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="../../images/ScatterUpdate.png" alt>
</div>
"""
function scatter_update(v3736, v3737, v3738; name=nothing, T=nothing, Tindices=nothing, use_locking=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ScatterUpdate") 
                begin  
                    begin  
                        if v3736 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3736)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3736)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3737 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3737)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3737)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3738 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3738)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3738)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tindices !== nothing 
                            desc["Tindices"] = Tindices
                        end
                    end
                    begin  
                        if use_locking !== nothing 
                            desc["use_locking"] = use_locking
                        end
                    end
                end
            end), name, "ScatterUpdate") 
    tf.Tensor(tf.Operation(desc))
end

"""
     apply_proximal_gradient_descent(var, alpha, l1, l2, delta; use_locking=false)

Update '*var' as FOBOS algorithm with fixed learning rate.

prox_v = var - alpha * delta
var = sign(prox_v)/(1+alpha*l2) * max{|prox_v|-alpha*l1,0}
"""
function apply_proximal_gradient_descent(v3739, v3740, v3741, v3742, v3743; name=nothing, T=nothing, use_locking=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ApplyProximalGradientDescent") 
                begin  
                    begin  
                        if v3739 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3739)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3739)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3740 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3740)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3740)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3741 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3741)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3741)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3742 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3742)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3742)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3743 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3743)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3743)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if use_locking !== nothing 
                            desc["use_locking"] = use_locking
                        end
                    end
                end
            end), name, "ApplyProximalGradientDescent") 
    tf.Tensor(tf.Operation(desc))
end

"""
     floor_mod(x, y)

Returns element-wise remainder of division. When `x < 0` xor `y < 0` is

true, this follows Python semantics in that the result here is consistent
with a flooring divide. E.g. `floor(x / y) * y + mod(x, y) = x`.

*NOTE*: `FloorMod` supports broadcasting. More about broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
"""
function floor_mod(v3744, v3745; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("FloorMod") 
                begin  
                    begin  
                        if v3744 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3744)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3744)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3745 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3745)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3745)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "FloorMod") 
    tf.Tensor(tf.Operation(desc))
end

"""
     is_nan(x)

Returns which elements of x are NaN.

@compatibility(numpy)
Equivalent to np.isnan
@end_compatibility
"""
function is_nan(v3746; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("IsNan") 
                begin  
                    begin  
                        if v3746 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3746)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3746)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "IsNan") 
    tf.Tensor(tf.Operation(desc))
end

"""
     compute_accidental_hits(true_classes, sampled_candidates; seed=0, seed2=0)

Computes the ids of the positions in sampled_candidates that match true_labels.

When doing log-odds NCE, the result of this op should be passed through a
SparseToDense op, then added to the logits of the sampled candidates. This has
the effect of 'removing' the sampled labels that match the true labels by
making the classifier sure that they are sampled labels.
"""
function compute_accidental_hits(v3747, v3748; name=nothing, num_true=nothing, seed=nothing, seed2=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ComputeAccidentalHits") 
                begin  
                    begin  
                        if v3747 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3747)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3747)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3748 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3748)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3748)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if num_true !== nothing 
                            desc["num_true"] = num_true
                        end
                    end
                    begin  
                        if seed !== nothing 
                            desc["seed"] = seed
                        end
                    end
                    begin  
                        if seed2 !== nothing 
                            desc["seed2"] = seed2
                        end
                    end
                end
            end), name, "ComputeAccidentalHits") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2), tf.Tensor(op, 3))
    end
end

"""
     string_to_number(string_tensor; out_type=Float32)

Converts each string in the input Tensor to the specified numeric type.

(Note that int32 overflow results in an error while float overflow
results in a rounded value.)
"""
function string_to_number(v3749; name=nothing, out_type=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("StringToNumber") 
                begin  
                    begin  
                        if v3749 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3749)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3749)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if out_type !== nothing 
                            desc["out_type"] = out_type
                        end
                    end
                end
            end), name, "StringToNumber") 
    tf.Tensor(tf.Operation(desc))
end

"""
     mutable_hash_table_of_tensors(; container=, shared_name=, use_node_name_sharing=false, value_shape=TensorShape[])

Creates an empty hash table.

This op creates a mutable hash table, specifying the type of its keys and
values. Each value must be a vector. Data can be inserted into the table using
the insert operations. It does not support the initialization operation.
"""
function mutable_hash_table_of_tensors(; name=nothing, container=nothing, shared_name=nothing, use_node_name_sharing=nothing, key_dtype=nothing, value_dtype=nothing, value_shape=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("MutableHashTableOfTensors") 
                begin  
                end 
                begin  
                    begin  
                        if container !== nothing 
                            desc["container"] = container
                        end
                    end
                    begin  
                        if shared_name !== nothing 
                            desc["shared_name"] = shared_name
                        end
                    end
                    begin  
                        if use_node_name_sharing !== nothing 
                            desc["use_node_name_sharing"] = use_node_name_sharing
                        end
                    end
                    begin  
                        if key_dtype !== nothing 
                            desc["key_dtype"] = key_dtype
                        end
                    end
                    begin  
                        if value_dtype !== nothing 
                            desc["value_dtype"] = value_dtype
                        end
                    end
                    begin  
                        if value_shape !== nothing 
                            desc["value_shape"] = value_shape
                        end
                    end
                end
            end), name, "MutableHashTableOfTensors") 
    tf.Tensor(tf.Operation(desc))
end

"""
     read_file(filename)

Reads and outputs the entire contents of the input filename.


"""
function read_file(v3750; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ReadFile") 
                begin  
                    begin  
                        if v3750 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3750)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3750)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "ReadFile") 
    tf.Tensor(tf.Operation(desc))
end

"""
     apply_centered_rmsp(var, mg, ms, mom, lr, rho, momentum, epsilon, grad; use_locking=false)

Update '*var' according to the centered RMSProp algorithm.

The centered RMSProp algorithm uses an estimate of the centered second moment
(i.e., the variance) for normalization, as opposed to regular RMSProp, which
uses the (uncentered) second moment. This often helps with training, but is
slightly more expensive in terms of computation and memory.

Note that in dense implementation of this algorithm, mg, ms, and mom will
update even if the grad is zero, but in this sparse implementation, mg, ms,
and mom will not update in iterations during which the grad is zero.

mean_square = decay * mean_square + (1-decay) * gradient ** 2
mean_grad = decay * mean_grad + (1-decay) * gradient

Delta = learning_rate * gradient / sqrt(mean_square + epsilon - mean_grad ** 2)

mg <- rho * mg_{t-1} + (1-rho) * grad
ms <- rho * ms_{t-1} + (1-rho) * grad * grad
mom <- momentum * mom_{t-1} + lr * grad / sqrt(ms - mg * mg + epsilon)
var <- var - mom
"""
function apply_centered_rmsp(v3751, v3752, v3753, v3754, v3755, v3756, v3757, v3758, v3759; name=nothing, T=nothing, use_locking=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ApplyCenteredRMSProp") 
                begin  
                    begin  
                        if v3751 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3751)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3751)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3752 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3752)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3752)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3753 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3753)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3753)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3754 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3754)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3754)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3755 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3755)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3755)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3756 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3756)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3756)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3757 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3757)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3757)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3758 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3758)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3758)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3759 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3759)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3759)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if use_locking !== nothing 
                            desc["use_locking"] = use_locking
                        end
                    end
                end
            end), name, "ApplyCenteredRMSProp") 
    tf.Tensor(tf.Operation(desc))
end

"""
     conv_3d_backprop_filter_v2(input, filter_sizes, out_backprop)

Computes the gradients of 3-D convolution with respect to the filter.


"""
function conv_3d_backprop_filter_v2(v3760, v3761, v3762; name=nothing, T=nothing, strides=nothing, padding=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Conv3DBackpropFilterV2") 
                begin  
                    begin  
                        if v3760 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3760)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3760)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3761 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3761)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3761)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3762 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3762)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3762)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if strides !== nothing 
                            desc["strides"] = strides
                        end
                    end
                    begin  
                        if padding !== nothing 
                            desc["padding"] = padding
                        end
                    end
                end
            end), name, "Conv3DBackpropFilterV2") 
    tf.Tensor(tf.Operation(desc))
end

"""
     learned_unigram_candidate_sampler(true_classes; seed=0, seed2=0)

Generates labels for candidate sampling with a learned unigram distribution.

See explanations of candidate sampling and the data formats at
go/candidate-sampling.

For each batch, this op picks a single set of sampled candidate labels.

The advantages of sampling candidates per-batch are simplicity and the
possibility of efficient dense matrix multiplication. The disadvantage is that
the sampled candidates must be chosen independently of the context and of the
true labels.
"""
function learned_unigram_candidate_sampler(v3763; name=nothing, num_true=nothing, num_sampled=nothing, unique=nothing, range_max=nothing, seed=nothing, seed2=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("LearnedUnigramCandidateSampler") 
                begin  
                    begin  
                        if v3763 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3763)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3763)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if num_true !== nothing 
                            desc["num_true"] = num_true
                        end
                    end
                    begin  
                        if num_sampled !== nothing 
                            desc["num_sampled"] = num_sampled
                        end
                    end
                    begin  
                        if unique !== nothing 
                            desc["unique"] = unique
                        end
                    end
                    begin  
                        if range_max !== nothing 
                            desc["range_max"] = range_max
                        end
                    end
                    begin  
                        if seed !== nothing 
                            desc["seed"] = seed
                        end
                    end
                    begin  
                        if seed2 !== nothing 
                            desc["seed2"] = seed2
                        end
                    end
                end
            end), name, "LearnedUnigramCandidateSampler") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2), tf.Tensor(op, 3))
    end
end

"""
     arg()

A graph node which represents an argument to a function.


"""
function arg(; name=nothing, T=nothing, index=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("_Arg") 
                begin  
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if index !== nothing 
                            desc["index"] = index
                        end
                    end
                end
            end), name, "_Arg") 
    tf.Tensor(tf.Operation(desc))
end

"""
     matrix_triangular_solve(matrix, rhs; lower=true, adjoint=false)

Solves systems of linear equations with upper or lower triangular matrices by

backsubstitution.

`matrix` is a tensor of shape `[..., M, M]` whose inner-most 2 dimensions form
square matrices. If `lower` is `True` then the strictly upper triangular part
of each inner-most matrix is assumed to be zero and not accessed.
If `lower` is False then the strictly lower triangular part of each inner-most
matrix is assumed to be zero and not accessed.
`rhs` is a tensor of shape `[..., M, K]`.

The output is a tensor of shape `[..., M, K]`. If `adjoint` is
`True` then the innermost matrices in output` satisfy matrix equations
`matrix[..., :, :] * output[..., :, :] = rhs[..., :, :]`.
If `adjoint` is `False` then the strictly then the  innermost matrices in
`output` satisfy matrix equations
`adjoint(matrix[..., i, k]) * output[..., k, j] = rhs[..., i, j]`.
"""
function matrix_triangular_solve(v3764, v3765; name=nothing, lower=nothing, adjoint=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("MatrixTriangularSolve") 
                begin  
                    begin  
                        if v3764 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3764)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3764)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3765 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3765)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3765)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if lower !== nothing 
                            desc["lower"] = lower
                        end
                    end
                    begin  
                        if adjoint !== nothing 
                            desc["adjoint"] = adjoint
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "MatrixTriangularSolve") 
    tf.Tensor(tf.Operation(desc))
end

"""
     fractional_avg_pool_grad(orig_input_tensor_shape, out_backprop, row_pooling_sequence, col_pooling_sequence; overlapping=false)

Computes gradient of the FractionalAvgPool function.

Unlike FractionalMaxPoolGrad, we don't need to find arg_max for
FractionalAvgPoolGrad, we just need to evenly back-propagate each element of
out_backprop to those indices that form the same pooling cell. Therefore, we
just need to know the shape of original input tensor, instead of the whole
tensor.
"""
function fractional_avg_pool_grad(v3766, v3767, v3768, v3769; name=nothing, overlapping=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("FractionalAvgPoolGrad") 
                begin  
                    begin  
                        if v3766 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3766)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3766)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3767 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3767)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3767)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3768 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3768)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3768)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3769 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3769)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3769)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if overlapping !== nothing 
                            desc["overlapping"] = overlapping
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "FractionalAvgPoolGrad") 
    tf.Tensor(tf.Operation(desc))
end

"""
     reader_num_work_units_completed(reader_handle)

Returns the number of work units this Reader has finished processing.


"""
function reader_num_work_units_completed(v3770; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ReaderNumWorkUnitsCompleted") 
                begin  
                    begin  
                        if v3770 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3770)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3770)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "ReaderNumWorkUnitsCompleted") 
    tf.Tensor(tf.Operation(desc))
end

"""
     atan(x)

Computes atan of x element-wise.


"""
function atan(v3771; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Atan") 
                begin  
                    begin  
                        if v3771 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3771)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3771)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Atan") 
    tf.Tensor(tf.Operation(desc))
end

"""
     bincount(arr, size, weights)

Counts the number of occurrences of each value in an integer array.

Outputs a vector with length `size` and the same dtype as `weights`. If
`weights` are empty, then index `i` stores the number of times the value `i` is
counted in `arr`. If `weights` are non-empty, then index `i` stores the sum of
the value in `weights` at each index where the corresponding value in `arr` is
`i`.

Values in `arr` outside of the range [0, size) are ignored.
"""
function bincount(v3772, v3773, v3774; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Bincount") 
                begin  
                    begin  
                        if v3772 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3772)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3772)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3773 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3773)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3773)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3774 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3774)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3774)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Bincount") 
    tf.Tensor(tf.Operation(desc))
end

"""
     mat_mul(a, b; transpose_a=false, transpose_b=false)

Multiply the matrix "a" by the matrix "b".

The inputs must be two-dimensional matrices and the inner dimension of
"a" (after being transposed if transpose_a is true) must match the
outer dimension of "b" (after being transposed if transposed_b is
true).

*Note*: The default kernel implementation for MatMul on GPUs uses
cublas.
"""
function mat_mul(v3775, v3776; name=nothing, transpose_a=nothing, transpose_b=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("MatMul") 
                begin  
                    begin  
                        if v3775 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3775)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3775)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3776 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3776)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3776)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if transpose_a !== nothing 
                            desc["transpose_a"] = transpose_a
                        end
                    end
                    begin  
                        if transpose_b !== nothing 
                            desc["transpose_b"] = transpose_b
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "MatMul") 
    tf.Tensor(tf.Operation(desc))
end

"""
     inv(x)

Computes the reciprocal of x element-wise.

I.e., \\(y = 1 / x\\).
"""
function inv(v3777; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Inv") 
                begin  
                    begin  
                        if v3777 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3777)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3777)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Inv") 
    tf.Tensor(tf.Operation(desc))
end

"""
     apply_proximal_adagrad(var, accum, lr, l1, l2, grad; use_locking=false)

Update '*var' and '*accum' according to FOBOS with Adagrad learning rate.

accum += grad * grad
prox_v = var - lr * grad * (1 / sqrt(accum))
var = sign(prox_v)/(1+lr*l2) * max{|prox_v|-lr*l1,0}
"""
function apply_proximal_adagrad(v3778, v3779, v3780, v3781, v3782, v3783; name=nothing, T=nothing, use_locking=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ApplyProximalAdagrad") 
                begin  
                    begin  
                        if v3778 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3778)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3778)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3779 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3779)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3779)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3780 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3780)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3780)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3781 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3781)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3781)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3782 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3782)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3782)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3783 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3783)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3783)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if use_locking !== nothing 
                            desc["use_locking"] = use_locking
                        end
                    end
                end
            end), name, "ApplyProximalAdagrad") 
    tf.Tensor(tf.Operation(desc))
end

"""
     erfc(x)

Computes the complementary error function of `x` element-wise.


"""
function erfc(v3784; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Erfc") 
                begin  
                    begin  
                        if v3784 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3784)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3784)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Erfc") 
    tf.Tensor(tf.Operation(desc))
end

"""
     sigmoid_grad(x, y)

Computes the gradient of the sigmoid of `x` wrt its input.

Specifically, `grad = dy * y * (1 - y)`, where `y = sigmoid(x)`, and
`dy` is the corresponding input gradient.
"""
function sigmoid_grad(v3785, v3786; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SigmoidGrad") 
                begin  
                    begin  
                        if v3785 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3785)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3785)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3786 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3786)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3786)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "SigmoidGrad") 
    tf.Tensor(tf.Operation(desc))
end

"""
     sparse_dense_cwise_mul(sp_indices, sp_values, sp_shape, dense)

Component-wise multiplies a SparseTensor by a dense Tensor.

The output locations corresponding to the implicitly zero elements in the sparse
tensor will be zero (i.e., will not take up storage space), regardless of the
contents of the dense tensor (even if it's +/-INF and that INF*0 == NaN).

*Limitation*: this Op only broadcasts the dense side to the sparse side, but not
the other direction.
"""
function sparse_dense_cwise_mul(v3787, v3788, v3789, v3790; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SparseDenseCwiseMul") 
                begin  
                    begin  
                        if v3787 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3787)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3787)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3788 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3788)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3788)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3789 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3789)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3789)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3790 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3790)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3790)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "SparseDenseCwiseMul") 
    tf.Tensor(tf.Operation(desc))
end

"""
     fixed_length_record_reader_v2(; header_bytes=0, footer_bytes=0, container=, shared_name=)

A Reader that outputs fixed-length records from a file.


"""
function fixed_length_record_reader_v2(; name=nothing, header_bytes=nothing, record_bytes=nothing, footer_bytes=nothing, container=nothing, shared_name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("FixedLengthRecordReaderV2") 
                begin  
                end 
                begin  
                    begin  
                        if header_bytes !== nothing 
                            desc["header_bytes"] = header_bytes
                        end
                    end
                    begin  
                        if record_bytes !== nothing 
                            desc["record_bytes"] = record_bytes
                        end
                    end
                    begin  
                        if footer_bytes !== nothing 
                            desc["footer_bytes"] = footer_bytes
                        end
                    end
                    begin  
                        if container !== nothing 
                            desc["container"] = container
                        end
                    end
                    begin  
                        if shared_name !== nothing 
                            desc["shared_name"] = shared_name
                        end
                    end
                end
            end), name, "FixedLengthRecordReaderV2") 
    tf.Tensor(tf.Operation(desc))
end

"""
     sharded_filespec(basename, num_shards)

Generate a glob pattern matching all sharded file names.


"""
function sharded_filespec(v3791, v3792; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ShardedFilespec") 
                begin  
                    begin  
                        if v3791 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3791)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3791)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3792 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3792)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3792)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "ShardedFilespec") 
    tf.Tensor(tf.Operation(desc))
end

"""
     tensor_array_concat_v3(handle, flow_in; element_shape_except0=TensorShape[unknown])

Concat the elements from the TensorArray into value `value`.

Takes `T` elements of shapes

  ```
  (n0 x d0 x d1 x ...), (n1 x d0 x d1 x ...), ..., (n(T-1) x d0 x d1 x ...)
  ```

and concatenates them into a Tensor of shape:

  ```(n0 + n1 + ... + n(T-1) x d0 x d1 x ...)```

All elements must have the same shape (excepting the first dimension).
"""
function tensor_array_concat_v3(v3793, v3794; name=nothing, dtype=nothing, element_shape_except0=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("TensorArrayConcatV3") 
                begin  
                    begin  
                        if v3793 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3793)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3793)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3794 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3794)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3794)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if dtype !== nothing 
                            desc["dtype"] = dtype
                        end
                    end
                    begin  
                        if element_shape_except0 !== nothing 
                            desc["element_shape_except0"] = element_shape_except0
                        end
                    end
                end
            end), name, "TensorArrayConcatV3") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2))
    end
end

"""
     write_file(filename, contents)

Writes contents to the file at input filename. Creates file if not existing.


"""
function write_file(v3795, v3796; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("WriteFile") 
                begin  
                    begin  
                        if v3795 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3795)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3795)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3796 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3796)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3796)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "WriteFile") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     sparse_accumulator_apply_gradient(handle, local_step, gradient_indices, gradient_values, gradient_shape)

Applies a sparse gradient to a given accumulator. Does not add if local_step is

lesser than the accumulator's global_step.
"""
function sparse_accumulator_apply_gradient(v3797, v3798, v3799, v3800, v3801; name=nothing, dtype=nothing, has_known_shape=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SparseAccumulatorApplyGradient") 
                begin  
                    begin  
                        if v3797 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3797)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3797)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3798 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3798)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3798)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3799 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3799)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3799)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3800 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3800)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3800)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3801 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3801)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3801)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if dtype !== nothing 
                            desc["dtype"] = dtype
                        end
                    end
                    begin  
                        if has_known_shape !== nothing 
                            desc["has_known_shape"] = has_known_shape
                        end
                    end
                end
            end), name, "SparseAccumulatorApplyGradient") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     barrier_insert_many(handle, keys, values)

For each key, assigns the respective value to the specified component.

If a key is not found in the barrier, this operation will create a new
incomplete element. If a key is found in the barrier, and the element
already has a value at component_index, this operation will fail with
INVALID_ARGUMENT, and leave the barrier in an undefined state.
"""
function barrier_insert_many(v3802, v3803, v3804; name=nothing, T=nothing, component_index=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("BarrierInsertMany") 
                begin  
                    begin  
                        if v3802 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3802)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3802)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3803 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3803)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3803)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3804 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3804)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3804)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if component_index !== nothing 
                            desc["component_index"] = component_index
                        end
                    end
                end
            end), name, "BarrierInsertMany") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     dilation_2d_backprop_input(input, filter, out_backprop)

Computes the gradient of morphological 2-D dilation with respect to the input.


"""
function dilation_2d_backprop_input(v3805, v3806, v3807; name=nothing, T=nothing, strides=nothing, rates=nothing, padding=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Dilation2DBackpropInput") 
                begin  
                    begin  
                        if v3805 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3805)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3805)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3806 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3806)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3806)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3807 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3807)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3807)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if strides !== nothing 
                            desc["strides"] = strides
                        end
                    end
                    begin  
                        if rates !== nothing 
                            desc["rates"] = rates
                        end
                    end
                    begin  
                        if padding !== nothing 
                            desc["padding"] = padding
                        end
                    end
                end
            end), name, "Dilation2DBackpropInput") 
    tf.Tensor(tf.Operation(desc))
end

"""
     resource_apply_adadelta(var, accum, accum_update, lr, rho, epsilon, grad; use_locking=false)

Update '*var' according to the adadelta scheme.

accum = rho() * accum + (1 - rho()) * grad.square();
update = (update_accum + epsilon).sqrt() * (accum + epsilon()).rsqrt() * grad;
update_accum = rho() * update_accum + (1 - rho()) * update.square();
var -= update;
"""
function resource_apply_adadelta(v3808, v3809, v3810, v3811, v3812, v3813, v3814; name=nothing, T=nothing, use_locking=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ResourceApplyAdadelta") 
                begin  
                    begin  
                        if v3808 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3808)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3808)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3809 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3809)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3809)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3810 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3810)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3810)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3811 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3811)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3811)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3812 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3812)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3812)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3813 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3813)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3813)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3814 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3814)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3814)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if use_locking !== nothing 
                            desc["use_locking"] = use_locking
                        end
                    end
                end
            end), name, "ResourceApplyAdadelta") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     batch_cholesky_grad(l, grad)




"""
function batch_cholesky_grad(v3815, v3816; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("BatchCholeskyGrad") 
                begin  
                    begin  
                        if v3815 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3815)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3815)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3816 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3816)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3816)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "BatchCholeskyGrad") 
    tf.Tensor(tf.Operation(desc))
end

"""
     resource_gather(resource, indices; validate_indices=true)

Gather slices from the variable pointed to by `resource` according to `indices`.

`indices` must be an integer tensor of any dimension (usually 0-D or 1-D).
Produces an output tensor with shape `indices.shape + params.shape[1:]` where:

```python
    # Scalar indices
    output[:, ..., :] = params[indices, :, ... :]

    # Vector indices
    output[i, :, ..., :] = params[indices[i], :, ... :]

    # Higher rank indices
    output[i, ..., j, :, ... :] = params[indices[i, ..., j], :, ..., :]
```
"""
function resource_gather(v3817, v3818; name=nothing, validate_indices=nothing, dtype=nothing, Tindices=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ResourceGather") 
                begin  
                    begin  
                        if v3817 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3817)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3817)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3818 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3818)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3818)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if validate_indices !== nothing 
                            desc["validate_indices"] = validate_indices
                        end
                    end
                    begin  
                        if dtype !== nothing 
                            desc["dtype"] = dtype
                        end
                    end
                    begin  
                        if Tindices !== nothing 
                            desc["Tindices"] = Tindices
                        end
                    end
                end
            end), name, "ResourceGather") 
    tf.Tensor(tf.Operation(desc))
end

"""
     logical_or(x, y)

Returns the truth value of x OR y element-wise.

*NOTE*: `LogicalOr` supports broadcasting. More about broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
"""
function logical_or(v3819, v3820; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("LogicalOr") 
                begin  
                    begin  
                        if v3819 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3819)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3819)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3820 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3820)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3820)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "LogicalOr") 
    tf.Tensor(tf.Operation(desc))
end

"""
     sin(x)

Computes sin of x element-wise.


"""
function sin(v3821; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Sin") 
                begin  
                    begin  
                        if v3821 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3821)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3821)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Sin") 
    tf.Tensor(tf.Operation(desc))
end

"""
     const_()

Returns a constant tensor.


"""
function const_(; name=nothing, value=nothing, dtype=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Const") 
                begin  
                end 
                begin  
                    begin  
                        if value !== nothing 
                            desc["value"] = value
                        end
                    end
                    begin  
                        if dtype !== nothing 
                            desc["dtype"] = dtype
                        end
                    end
                end
            end), name, "Const") 
    tf.Tensor(tf.Operation(desc))
end

"""
     dense_to_sparse_set_operation(set1, set2_indices, set2_values, set2_shape; validate_indices=true)

Applies set operation along last dimension of `Tensor` and `SparseTensor`.

See SetOperationOp::SetOperationFromContext for values of `set_operation`.

Input `set2` is a `SparseTensor` represented by `set2_indices`, `set2_values`,
and `set2_shape`. For `set2` ranked `n`, 1st `n-1` dimensions must be the same
as `set1`. Dimension `n` contains values in a set, duplicates are allowed but
ignored.

If `validate_indices` is `True`, this op validates the order and range of `set2`
indices.

Output `result` is a `SparseTensor` represented by `result_indices`,
`result_values`, and `result_shape`. For `set1` and `set2` ranked `n`, this
has rank `n` and the same 1st `n-1` dimensions as `set1` and `set2`. The `nth`
dimension contains the result of `set_operation` applied to the corresponding
`[0...n-1]` dimension of `set`.
"""
function dense_to_sparse_set_operation(v3822, v3823, v3824, v3825; name=nothing, set_operation=nothing, validate_indices=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("DenseToSparseSetOperation") 
                begin  
                    begin  
                        if v3822 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3822)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3822)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3823 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3823)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3823)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3824 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3824)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3824)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3825 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3825)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3825)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if set_operation !== nothing 
                            desc["set_operation"] = set_operation
                        end
                    end
                    begin  
                        if validate_indices !== nothing 
                            desc["validate_indices"] = validate_indices
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "DenseToSparseSetOperation") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2), tf.Tensor(op, 3))
    end
end

"""
     reader_num_records_produced(reader_handle)

Returns the number of records this Reader has produced.

This is the same as the number of ReaderRead executions that have
succeeded.
"""
function reader_num_records_produced(v3826; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ReaderNumRecordsProduced") 
                begin  
                    begin  
                        if v3826 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3826)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3826)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "ReaderNumRecordsProduced") 
    tf.Tensor(tf.Operation(desc))
end

"""
     truncate_mod(x, y)

Returns element-wise remainder of division. This emulates C semantics where

true, this follows C semantics in that the result here is consistent
with a flooring divide. E.g. `floor(x / y) * y + mod(x, y) = x`.

*NOTE*: `Mod` supports broadcasting. More about broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
"""
function truncate_mod(v3827, v3828; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("TruncateMod") 
                begin  
                    begin  
                        if v3827 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3827)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3827)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3828 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3828)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3828)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "TruncateMod") 
    tf.Tensor(tf.Operation(desc))
end

"""
     batch_fft(input)




"""
function batch_fft(v3829; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("BatchFFT") 
                begin  
                    begin  
                        if v3829 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3829)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3829)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "BatchFFT") 
    tf.Tensor(tf.Operation(desc))
end

"""
     resource_apply_proximal_gradient_descent(var, alpha, l1, l2, delta; use_locking=false)

Update '*var' as FOBOS algorithm with fixed learning rate.

prox_v = var - alpha * delta
var = sign(prox_v)/(1+alpha*l2) * max{|prox_v|-alpha*l1,0}
"""
function resource_apply_proximal_gradient_descent(v3830, v3831, v3832, v3833, v3834; name=nothing, T=nothing, use_locking=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ResourceApplyProximalGradientDescent") 
                begin  
                    begin  
                        if v3830 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3830)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3830)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3831 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3831)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3831)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3832 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3832)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3832)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3833 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3833)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3833)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3834 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3834)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3834)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if use_locking !== nothing 
                            desc["use_locking"] = use_locking
                        end
                    end
                end
            end), name, "ResourceApplyProximalGradientDescent") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     mean(input, reduction_indices; keep_dims=false, Tidx=Int32)

Computes the mean of elements across dimensions of a tensor.

Reduces `input` along the dimensions given in `reduction_indices`. Unless
`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in
`reduction_indices`. If `keep_dims` is true, the reduced dimensions are
retained with length 1.
"""
function mean(v3835, v3836; name=nothing, keep_dims=nothing, T=nothing, Tidx=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Mean") 
                begin  
                    begin  
                        if v3835 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3835)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3835)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3836 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3836)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3836)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if keep_dims !== nothing 
                            desc["keep_dims"] = keep_dims
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tidx !== nothing 
                            desc["Tidx"] = Tidx
                        end
                    end
                end
            end), name, "Mean") 
    tf.Tensor(tf.Operation(desc))
end

"""
     quantized_max_pool(input, min_input, max_input)

Produces the max pool of the input tensor for quantized types.


"""
function quantized_max_pool(v3837, v3838, v3839; name=nothing, T=nothing, ksize=nothing, strides=nothing, padding=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("QuantizedMaxPool") 
                begin  
                    begin  
                        if v3837 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3837)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3837)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3838 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3838)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3838)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3839 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3839)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3839)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if ksize !== nothing 
                            desc["ksize"] = ksize
                        end
                    end
                    begin  
                        if strides !== nothing 
                            desc["strides"] = strides
                        end
                    end
                    begin  
                        if padding !== nothing 
                            desc["padding"] = padding
                        end
                    end
                end
            end), name, "QuantizedMaxPool") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2), tf.Tensor(op, 3))
    end
end

"""
     space_to_batch(input, paddings; Tpaddings=Int32)

SpaceToBatch for 4-D tensors of type T.

This is a legacy version of the more general SpaceToBatchND.

Zero-pads and then rearranges (permutes) blocks of spatial data into batch.
More specifically, this op outputs a copy of the input tensor where values from
the `height` and `width` dimensions are moved to the `batch` dimension. After
the zero-padding, both `height` and `width` of the input must be divisible by the
block size.
"""
function space_to_batch(v3840, v3841; name=nothing, T=nothing, Tpaddings=nothing, block_size=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SpaceToBatch") 
                begin  
                    begin  
                        if v3840 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3840)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3840)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3841 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3841)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3841)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tpaddings !== nothing 
                            desc["Tpaddings"] = Tpaddings
                        end
                    end
                    begin  
                        if block_size !== nothing 
                            desc["block_size"] = block_size
                        end
                    end
                end
            end), name, "SpaceToBatch") 
    tf.Tensor(tf.Operation(desc))
end

"""
     irfft_2d(input, fft_length)

Compute the inverse 2-dimensional discrete Fourier Transform of a real-valued

signal over the inner-most 2 dimensions of `input`.

The inner-most 2 dimensions of `input` are assumed to be the result of `RFFT2D`:
The inner-most dimension contains the `fft_length / 2 + 1` unique components of
the DFT of a real-valued signal. If `fft_length` is not provided, it is computed
from the size of the inner-most 2 dimensions of `input`. If the FFT length used
to compute `input` is odd, it should be provided since it cannot be inferred
properly.
"""
function irfft_2d(v3842, v3843; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("IRFFT2D") 
                begin  
                    begin  
                        if v3842 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3842)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3842)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3843 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3843)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3843)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "IRFFT2D") 
    tf.Tensor(tf.Operation(desc))
end

"""
     adjust_hue(images, delta)

Adjust the hue of one or more images.

`images` is a tensor of at least 3 dimensions.  The last dimension is
interpretted as channels, and must be three.

The input image is considered in the RGB colorspace. Conceptually, the RGB
colors are first mapped into HSV. A delta is then applied all the hue values,
and then remapped back to RGB colorspace.
"""
function adjust_hue(v3844, v3845; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("AdjustHue") 
                begin  
                    begin  
                        if v3844 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3844)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3844)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3845 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3845)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3845)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "AdjustHue") 
    tf.Tensor(tf.Operation(desc))
end

"""
     floor(x)

Returns element-wise largest integer not greater than x.


"""
function floor(v3846; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Floor") 
                begin  
                    begin  
                        if v3846 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3846)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3846)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Floor") 
    tf.Tensor(tf.Operation(desc))
end

"""
     tile_grad(input, multiples)

Returns the gradient of `Tile`.

Since `Tile` takes an input and repeats the input `multiples` times
along each dimension, `TileGrad` takes in `multiples` and aggregates
each repeated tile of `input` into `output`.
"""
function tile_grad(v3847, v3848; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("TileGrad") 
                begin  
                    begin  
                        if v3847 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3847)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3847)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3848 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3848)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3848)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "TileGrad") 
    tf.Tensor(tf.Operation(desc))
end

"""
     real_div(x, y)

Returns x / y element-wise for real types.

If `x` and `y` are reals, this will return the floating-point division.

*NOTE*: `Div` supports broadcasting. More about broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
"""
function real_div(v3849, v3850; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("RealDiv") 
                begin  
                    begin  
                        if v3849 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3849)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3849)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3850 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3850)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3850)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "RealDiv") 
    tf.Tensor(tf.Operation(desc))
end

"""
     tensor_array_grad_v3(handle, flow_in)

Creates a TensorArray for storing the gradients of values in the given handle.

If the given TensorArray gradient already exists, returns a reference to it.

Locks the size of the original TensorArray by disabling its dynamic size flag.

**A note about the input flow_in:**

The handle flow_in forces the execution of the gradient lookup to occur
only after certain other operations have occurred.  For example, when
the forward TensorArray is dynamically sized, writes to this TensorArray
may resize the object.  The gradient TensorArray is statically sized based
on the size of the forward TensorArray when this operation executes.
Furthermore, the size of the forward TensorArray is frozen by this call.
As a result, the flow is used to ensure that the call to generate the gradient
TensorArray only happens after all writes are executed.

In the case of dynamically sized TensorArrays, gradient computation should
only be performed on read operations that have themselves been chained via
flow to occur only after all writes have executed. That way the final size
of the forward TensorArray is known when this operation is called.

**A note about the source attribute:**

TensorArray gradient calls use an accumulator TensorArray object.  If
multiple gradients are calculated and run in the same session, the multiple
gradient nodes may accidentally flow throuth the same accumulator TensorArray.
This double counts and generally breaks the TensorArray gradient flow.

The solution is to identify which gradient call this particular
TensorArray gradient is being called in.  This is performed by identifying
a unique string (e.g. "gradients", "gradients_1", ...) from the input
gradient Tensor's name.  This string is used as a suffix when creating
the TensorArray gradient object here (the attribute `source`).

The attribute `source` is added as a suffix to the forward TensorArray's
name when performing the creation / lookup, so that each separate gradient
calculation gets its own TensorArray accumulator.
"""
function tensor_array_grad_v3(v3851, v3852; name=nothing, source=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("TensorArrayGradV3") 
                begin  
                    begin  
                        if v3851 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3851)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3851)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3852 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3852)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3852)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if source !== nothing 
                            desc["source"] = source
                        end
                    end
                end
            end), name, "TensorArrayGradV3") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2))
    end
end

"""
     restore_slice(file_pattern, tensor_name, shape_and_slice; preferred_shard=-1)

Restores a tensor from checkpoint files.

This is like `Restore` except that restored tensor can be listed as filling
only a slice of a larger tensor.  `shape_and_slice` specifies the shape of the
larger tensor and the slice that the restored tensor covers.

The `shape_and_slice` input has the same format as the
elements of the `shapes_and_slices` input of the `SaveSlices` op.
"""
function restore_slice(v3853, v3854, v3855; name=nothing, dt=nothing, preferred_shard=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("RestoreSlice") 
                begin  
                    begin  
                        if v3853 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3853)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3853)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3854 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3854)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3854)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3855 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3855)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3855)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if dt !== nothing 
                            desc["dt"] = dt
                        end
                    end
                    begin  
                        if preferred_shard !== nothing 
                            desc["preferred_shard"] = preferred_shard
                        end
                    end
                end
            end), name, "RestoreSlice") 
    tf.Tensor(tf.Operation(desc))
end

"""
     sparse_apply_adagrad(var, accum, lr, grad, indices; use_locking=false)

Update relevant entries in '*var' and '*accum' according to the adagrad scheme.

That is for rows we have grad for, we update var and accum as follows:
accum += grad * grad
var -= lr * grad * (1 / sqrt(accum))
"""
function sparse_apply_adagrad(v3856, v3857, v3858, v3859, v3860; name=nothing, T=nothing, Tindices=nothing, use_locking=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SparseApplyAdagrad") 
                begin  
                    begin  
                        if v3856 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3856)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3856)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3857 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3857)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3857)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3858 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3858)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3858)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3859 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3859)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3859)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3860 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3860)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3860)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tindices !== nothing 
                            desc["Tindices"] = Tindices
                        end
                    end
                    begin  
                        if use_locking !== nothing 
                            desc["use_locking"] = use_locking
                        end
                    end
                end
            end), name, "SparseApplyAdagrad") 
    tf.Tensor(tf.Operation(desc))
end

"""
     fused_batch_norm(x, scale, offset, mean, variance; epsilon=nothing, data_format=NHWC, is_training=true)

Batch normalization.

Note that the size of 4D Tensors are defined by either "NHWC" or "NCHW".
The size of 1D Tensors matches the dimension C of the 4D Tensors.
"""
function fused_batch_norm(v3861, v3862, v3863, v3864, v3865; name=nothing, T=nothing, epsilon=nothing, data_format=nothing, is_training=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("FusedBatchNorm") 
                begin  
                    begin  
                        if v3861 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3861)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3861)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3862 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3862)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3862)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3863 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3863)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3863)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3864 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3864)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3864)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3865 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3865)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3865)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if epsilon !== nothing 
                            desc["epsilon"] = epsilon
                        end
                    end
                    begin  
                        if data_format !== nothing 
                            desc["data_format"] = data_format
                        end
                    end
                    begin  
                        if is_training !== nothing 
                            desc["is_training"] = is_training
                        end
                    end
                end
            end), name, "FusedBatchNorm") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2), tf.Tensor(op, 3), tf.Tensor(op, 4), tf.Tensor(op, 5))
    end
end

"""
     reverse(tensor, dims)

Reverses specific dimensions of a tensor.

Given a `tensor`, and a `bool` tensor `dims` representing the dimensions
of `tensor`, this operation reverses each dimension i of `tensor` where
`dims[i]` is `True`.

`tensor` can have up to 8 dimensions. The number of dimensions
of `tensor` must equal the number of elements in `dims`. In other words:

`rank(tensor) = size(dims)`

For example:

```prettyprint
# tensor 't' is [[[[ 0,  1,  2,  3],
#                  [ 4,  5,  6,  7],
#                  [ 8,  9, 10, 11]],
#                 [[12, 13, 14, 15],
#                  [16, 17, 18, 19],
#                  [20, 21, 22, 23]]]]
# tensor 't' shape is [1, 2, 3, 4]

# 'dims' is [False, False, False, True]
reverse(t, dims) ==> [[[[ 3,  2,  1,  0],
                        [ 7,  6,  5,  4],
                        [ 11, 10, 9, 8]],
                       [[15, 14, 13, 12],
                        [19, 18, 17, 16],
                        [23, 22, 21, 20]]]]

# 'dims' is [False, True, False, False]
reverse(t, dims) ==> [[[[12, 13, 14, 15],
                        [16, 17, 18, 19],
                        [20, 21, 22, 23]
                       [[ 0,  1,  2,  3],
                        [ 4,  5,  6,  7],
                        [ 8,  9, 10, 11]]]]

# 'dims' is [False, False, True, False]
reverse(t, dims) ==> [[[[8, 9, 10, 11],
                        [4, 5, 6, 7],
                        [0, 1, 2, 3]]
                       [[20, 21, 22, 23],
                        [16, 17, 18, 19],
                        [12, 13, 14, 15]]]]
```
"""
function reverse(v3866, v3867; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Reverse") 
                begin  
                    begin  
                        if v3866 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3866)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3866)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3867 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3867)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3867)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Reverse") 
    tf.Tensor(tf.Operation(desc))
end

"""
     logical_and(x, y)

Returns the truth value of x AND y element-wise.

*NOTE*: `LogicalAnd` supports broadcasting. More about broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
"""
function logical_and(v3868, v3869; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("LogicalAnd") 
                begin  
                    begin  
                        if v3868 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3868)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3868)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3869 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3869)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3869)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "LogicalAnd") 
    tf.Tensor(tf.Operation(desc))
end

"""
     get_session_tensor(handle)

Get the value of the tensor specified by its handle.


"""
function get_session_tensor(v3870; name=nothing, dtype=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("GetSessionTensor") 
                begin  
                    begin  
                        if v3870 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3870)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3870)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if dtype !== nothing 
                            desc["dtype"] = dtype
                        end
                    end
                end
            end), name, "GetSessionTensor") 
    tf.Tensor(tf.Operation(desc))
end

"""
     decode_png(contents; channels=0, dtype=?)

Decode a PNG-encoded image to a uint8 or uint16 tensor.

The attr `channels` indicates the desired number of color channels for the
decoded image.

Accepted values are:

*   0: Use the number of channels in the PNG-encoded image.
*   1: output a grayscale image.
*   3: output an RGB image.
*   4: output an RGBA image.

If needed, the PNG-encoded image is transformed to match the requested number
of color channels.
"""
function decode_png(v3871; name=nothing, channels=nothing, dtype=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("DecodePng") 
                begin  
                    begin  
                        if v3871 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3871)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3871)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if channels !== nothing 
                            desc["channels"] = channels
                        end
                    end
                    begin  
                        if dtype !== nothing 
                            desc["dtype"] = dtype
                        end
                    end
                end
            end), name, "DecodePng") 
    tf.Tensor(tf.Operation(desc))
end

"""
     igamma(a, x)

Compute the lower regularized incomplete Gamma function `Q(a, x)`.

The lower regularized incomplete Gamma function is defined as:

```
P(a, x) = gamma(a, x) / Gamma(a) = 1 - Q(a, x)
```
where
```
gamma(a, x) = int_{0}^{x} t^{a-1} exp(-t) dt
```
is the lower incomplete Gamma function.

Note, above `Q(a, x)` (`Igammac`) is the upper regularized complete
Gamma function.
"""
function igamma(v3872, v3873; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Igamma") 
                begin  
                    begin  
                        if v3872 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3872)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3872)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3873 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3873)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3873)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Igamma") 
    tf.Tensor(tf.Operation(desc))
end

"""
     tensor_array_gather_v3(handle, indices, flow_in; element_shape=TensorShape[unknown])

Gather specific elements from the TensorArray into output `value`.

All elements selected by `indices` must have the same shape.
"""
function tensor_array_gather_v3(v3874, v3875, v3876; name=nothing, dtype=nothing, element_shape=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("TensorArrayGatherV3") 
                begin  
                    begin  
                        if v3874 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3874)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3874)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3875 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3875)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3875)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3876 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3876)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3876)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if dtype !== nothing 
                            desc["dtype"] = dtype
                        end
                    end
                    begin  
                        if element_shape !== nothing 
                            desc["element_shape"] = element_shape
                        end
                    end
                end
            end), name, "TensorArrayGatherV3") 
    tf.Tensor(tf.Operation(desc))
end

"""
     digamma(x)

Computes Psi, the derivative of Lgamma (the log of the absolute value of

`Gamma(x)`), element-wise.
"""
function digamma(v3877; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Digamma") 
                begin  
                    begin  
                        if v3877 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3877)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3877)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Digamma") 
    tf.Tensor(tf.Operation(desc))
end

"""
     destroy_resource_op(resource; ignore_lookup_error=true)

Deletes the resource specified by the handle.

All subsequent operations using the resource will result in a NotFound
error status.
"""
function destroy_resource_op(v3878; name=nothing, ignore_lookup_error=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("DestroyResourceOp") 
                begin  
                    begin  
                        if v3878 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3878)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3878)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if ignore_lookup_error !== nothing 
                            desc["ignore_lookup_error"] = ignore_lookup_error
                        end
                    end
                end
            end), name, "DestroyResourceOp") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     text_line_reader(; skip_header_lines=0, container=, shared_name=)

A Reader that outputs the lines of a file delimited by '\n'.


"""
function text_line_reader(; name=nothing, skip_header_lines=nothing, container=nothing, shared_name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("TextLineReader") 
                begin  
                end 
                begin  
                    begin  
                        if skip_header_lines !== nothing 
                            desc["skip_header_lines"] = skip_header_lines
                        end
                    end
                    begin  
                        if container !== nothing 
                            desc["container"] = container
                        end
                    end
                    begin  
                        if shared_name !== nothing 
                            desc["shared_name"] = shared_name
                        end
                    end
                end
            end), name, "TextLineReader") 
    tf.Tensor(tf.Operation(desc))
end

"""
     text_line_reader_v2(; skip_header_lines=0, container=, shared_name=)

A Reader that outputs the lines of a file delimited by '\n'.


"""
function text_line_reader_v2(; name=nothing, skip_header_lines=nothing, container=nothing, shared_name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("TextLineReaderV2") 
                begin  
                end 
                begin  
                    begin  
                        if skip_header_lines !== nothing 
                            desc["skip_header_lines"] = skip_header_lines
                        end
                    end
                    begin  
                        if container !== nothing 
                            desc["container"] = container
                        end
                    end
                    begin  
                        if shared_name !== nothing 
                            desc["shared_name"] = shared_name
                        end
                    end
                end
            end), name, "TextLineReaderV2") 
    tf.Tensor(tf.Operation(desc))
end

"""
     betainc(a, b, x)

Compute the regularized incomplete beta integral \\(I_x(a, b)\\).

The regularized incomplete beta integral is defined as:

```
I_x(a, b) = \frac{B(x; a, b)}{B(a, b)}
```
where

```
B(x; a, b) = \int_0^x t^{a-1} (1 - t)^{b-1} dt
```

is the incomplete beta function and \\(B(a, b)\\) is the *complete*
beta function.
"""
function betainc(v3879, v3880, v3881; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Betainc") 
                begin  
                    begin  
                        if v3879 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3879)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3879)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3880 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3880)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3880)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3881 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3881)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3881)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Betainc") 
    tf.Tensor(tf.Operation(desc))
end

"""
     space_to_depth(input)

SpaceToDepth for tensors of type T.

Rearranges blocks of spatial data, into depth. More specifically,
this op outputs a copy of the input tensor where values from the `height`
and `width` dimensions are moved to the `depth` dimension.
The attr `block_size` indicates the input block size and how the data is moved.

  * Non-overlapping blocks of size `block_size x block size` are rearranged
    into depth at each location.
  * The depth of the output tensor is `input_depth * block_size * block_size`.
  * The input tensor's height and width must be divisible by block_size.

That is, assuming the input is in the shape:
`[batch, height, width, depth]`,
the shape of the output will be:
`[batch, height/block_size, width/block_size, depth*block_size*block_size]`

This operation requires that the input tensor be of rank 4, and that
`block_size` be >=1 and a divisor of both the input `height` and `width`.

This operation is useful for resizing the activations between convolutions
(but keeping all data), e.g. instead of pooling. It is also useful for training
purely convolutional models.

For example, given this input of shape `[1, 2, 2, 1]`, and block_size of 2:

```prettyprint
x = [[[[1], [2]],
      [[3], [4]]]]
```

This operation will output a tensor of shape `[1, 1, 1, 4]`:

```prettyprint
[[[[1, 2, 3, 4]]]]
```

Here, the input has a batch of 1 and each batch element has shape `[2, 2, 1]`,
the corresponding output will have a single element (i.e. width and height are
both 1) and will have a depth of 4 channels (1 * block_size * block_size).
The output element shape is `[1, 1, 4]`.

For an input tensor with larger depth, here of shape `[1, 2, 2, 3]`, e.g.

```prettyprint
x = [[[[1, 2, 3], [4, 5, 6]],
      [[7, 8, 9], [10, 11, 12]]]]
```

This operation, for block_size of 2, will return the following tensor of shape
`[1, 1, 1, 12]`

```prettyprint
[[[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]]]]
```

Similarly, for the following input of shape `[1 4 4 1]`, and a block size of 2:

```prettyprint
x = [[[[1],   [2],  [5],  [6]],
      [[3],   [4],  [7],  [8]],
      [[9],  [10], [13],  [14]],
      [[11], [12], [15],  [16]]]]
```

the operator will return the following tensor of shape `[1 2 2 4]`:

```prettyprint
x = [[[[1, 2, 3, 4],
       [5, 6, 7, 8]],
      [[9, 10, 11, 12],
       [13, 14, 15, 16]]]]
```
"""
function space_to_depth(v3882; name=nothing, T=nothing, block_size=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SpaceToDepth") 
                begin  
                    begin  
                        if v3882 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3882)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3882)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if block_size !== nothing 
                            desc["block_size"] = block_size
                        end
                    end
                end
            end), name, "SpaceToDepth") 
    tf.Tensor(tf.Operation(desc))
end

"""
     sqrt_grad(x, y)

Computes the gradient for the sqrt of `x` wrt its input.

Specifically, `grad = dy * 0.5 / y`, where `y = sqrt(x)`, and `dy`
is the corresponding input gradient.
"""
function sqrt_grad(v3883, v3884; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SqrtGrad") 
                begin  
                    begin  
                        if v3883 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3883)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3883)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3884 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3884)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3884)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "SqrtGrad") 
    tf.Tensor(tf.Operation(desc))
end

"""
     tensor_array_scatter_v3(handle, indices, value, flow_in)

Scatter the data from the input value into specific TensorArray elements.

`indices` must be a vector, its length must match the first dim of `value`.
"""
function tensor_array_scatter_v3(v3885, v3886, v3887, v3888; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("TensorArrayScatterV3") 
                begin  
                    begin  
                        if v3885 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3885)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3885)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3886 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3886)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3886)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3887 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3887)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3887)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3888 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3888)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3888)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "TensorArrayScatterV3") 
    tf.Tensor(tf.Operation(desc))
end

"""
     resize_nearest_neighbor_grad(grads, size; align_corners=false)

Computes the gradient of nearest neighbor interpolation.


"""
function resize_nearest_neighbor_grad(v3889, v3890; name=nothing, T=nothing, align_corners=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ResizeNearestNeighborGrad") 
                begin  
                    begin  
                        if v3889 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3889)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3889)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3890 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3890)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3890)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if align_corners !== nothing 
                            desc["align_corners"] = align_corners
                        end
                    end
                end
            end), name, "ResizeNearestNeighborGrad") 
    tf.Tensor(tf.Operation(desc))
end

"""
     qr(input; full_matrices=false)

Computes the QR decompositions of one or more matrices.

Computes the QR decomposition of each inner matrix in `tensor` such that
`tensor[..., :, :] = q[..., :, :] * r[..., :,:])`

```prettyprint
# a is a tensor.
# q is a tensor of orthonormal matrices.
# r is a tensor of upper triangular matrices.
q, r = qr(a)
q_full, r_full = qr(a, full_matrices=True)
```
"""
function qr(v3891; name=nothing, full_matrices=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Qr") 
                begin  
                    begin  
                        if v3891 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3891)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3891)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if full_matrices !== nothing 
                            desc["full_matrices"] = full_matrices
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Qr") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2))
    end
end

"""
     tanh_grad(x, y)

Computes the gradient for the tanh of `x` wrt its input.

Specifically, `grad = dy * (1 - y*y)`, where `y = tanh(x)`, and `dy`
is the corresponding input gradient.
"""
function tanh_grad(v3892, v3893; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("TanhGrad") 
                begin  
                    begin  
                        if v3892 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3892)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3892)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3893 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3893)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3893)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "TanhGrad") 
    tf.Tensor(tf.Operation(desc))
end

"""
     decode_base_64(input)

Decode web-safe base64-encoded strings.

Input may or may not have padding at the end. See EncodeBase64 for padding.
Web-safe means that input must use - and _ instead of + and /.
"""
function decode_base_64(v3894; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("DecodeBase64") 
                begin  
                    begin  
                        if v3894 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3894)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3894)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "DecodeBase64") 
    tf.Tensor(tf.Operation(desc))
end

"""
     audio_summary_v2(tag, tensor, sample_rate; max_outputs=3)

Outputs a `Summary` protocol buffer with audio.

The summary has up to `max_outputs` summary values containing audio. The
audio is built from `tensor` which must be 3-D with shape `[batch_size,
frames, channels]` or 2-D with shape `[batch_size, frames]`. The values are
assumed to be in the range of `[-1.0, 1.0]` with a sample rate of `sample_rate`.

The `tag` argument is a scalar `Tensor` of type `string`.  It is used to
build the `tag` of the summary values:

*  If `max_outputs` is 1, the summary value tag is '*tag*/audio'.
*  If `max_outputs` is greater than 1, the summary value tags are
   generated sequentially as '*tag*/audio/0', '*tag*/audio/1', etc.
"""
function audio_summary_v2(v3895, v3896, v3897; name=nothing, max_outputs=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("AudioSummaryV2") 
                begin  
                    begin  
                        if v3895 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3895)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3895)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3896 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3896)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3896)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3897 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3897)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3897)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if max_outputs !== nothing 
                            desc["max_outputs"] = max_outputs
                        end
                    end
                end
            end), name, "AudioSummaryV2") 
    tf.Tensor(tf.Operation(desc))
end

"""
     mirror_pad(input, paddings; Tpaddings=Int32)

Pads a tensor with mirrored values.

This operation pads a `input` with mirrored values according to the `paddings`
you specify. `paddings` is an integer tensor with shape `[n, 2]`, where n is
the rank of `input`. For each dimension D of `input`, `paddings[D, 0]` indicates
how many values to add before the contents of `input` in that dimension, and
`paddings[D, 1]` indicates how many values to add after the contents of `input`
in that dimension. Both `paddings[D, 0]` and `paddings[D, 1]` must be no greater
than `input.dim_size(D)` (or `input.dim_size(D) - 1`) if `copy_border` is true
(if false, respectively).

The padded size of each dimension D of the output is:

`paddings(D, 0) + input.dim_size(D) + paddings(D, 1)`

For example:

```prettyprint
# 't' is [[1, 2, 3], [4, 5, 6]].
# 'paddings' is [[1, 1]], [2, 2]].
# 'mode' is SYMMETRIC.
# rank of 't' is 2.
pad(t, paddings) ==> [[2, 1, 1, 2, 3, 3, 2]
                      [2, 1, 1, 2, 3, 3, 2]
                      [5, 4, 4, 5, 6, 6, 5]
                      [5, 4, 4, 5, 6, 6, 5]]
```
"""
function mirror_pad(v3898, v3899; name=nothing, T=nothing, Tpaddings=nothing, mode=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("MirrorPad") 
                begin  
                    begin  
                        if v3898 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3898)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3898)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3899 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3899)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3899)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tpaddings !== nothing 
                            desc["Tpaddings"] = Tpaddings
                        end
                    end
                    begin  
                        if mode !== nothing 
                            desc["mode"] = mode
                        end
                    end
                end
            end), name, "MirrorPad") 
    tf.Tensor(tf.Operation(desc))
end

"""
     logical_not(x)

Returns the truth value of NOT x element-wise.


"""
function logical_not(v3900; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("LogicalNot") 
                begin  
                    begin  
                        if v3900 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3900)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3900)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "LogicalNot") 
    tf.Tensor(tf.Operation(desc))
end

"""
     log_softmax(logits)

Computes log softmax activations.

For each batch `i` and class `j` we have

    logsoftmax[i, j] = logits[i, j] - log(sum(exp(logits[i])))
"""
function log_softmax(v3901; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("LogSoftmax") 
                begin  
                    begin  
                        if v3901 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3901)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3901)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "LogSoftmax") 
    tf.Tensor(tf.Operation(desc))
end

"""
     batch_ifft(input)




"""
function batch_ifft(v3902; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("BatchIFFT") 
                begin  
                    begin  
                        if v3902 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3902)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3902)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "BatchIFFT") 
    tf.Tensor(tf.Operation(desc))
end

"""
     fake_quant_with_min_max_args_gradient(gradients, inputs; min=nothing, max=nothing)

Compute gradients for a FakeQuantWithMinMaxArgs operation.


"""
function fake_quant_with_min_max_args_gradient(v3903, v3904; name=nothing, min=nothing, max=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("FakeQuantWithMinMaxArgsGradient") 
                begin  
                    begin  
                        if v3903 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3903)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3903)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3904 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3904)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3904)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if min !== nothing 
                            desc["min"] = min
                        end
                    end
                    begin  
                        if max !== nothing 
                            desc["max"] = max
                        end
                    end
                end
            end), name, "FakeQuantWithMinMaxArgsGradient") 
    tf.Tensor(tf.Operation(desc))
end

"""
     random_uniform(shape; seed=0, seed2=0)

Outputs random values from a uniform distribution.

The generated values follow a uniform distribution in the range `[0, 1)`. The
lower bound 0 is included in the range, while the upper bound 1 is excluded.
"""
function random_uniform(v3905; name=nothing, seed=nothing, seed2=nothing, dtype=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("RandomUniform") 
                begin  
                    begin  
                        if v3905 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3905)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3905)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if seed !== nothing 
                            desc["seed"] = seed
                        end
                    end
                    begin  
                        if seed2 !== nothing 
                            desc["seed2"] = seed2
                        end
                    end
                    begin  
                        if dtype !== nothing 
                            desc["dtype"] = dtype
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "RandomUniform") 
    tf.Tensor(tf.Operation(desc))
end

"""
     batch_svd(input; compute_uv=true, full_matrices=false)




"""
function batch_svd(v3906; name=nothing, compute_uv=nothing, full_matrices=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("BatchSvd") 
                begin  
                    begin  
                        if v3906 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3906)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3906)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if compute_uv !== nothing 
                            desc["compute_uv"] = compute_uv
                        end
                    end
                    begin  
                        if full_matrices !== nothing 
                            desc["full_matrices"] = full_matrices
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "BatchSvd") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2), tf.Tensor(op, 3))
    end
end

"""
     resource_sparse_apply_ftrl(var, accum, linear, grad, indices, lr, l1, l2, lr_power; use_locking=false)

Update relevant entries in '*var' according to the Ftrl-proximal scheme.

That is for rows we have grad for, we update var, accum and linear as follows:
accum_new = accum + grad * grad
linear += grad + (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var
quadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2
var = (sign(linear) * l1 - linear) / quadratic if |linear| > l1 else 0.0
accum = accum_new
"""
function resource_sparse_apply_ftrl(v3907, v3908, v3909, v3910, v3911, v3912, v3913, v3914, v3915; name=nothing, T=nothing, Tindices=nothing, use_locking=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ResourceSparseApplyFtrl") 
                begin  
                    begin  
                        if v3907 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3907)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3907)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3908 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3908)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3908)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3909 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3909)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3909)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3910 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3910)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3910)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3911 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3911)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3911)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3912 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3912)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3912)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3913 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3913)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3913)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3914 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3914)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3914)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3915 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3915)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3915)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tindices !== nothing 
                            desc["Tindices"] = Tindices
                        end
                    end
                    begin  
                        if use_locking !== nothing 
                            desc["use_locking"] = use_locking
                        end
                    end
                end
            end), name, "ResourceSparseApplyFtrl") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     reader_reset(reader_handle)

Restore a Reader to its initial clean state.


"""
function reader_reset(v3916; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ReaderReset") 
                begin  
                    begin  
                        if v3916 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3916)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3916)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "ReaderReset") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     resize_nearest_neighbor(images, size; align_corners=false)

Resize `images` to `size` using nearest neighbor interpolation.


"""
function resize_nearest_neighbor(v3917, v3918; name=nothing, T=nothing, align_corners=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ResizeNearestNeighbor") 
                begin  
                    begin  
                        if v3917 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3917)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3917)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3918 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3918)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3918)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if align_corners !== nothing 
                            desc["align_corners"] = align_corners
                        end
                    end
                end
            end), name, "ResizeNearestNeighbor") 
    tf.Tensor(tf.Operation(desc))
end

"""
     size(input; out_type=Int32)

Returns the size of a tensor.

This operation returns an integer representing the number of elements in
`input`.

For example:

```prettyprint
# 't' is [[[1, 1,, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]]
size(t) ==> 12
```
"""
function size(v3919; name=nothing, T=nothing, out_type=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Size") 
                begin  
                    begin  
                        if v3919 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3919)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3919)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if out_type !== nothing 
                            desc["out_type"] = out_type
                        end
                    end
                end
            end), name, "Size") 
    tf.Tensor(tf.Operation(desc))
end

"""
     add_n(inputs)

Add all input tensors element wise.


"""
function add_n(v3920; name=nothing, N=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("AddN") 
                begin  
                    begin  
                        if v3920 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3920)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3920)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if N !== nothing 
                            desc["N"] = N
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "AddN") 
    tf.Tensor(tf.Operation(desc))
end

"""
     sparse_segment_sum(data, indices, segment_ids; Tidx=Int32)

Computes the sum along sparse segments of a tensor.

Read [the section on
Segmentation](../../api_docs/python/math_ops.md#segmentation) for an explanation
of segments.

Like `SegmentSum`, but `segment_ids` can have rank less than `data`'s first
dimension, selecting a subset of dimension 0, specified by `indices`.

For example:

```prettyprint
c = tf.constant([[1,2,3,4], [-1,-2,-3,-4], [5,6,7,8]])

# Select two rows, one segment.
tf.sparse_segment_sum(c, tf.constant([0, 1]), tf.constant([0, 0]))
  ==> [[0 0 0 0]]

# Select two rows, two segment.
tf.sparse_segment_sum(c, tf.constant([0, 1]), tf.constant([0, 1]))
  ==> [[ 1  2  3  4]
       [-1 -2 -3 -4]]

# Select all rows, two segments.
tf.sparse_segment_sum(c, tf.constant([0, 1, 2]), tf.constant([0, 0, 1]))
  ==> [[0 0 0 0]
       [5 6 7 8]]

# Which is equivalent to:
tf.segment_sum(c, tf.constant([0, 0, 1]))
```
"""
function sparse_segment_sum(v3921, v3922, v3923; name=nothing, T=nothing, Tidx=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SparseSegmentSum") 
                begin  
                    begin  
                        if v3921 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3921)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3921)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3922 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3922)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3922)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3923 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3923)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3923)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tidx !== nothing 
                            desc["Tidx"] = Tidx
                        end
                    end
                end
            end), name, "SparseSegmentSum") 
    tf.Tensor(tf.Operation(desc))
end

"""
     batch_matrix_determinant(input)




"""
function batch_matrix_determinant(v3924; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("BatchMatrixDeterminant") 
                begin  
                    begin  
                        if v3924 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3924)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3924)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "BatchMatrixDeterminant") 
    tf.Tensor(tf.Operation(desc))
end

"""
     batch_matrix_diag(diagonal)




"""
function batch_matrix_diag(v3925; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("BatchMatrixDiag") 
                begin  
                    begin  
                        if v3925 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3925)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3925)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "BatchMatrixDiag") 
    tf.Tensor(tf.Operation(desc))
end

"""
     sum(input, reduction_indices; keep_dims=false, Tidx=Int32)

Computes the sum of elements across dimensions of a tensor.

Reduces `input` along the dimensions given in `reduction_indices`. Unless
`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in
`reduction_indices`. If `keep_dims` is true, the reduced dimensions are
retained with length 1.
"""
function sum(v3926, v3927; name=nothing, keep_dims=nothing, T=nothing, Tidx=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Sum") 
                begin  
                    begin  
                        if v3926 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3926)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3926)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3927 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3927)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3927)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if keep_dims !== nothing 
                            desc["keep_dims"] = keep_dims
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tidx !== nothing 
                            desc["Tidx"] = Tidx
                        end
                    end
                end
            end), name, "Sum") 
    tf.Tensor(tf.Operation(desc))
end

"""
     less_equal(x, y)

Returns the truth value of (x <= y) element-wise.

*NOTE*: `LessEqual` supports broadcasting. More about broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
"""
function less_equal(v3928, v3929; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("LessEqual") 
                begin  
                    begin  
                        if v3928 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3928)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3928)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3929 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3929)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3929)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "LessEqual") 
    tf.Tensor(tf.Operation(desc))
end

"""
     is_inf(x)

Returns which elements of x are Inf.

@compatibility(numpy)
Equivalent to np.isinf
@end_compatibility
"""
function is_inf(v3930; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("IsInf") 
                begin  
                    begin  
                        if v3930 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3930)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3930)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "IsInf") 
    tf.Tensor(tf.Operation(desc))
end

"""
     tensor_array_concat_v2(handle, flow_in; element_shape_except0=TensorShape[unknown])

Deprecated. Use TensorArrayConcatV3


"""
function tensor_array_concat_v2(v3931, v3932; name=nothing, dtype=nothing, element_shape_except0=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("TensorArrayConcatV2") 
                begin  
                    begin  
                        if v3931 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3931)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3931)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3932 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3932)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3932)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if dtype !== nothing 
                            desc["dtype"] = dtype
                        end
                    end
                    begin  
                        if element_shape_except0 !== nothing 
                            desc["element_shape_except0"] = element_shape_except0
                        end
                    end
                end
            end), name, "TensorArrayConcatV2") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2))
    end
end

"""
     apply_gradient_descent(var, alpha, delta; use_locking=false)

Update '*var' by subtracting 'alpha' * 'delta' from it.


"""
function apply_gradient_descent(v3933, v3934, v3935; name=nothing, T=nothing, use_locking=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ApplyGradientDescent") 
                begin  
                    begin  
                        if v3933 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3933)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3933)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3934 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3934)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3934)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3935 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3935)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3935)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if use_locking !== nothing 
                            desc["use_locking"] = use_locking
                        end
                    end
                end
            end), name, "ApplyGradientDescent") 
    tf.Tensor(tf.Operation(desc))
end

"""
     resource_sparse_apply_adagrad(var, accum, lr, grad, indices; use_locking=false)

Update relevant entries in '*var' and '*accum' according to the adagrad scheme.

That is for rows we have grad for, we update var and accum as follows:
accum += grad * grad
var -= lr * grad * (1 / sqrt(accum))
"""
function resource_sparse_apply_adagrad(v3936, v3937, v3938, v3939, v3940; name=nothing, T=nothing, Tindices=nothing, use_locking=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ResourceSparseApplyAdagrad") 
                begin  
                    begin  
                        if v3936 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3936)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3936)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3937 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3937)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3937)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3938 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3938)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3938)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3939 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3939)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3939)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3940 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3940)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3940)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tindices !== nothing 
                            desc["Tindices"] = Tindices
                        end
                    end
                    begin  
                        if use_locking !== nothing 
                            desc["use_locking"] = use_locking
                        end
                    end
                end
            end), name, "ResourceSparseApplyAdagrad") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     sparse_segment_sqrt_n(data, indices, segment_ids; Tidx=Int32)

Computes the sum along sparse segments of a tensor divided by the sqrt of N.

N is the size of the segment being reduced.

Read [the section on
Segmentation](../../api_docs/python/math_ops.md#segmentation) for an explanation
of segments.
"""
function sparse_segment_sqrt_n(v3941, v3942, v3943; name=nothing, T=nothing, Tidx=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SparseSegmentSqrtN") 
                begin  
                    begin  
                        if v3941 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3941)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3941)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3942 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3942)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3942)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3943 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3943)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3943)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tidx !== nothing 
                            desc["Tidx"] = Tidx
                        end
                    end
                end
            end), name, "SparseSegmentSqrtN") 
    tf.Tensor(tf.Operation(desc))
end

"""
     fixed_unigram_candidate_sampler(true_classes; vocab_file=, distortion=nothing, num_reserved_ids=0, num_shards=1, shard=0, unigrams=Int64[], seed=0, seed2=0)

Generates labels for candidate sampling with a learned unigram distribution.

A unigram sampler could use a fixed unigram distribution read from a
file or passed in as an in-memory array instead of building up the distribution
from data on the fly. There is also an option to skew the distribution by
applying a distortion power to the weights.

The vocabulary file should be in CSV-like format, with the last field
being the weight associated with the word.

For each batch, this op picks a single set of sampled candidate labels.

The advantages of sampling candidates per-batch are simplicity and the
possibility of efficient dense matrix multiplication. The disadvantage is that
the sampled candidates must be chosen independently of the context and of the
true labels.
"""
function fixed_unigram_candidate_sampler(v3944; name=nothing, num_true=nothing, num_sampled=nothing, unique=nothing, range_max=nothing, vocab_file=nothing, distortion=nothing, num_reserved_ids=nothing, num_shards=nothing, shard=nothing, unigrams=nothing, seed=nothing, seed2=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("FixedUnigramCandidateSampler") 
                begin  
                    begin  
                        if v3944 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3944)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3944)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if num_true !== nothing 
                            desc["num_true"] = num_true
                        end
                    end
                    begin  
                        if num_sampled !== nothing 
                            desc["num_sampled"] = num_sampled
                        end
                    end
                    begin  
                        if unique !== nothing 
                            desc["unique"] = unique
                        end
                    end
                    begin  
                        if range_max !== nothing 
                            desc["range_max"] = range_max
                        end
                    end
                    begin  
                        if vocab_file !== nothing 
                            desc["vocab_file"] = vocab_file
                        end
                    end
                    begin  
                        if distortion !== nothing 
                            desc["distortion"] = distortion
                        end
                    end
                    begin  
                        if num_reserved_ids !== nothing 
                            desc["num_reserved_ids"] = num_reserved_ids
                        end
                    end
                    begin  
                        if num_shards !== nothing 
                            desc["num_shards"] = num_shards
                        end
                    end
                    begin  
                        if shard !== nothing 
                            desc["shard"] = shard
                        end
                    end
                    begin  
                        if unigrams !== nothing 
                            desc["unigrams"] = unigrams
                        end
                    end
                    begin  
                        if seed !== nothing 
                            desc["seed"] = seed
                        end
                    end
                    begin  
                        if seed2 !== nothing 
                            desc["seed2"] = seed2
                        end
                    end
                end
            end), name, "FixedUnigramCandidateSampler") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2), tf.Tensor(op, 3))
    end
end

"""
     record_input(; file_random_seed=301, file_shuffle_shift_ratio=nothing, file_buffer_size=10000, file_parallelism=16, batch_size=32)

Emits randomized records.


"""
function record_input(; name=nothing, file_pattern=nothing, file_random_seed=nothing, file_shuffle_shift_ratio=nothing, file_buffer_size=nothing, file_parallelism=nothing, batch_size=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("RecordInput") 
                begin  
                end 
                begin  
                    begin  
                        if file_pattern !== nothing 
                            desc["file_pattern"] = file_pattern
                        end
                    end
                    begin  
                        if file_random_seed !== nothing 
                            desc["file_random_seed"] = file_random_seed
                        end
                    end
                    begin  
                        if file_shuffle_shift_ratio !== nothing 
                            desc["file_shuffle_shift_ratio"] = file_shuffle_shift_ratio
                        end
                    end
                    begin  
                        if file_buffer_size !== nothing 
                            desc["file_buffer_size"] = file_buffer_size
                        end
                    end
                    begin  
                        if file_parallelism !== nothing 
                            desc["file_parallelism"] = file_parallelism
                        end
                    end
                    begin  
                        if batch_size !== nothing 
                            desc["batch_size"] = batch_size
                        end
                    end
                end
            end), name, "RecordInput") 
    tf.Tensor(tf.Operation(desc))
end

"""
     max(input, reduction_indices; keep_dims=false, Tidx=Int32)

Computes the maximum of elements across dimensions of a tensor.

Reduces `input` along the dimensions given in `reduction_indices`. Unless
`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in
`reduction_indices`. If `keep_dims` is true, the reduced dimensions are
retained with length 1.
"""
function max(v3945, v3946; name=nothing, keep_dims=nothing, T=nothing, Tidx=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Max") 
                begin  
                    begin  
                        if v3945 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3945)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3945)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3946 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3946)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3946)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if keep_dims !== nothing 
                            desc["keep_dims"] = keep_dims
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tidx !== nothing 
                            desc["Tidx"] = Tidx
                        end
                    end
                end
            end), name, "Max") 
    tf.Tensor(tf.Operation(desc))
end

"""
     queue_dequeue_up_to_v2(handle, n; timeout_ms=-1)

Dequeues n tuples of one or more tensors from the given queue.

This operation is not supported by all queues.  If a queue does not support
DequeueUpTo, then an Unimplemented error is returned.

If the queue is closed and there are more than 0 but less than n elements
remaining, then instead of returning an OutOfRange error like
QueueDequeueMany, less than `n` elements are returned immediately.  If the queue
is closed and there are 0 elements left in the queue, then an OutOfRange
error is returned just like in QueueDequeueMany.  Otherwise the behavior
is identical to QueueDequeueMany:

This operation concatenates queue-element component tensors along the
0th dimension to make a single component tensor.  All of the components
in the dequeued tuple will have size n in the 0th dimension.

This operation has k outputs, where k is the number of components in
the tuples stored in the given queue, and output i is the ith
component of the dequeued tuple.
"""
function queue_dequeue_up_to_v2(v3947, v3948; name=nothing, component_types=nothing, timeout_ms=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("QueueDequeueUpToV2") 
                begin  
                    begin  
                        if v3947 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3947)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3947)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3948 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3948)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3948)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if component_types !== nothing 
                            desc["component_types"] = component_types
                        end
                    end
                    begin  
                        if timeout_ms !== nothing 
                            desc["timeout_ms"] = timeout_ms
                        end
                    end
                end
            end), name, "QueueDequeueUpToV2") 
    tf.Tensor(tf.Operation(desc))
end

"""
     ifft_2d(input)

Compute the inverse 2-dimensional discrete Fourier Transform over the inner-most

2 dimensions of `input`.
"""
function ifft_2d(v3949; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("IFFT2D") 
                begin  
                    begin  
                        if v3949 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3949)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3949)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "IFFT2D") 
    tf.Tensor(tf.Operation(desc))
end

"""
     scatter_mul(ref, indices, updates; use_locking=false)

Multiplies sparse updates into a variable reference.

This operation computes

    # Scalar indices
    ref[indices, ...] *= updates[...]

    # Vector indices (for each i)
    ref[indices[i], ...] *= updates[i, ...]

    # High rank indices (for each i, ..., j)
    ref[indices[i, ..., j], ...] *= updates[i, ..., j, ...]

This operation outputs `ref` after the update is done.
This makes it easier to chain operations that need to use the reset value.

Duplicate entries are handled correctly: if multiple `indices` reference
the same location, their contributions multiply.

Requires `updates.shape = indices.shape + ref.shape[1:]`.
"""
function scatter_mul(v3950, v3951, v3952; name=nothing, T=nothing, Tindices=nothing, use_locking=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ScatterMul") 
                begin  
                    begin  
                        if v3950 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3950)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3950)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3951 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3951)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3951)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3952 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3952)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3952)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tindices !== nothing 
                            desc["Tindices"] = Tindices
                        end
                    end
                    begin  
                        if use_locking !== nothing 
                            desc["use_locking"] = use_locking
                        end
                    end
                end
            end), name, "ScatterMul") 
    tf.Tensor(tf.Operation(desc))
end

"""
     sparse_concat(indices, values, shapes)

Concatenates a list of `SparseTensor` along the specified dimension.

Concatenation is with respect to the dense versions of these sparse tensors.
It is assumed that each input is a `SparseTensor` whose elements are ordered
along increasing dimension number.

All inputs' shapes must match, except for the concat dimension.  The
`indices`, `values`, and `shapes` lists must have the same length.

The output shape is identical to the inputs', except along the concat
dimension, where it is the sum of the inputs' sizes along that dimension.

The output elements will be resorted to preserve the sort order along
increasing dimension number.

This op runs in `O(M log M)` time, where `M` is the total number of non-empty
values across all inputs. This is due to the need for an internal sort in
order to concatenate efficiently across an arbitrary dimension.

For example, if `concat_dim = 1` and the inputs are

    sp_inputs[0]: shape = [2, 3]
    [0, 2]: "a"
    [1, 0]: "b"
    [1, 1]: "c"

    sp_inputs[1]: shape = [2, 4]
    [0, 1]: "d"
    [0, 2]: "e"

then the output will be

    shape = [2, 7]
    [0, 2]: "a"
    [0, 4]: "d"
    [0, 5]: "e"
    [1, 0]: "b"
    [1, 1]: "c"

Graphically this is equivalent to doing

    [    a] concat [  d e  ] = [    a   d e  ]
    [b c  ]        [       ]   [b c          ]
"""
function sparse_concat(v3953, v3954, v3955; name=nothing, concat_dim=nothing, N=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SparseConcat") 
                begin  
                    begin  
                        if v3953 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3953)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3953)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3954 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3954)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3954)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3955 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3955)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3955)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if concat_dim !== nothing 
                            desc["concat_dim"] = concat_dim
                        end
                    end
                    begin  
                        if N !== nothing 
                            desc["N"] = N
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "SparseConcat") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2), tf.Tensor(op, 3))
    end
end

"""
     decode_jpeg(contents; channels=0, ratio=1, fancy_upscaling=true, try_recover_truncated=false, acceptable_fraction=nothing, dct_method=)

Decode a JPEG-encoded image to a uint8 tensor.

The attr `channels` indicates the desired number of color channels for the
decoded image.

Accepted values are:

*   0: Use the number of channels in the JPEG-encoded image.
*   1: output a grayscale image.
*   3: output an RGB image.

If needed, the JPEG-encoded image is transformed to match the requested number
of color channels.

The attr `ratio` allows downscaling the image by an integer factor during
decoding.  Allowed values are: 1, 2, 4, and 8.  This is much faster than
downscaling the image later.
"""
function decode_jpeg(v3956; name=nothing, channels=nothing, ratio=nothing, fancy_upscaling=nothing, try_recover_truncated=nothing, acceptable_fraction=nothing, dct_method=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("DecodeJpeg") 
                begin  
                    begin  
                        if v3956 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3956)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3956)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if channels !== nothing 
                            desc["channels"] = channels
                        end
                    end
                    begin  
                        if ratio !== nothing 
                            desc["ratio"] = ratio
                        end
                    end
                    begin  
                        if fancy_upscaling !== nothing 
                            desc["fancy_upscaling"] = fancy_upscaling
                        end
                    end
                    begin  
                        if try_recover_truncated !== nothing 
                            desc["try_recover_truncated"] = try_recover_truncated
                        end
                    end
                    begin  
                        if acceptable_fraction !== nothing 
                            desc["acceptable_fraction"] = acceptable_fraction
                        end
                    end
                    begin  
                        if dct_method !== nothing 
                            desc["dct_method"] = dct_method
                        end
                    end
                end
            end), name, "DecodeJpeg") 
    tf.Tensor(tf.Operation(desc))
end

"""
     histogram_summary(tag, values; T=Float32)

Outputs a `Summary` protocol buffer with a histogram.

The generated
[`Summary`](https://www.tensorflow.org/code/tensorflow/core/framework/summary.proto)
has one summary value containing a histogram for `values`.

This op reports an `InvalidArgument` error if any value is not finite.
"""
function histogram_summary(v3957, v3958; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("HistogramSummary") 
                begin  
                    begin  
                        if v3957 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3957)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3957)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3958 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3958)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3958)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "HistogramSummary") 
    tf.Tensor(tf.Operation(desc))
end

"""
     random_shuffle_queue_v2(; shapes=Int64[], capacity=-1, min_after_dequeue=0, seed=0, seed2=0, container=, shared_name=)

A queue that randomizes the order of elements.


"""
function random_shuffle_queue_v2(; name=nothing, component_types=nothing, shapes=nothing, capacity=nothing, min_after_dequeue=nothing, seed=nothing, seed2=nothing, container=nothing, shared_name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("RandomShuffleQueueV2") 
                begin  
                end 
                begin  
                    begin  
                        if component_types !== nothing 
                            desc["component_types"] = component_types
                        end
                    end
                    begin  
                        if shapes !== nothing 
                            desc["shapes"] = shapes
                        end
                    end
                    begin  
                        if capacity !== nothing 
                            desc["capacity"] = capacity
                        end
                    end
                    begin  
                        if min_after_dequeue !== nothing 
                            desc["min_after_dequeue"] = min_after_dequeue
                        end
                    end
                    begin  
                        if seed !== nothing 
                            desc["seed"] = seed
                        end
                    end
                    begin  
                        if seed2 !== nothing 
                            desc["seed2"] = seed2
                        end
                    end
                    begin  
                        if container !== nothing 
                            desc["container"] = container
                        end
                    end
                    begin  
                        if shared_name !== nothing 
                            desc["shared_name"] = shared_name
                        end
                    end
                end
            end), name, "RandomShuffleQueueV2") 
    tf.Tensor(tf.Operation(desc))
end

"""
     pad(input, paddings; Tpaddings=Int32)

Pads a tensor with zeros.

This operation pads a `input` with zeros according to the `paddings` you
specify. `paddings` is an integer tensor with shape `[Dn, 2]`, where n is the
rank of `input`. For each dimension D of `input`, `paddings[D, 0]` indicates
how many zeros to add before the contents of `input` in that dimension, and
`paddings[D, 1]` indicates how many zeros to add after the contents of `input`
in that dimension.

The padded size of each dimension D of the output is:

`paddings(D, 0) + input.dim_size(D) + paddings(D, 1)`

For example:

```prettyprint
# 't' is [[1, 1], [2, 2]]
# 'paddings' is [[1, 1], [2, 2]]
# rank of 't' is 2
pad(t, paddings) ==> [[0, 0, 0, 0, 0, 0]
                      [0, 0, 1, 1, 0, 0]
                      [0, 0, 2, 2, 0, 0]
                      [0, 0, 0, 0, 0, 0]]
```
"""
function pad(v3959, v3960; name=nothing, T=nothing, Tpaddings=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Pad") 
                begin  
                    begin  
                        if v3959 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3959)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3959)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3960 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3960)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3960)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tpaddings !== nothing 
                            desc["Tpaddings"] = Tpaddings
                        end
                    end
                end
            end), name, "Pad") 
    tf.Tensor(tf.Operation(desc))
end

"""
     add_many_sparse_to_tensors_map(sparse_indices, sparse_values, sparse_shape; container=, shared_name=)

Add an `N`-minibatch `SparseTensor` to a `SparseTensorsMap`, return `N` handles.

A `SparseTensor` of rank `R` is represented by three tensors: `sparse_indices`,
`sparse_values`, and `sparse_shape`, where

```sparse_indices.shape[1] == sparse_shape.shape[0] == R```

An `N`-minibatch of `SparseTensor` objects is represented as a `SparseTensor`
having a first `sparse_indices` column taking values between `[0, N)`, where
the minibatch size `N == sparse_shape[0]`.

The input `SparseTensor` must have rank `R` greater than 1, and the first
dimension is treated as the minibatch dimension.  Elements of the `SparseTensor`
must be sorted in increasing order of this first dimension.  The stored
`SparseTensor` objects pointed to by each row of the output `sparse_handles`
will have rank `R-1`.

The `SparseTensor` values can then be read out as part of a minibatch by passing
the given keys as vector elements to `TakeManySparseFromTensorsMap`.  To ensure
the correct `SparseTensorsMap` is accessed, ensure that the same
`container` and `shared_name` are passed to that Op.  If no `shared_name`
is provided here, instead use the *name* of the Operation created by calling
`AddManySparseToTensorsMap` as the `shared_name` passed to
`TakeManySparseFromTensorsMap`.  Ensure the Operations are colocated.
"""
function add_many_sparse_to_tensors_map(v3961, v3962, v3963; name=nothing, T=nothing, container=nothing, shared_name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("AddManySparseToTensorsMap") 
                begin  
                    begin  
                        if v3961 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3961)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3961)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3962 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3962)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3962)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3963 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3963)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3963)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if container !== nothing 
                            desc["container"] = container
                        end
                    end
                    begin  
                        if shared_name !== nothing 
                            desc["shared_name"] = shared_name
                        end
                    end
                end
            end), name, "AddManySparseToTensorsMap") 
    tf.Tensor(tf.Operation(desc))
end

"""
     sparse_reorder(input_indices, input_values, input_shape)

Reorders a SparseTensor into the canonical, row-major ordering.

Note that by convention, all sparse ops preserve the canonical ordering along
increasing dimension number. The only time ordering can be violated is during
manual manipulation of the indices and values vectors to add entries.

Reordering does not affect the shape of the SparseTensor.

If the tensor has rank `R` and `N` non-empty values, `input_indices` has
shape `[N, R]`, input_values has length `N`, and input_shape has length `R`.
"""
function sparse_reorder(v3964, v3965, v3966; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SparseReorder") 
                begin  
                    begin  
                        if v3964 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3964)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3964)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3965 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3965)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3965)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3966 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3966)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3966)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "SparseReorder") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2))
    end
end

"""
     mul(x, y)

Returns x * y element-wise.

*NOTE*: `Mul` supports broadcasting. More about broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
"""
function mul(v3967, v3968; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Mul") 
                begin  
                    begin  
                        if v3967 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3967)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3967)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3968 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3968)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3968)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Mul") 
    tf.Tensor(tf.Operation(desc))
end

"""
     segment_sum(data, segment_ids)

Computes the sum along segments of a tensor.

Read [the section on Segmentation](../../api_docs/python/math_ops.md#segmentation)
for an explanation of segments.

Computes a tensor such that
\\(output_i = \sum_j data_j\\) where sum is over `j` such
that `segment_ids[j] == i`.

If the sum is empty for a given segment ID `i`, `output[i] = 0`.

<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="../../images/SegmentSum.png" alt>
</div>
"""
function segment_sum(v3969, v3970; name=nothing, T=nothing, Tindices=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SegmentSum") 
                begin  
                    begin  
                        if v3969 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3969)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3969)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3970 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3970)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3970)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tindices !== nothing 
                            desc["Tindices"] = Tindices
                        end
                    end
                end
            end), name, "SegmentSum") 
    tf.Tensor(tf.Operation(desc))
end

"""
     exp(x)

Computes exponential of x element-wise.  \\(y = e^x\\).


"""
function exp(v3971; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Exp") 
                begin  
                    begin  
                        if v3971 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3971)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3971)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Exp") 
    tf.Tensor(tf.Operation(desc))
end

"""
     softmax_cross_entropy_with_logits(features, labels)

Computes softmax cross entropy cost and gradients to backpropagate.

Inputs are the logits, not probabilities.
"""
function softmax_cross_entropy_with_logits(v3972, v3973; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SoftmaxCrossEntropyWithLogits") 
                begin  
                    begin  
                        if v3972 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3972)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3972)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3973 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3973)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3973)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "SoftmaxCrossEntropyWithLogits") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2))
    end
end

"""
     queue_enqueue_many_v2(handle, components; timeout_ms=-1)

Enqueues zero or more tuples of one or more tensors in the given queue.

This operation slices each component tensor along the 0th dimension to
make multiple queue elements. All of the tuple components must have the
same size in the 0th dimension.

The components input has k elements, which correspond to the components of
tuples stored in the given queue.

N.B. If the queue is full, this operation will block until the given
elements have been enqueued (or 'timeout_ms' elapses, if specified).
"""
function queue_enqueue_many_v2(v3974, v3975; name=nothing, Tcomponents=nothing, timeout_ms=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("QueueEnqueueManyV2") 
                begin  
                    begin  
                        if v3974 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3974)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3974)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3975 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3975)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3975)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if Tcomponents !== nothing 
                            desc["Tcomponents"] = Tcomponents
                        end
                    end
                    begin  
                        if timeout_ms !== nothing 
                            desc["timeout_ms"] = timeout_ms
                        end
                    end
                end
            end), name, "QueueEnqueueManyV2") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     batch_matrix_set_diag(input, diagonal)




"""
function batch_matrix_set_diag(v3976, v3977; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("BatchMatrixSetDiag") 
                begin  
                    begin  
                        if v3976 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3976)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3976)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3977 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3977)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3977)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "BatchMatrixSetDiag") 
    tf.Tensor(tf.Operation(desc))
end

"""
     get_session_handle_v2(value)

Store the input tensor in the state of the current session.


"""
function get_session_handle_v2(v3978; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("GetSessionHandleV2") 
                begin  
                    begin  
                        if v3978 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3978)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3978)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "GetSessionHandleV2") 
    tf.Tensor(tf.Operation(desc))
end

"""
     resource_sparse_apply_centered_rmsp(var, mg, ms, mom, lr, rho, momentum, epsilon, grad, indices; use_locking=false)

Update '*var' according to the centered RMSProp algorithm.

The centered RMSProp algorithm uses an estimate of the centered second moment
(i.e., the variance) for normalization, as opposed to regular RMSProp, which
uses the (uncentered) second moment. This often helps with training, but is
slightly more expensive in terms of computation and memory.

Note that in dense implementation of this algorithm, mg, ms, and mom will
update even if the grad is zero, but in this sparse implementation, mg, ms,
and mom will not update in iterations during which the grad is zero.

mean_square = decay * mean_square + (1-decay) * gradient ** 2
mean_grad = decay * mean_grad + (1-decay) * gradient
Delta = learning_rate * gradient / sqrt(mean_square + epsilon - mean_grad ** 2)

ms <- rho * ms_{t-1} + (1-rho) * grad * grad
mom <- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)
var <- var - mom
"""
function resource_sparse_apply_centered_rmsp(v3979, v3980, v3981, v3982, v3983, v3984, v3985, v3986, v3987, v3988; name=nothing, T=nothing, Tindices=nothing, use_locking=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ResourceSparseApplyCenteredRMSProp") 
                begin  
                    begin  
                        if v3979 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3979)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3979)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3980 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3980)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3980)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3981 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3981)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3981)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3982 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3982)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3982)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3983 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3983)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3983)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3984 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3984)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3984)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3985 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3985)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3985)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3986 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3986)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3986)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3987 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3987)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3987)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3988 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3988)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3988)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tindices !== nothing 
                            desc["Tindices"] = Tindices
                        end
                    end
                    begin  
                        if use_locking !== nothing 
                            desc["use_locking"] = use_locking
                        end
                    end
                end
            end), name, "ResourceSparseApplyCenteredRMSProp") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     stack_pop(handle)

Pop the element at the top of the stack.


"""
function stack_pop(v3989; name=nothing, elem_type=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("StackPop") 
                begin  
                    begin  
                        if v3989 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3989)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3989)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if elem_type !== nothing 
                            desc["elem_type"] = elem_type
                        end
                    end
                end
            end), name, "StackPop") 
    tf.Tensor(tf.Operation(desc))
end

"""
     relu_grad(gradients, features)

Computes rectified linear gradients for a Relu operation.


"""
function relu_grad(v3990, v3991; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ReluGrad") 
                begin  
                    begin  
                        if v3990 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3990)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3990)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3991 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3991)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3991)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "ReluGrad") 
    tf.Tensor(tf.Operation(desc))
end

"""
     resource_sparse_apply_rmsp(var, ms, mom, lr, rho, momentum, epsilon, grad, indices; use_locking=false)

Update '*var' according to the RMSProp algorithm.

Note that in dense implementation of this algorithm, ms and mom will
update even if the grad is zero, but in this sparse implementation, ms
and mom will not update in iterations during which the grad is zero.

mean_square = decay * mean_square + (1-decay) * gradient ** 2
Delta = learning_rate * gradient / sqrt(mean_square + epsilon)

ms <- rho * ms_{t-1} + (1-rho) * grad * grad
mom <- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)
var <- var - mom
"""
function resource_sparse_apply_rmsp(v3992, v3993, v3994, v3995, v3996, v3997, v3998, v3999, v4000; name=nothing, T=nothing, Tindices=nothing, use_locking=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ResourceSparseApplyRMSProp") 
                begin  
                    begin  
                        if v3992 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3992)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3992)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3993 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3993)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3993)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3994 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3994)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3994)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3995 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3995)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3995)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3996 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3996)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3996)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3997 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3997)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3997)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3998 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3998)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3998)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v3999 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v3999)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v3999)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4000 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4000)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4000)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tindices !== nothing 
                            desc["Tindices"] = Tindices
                        end
                    end
                    begin  
                        if use_locking !== nothing 
                            desc["use_locking"] = use_locking
                        end
                    end
                end
            end), name, "ResourceSparseApplyRMSProp") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     parse_example(serialized, names, sparse_keys, dense_keys, dense_defaults)

Transforms a vector of brain.Example protos (as strings) into typed tensors.


"""
function parse_example(v4001, v4002, v4003, v4004, v4005; name=nothing, Nsparse=nothing, Ndense=nothing, sparse_types=nothing, Tdense=nothing, dense_shapes=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ParseExample") 
                begin  
                    begin  
                        if v4001 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4001)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4001)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4002 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4002)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4002)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4003 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4003)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4003)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4004 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4004)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4004)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4005 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4005)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4005)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if Nsparse !== nothing 
                            desc["Nsparse"] = Nsparse
                        end
                    end
                    begin  
                        if Ndense !== nothing 
                            desc["Ndense"] = Ndense
                        end
                    end
                    begin  
                        if sparse_types !== nothing 
                            desc["sparse_types"] = sparse_types
                        end
                    end
                    begin  
                        if Tdense !== nothing 
                            desc["Tdense"] = Tdense
                        end
                    end
                    begin  
                        if dense_shapes !== nothing 
                            desc["dense_shapes"] = dense_shapes
                        end
                    end
                end
            end), name, "ParseExample") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2), tf.Tensor(op, 3), tf.Tensor(op, 4))
    end
end

"""
     random_crop(image, size; seed=0, seed2=0)

Randomly crop `image`.

`size` is a 1-D int64 tensor with 2 elements representing the crop height and
width.  The values must be non negative.

This Op picks a random location in `image` and crops a `height` by `width`
rectangle from that location.  The random location is picked so the cropped
area will fit inside the original image.
"""
function random_crop(v4006, v4007; name=nothing, T=nothing, seed=nothing, seed2=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("RandomCrop") 
                begin  
                    begin  
                        if v4006 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4006)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4006)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4007 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4007)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4007)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if seed !== nothing 
                            desc["seed"] = seed
                        end
                    end
                    begin  
                        if seed2 !== nothing 
                            desc["seed2"] = seed2
                        end
                    end
                end
            end), name, "RandomCrop") 
    tf.Tensor(tf.Operation(desc))
end

"""
     sparse_apply_proximal_gradient_descent(var, alpha, l1, l2, grad, indices; use_locking=false)

Sparse update '*var' as FOBOS algorithm with fixed learning rate.

That is for rows we have grad for, we update var as follows:
prox_v = var - alpha * grad
var = sign(prox_v)/(1+alpha*l2) * max{|prox_v|-alpha*l1,0}
"""
function sparse_apply_proximal_gradient_descent(v4008, v4009, v4010, v4011, v4012, v4013; name=nothing, T=nothing, Tindices=nothing, use_locking=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SparseApplyProximalGradientDescent") 
                begin  
                    begin  
                        if v4008 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4008)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4008)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4009 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4009)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4009)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4010 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4010)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4010)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4011 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4011)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4011)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4012 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4012)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4012)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4013 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4013)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4013)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tindices !== nothing 
                            desc["Tindices"] = Tindices
                        end
                    end
                    begin  
                        if use_locking !== nothing 
                            desc["use_locking"] = use_locking
                        end
                    end
                end
            end), name, "SparseApplyProximalGradientDescent") 
    tf.Tensor(tf.Operation(desc))
end

"""
     queue_enqueue_v2(handle, components; timeout_ms=-1)

Enqueues a tuple of one or more tensors in the given queue.

The components input has k elements, which correspond to the components of
tuples stored in the given queue.

N.B. If the queue is full, this operation will block until the given
element has been enqueued (or 'timeout_ms' elapses, if specified).
"""
function queue_enqueue_v2(v4014, v4015; name=nothing, Tcomponents=nothing, timeout_ms=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("QueueEnqueueV2") 
                begin  
                    begin  
                        if v4014 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4014)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4014)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4015 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4015)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4015)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if Tcomponents !== nothing 
                            desc["Tcomponents"] = Tcomponents
                        end
                    end
                    begin  
                        if timeout_ms !== nothing 
                            desc["timeout_ms"] = timeout_ms
                        end
                    end
                end
            end), name, "QueueEnqueueV2") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     where(input)

Returns locations of true values in a boolean tensor.

This operation returns the coordinates of true elements in `input`. The
coordinates are returned in a 2-D tensor where the first dimension (rows)
represents the number of true elements, and the second dimension (columns)
represents the coordinates of the true elements. Keep in mind, the shape of
the output tensor can vary depending on how many true values there are in
`input`. Indices are output in row-major order.

For example:

```prettyprint
# 'input' tensor is [[True, False]
#                    [True, False]]
# 'input' has two true values, so output has two coordinates.
# 'input' has rank of 2, so coordinates have two indices.
where(input) ==> [[0, 0],
                  [1, 0]]

# `input` tensor is [[[True, False]
#                     [True, False]]
#                    [[False, True]
#                     [False, True]]
#                    [[False, False]
#                     [False, True]]]
# 'input' has 5 true values, so output has 5 coordinates.
# 'input' has rank of 3, so coordinates have three indices.
where(input) ==> [[0, 0, 0],
                  [0, 1, 0],
                  [1, 0, 1],
                  [1, 1, 1],
                  [2, 1, 1]]
```
"""
function where(v4016; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Where") 
                begin  
                    begin  
                        if v4016 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4016)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4016)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "Where") 
    tf.Tensor(tf.Operation(desc))
end

"""
     tensor_array_split(handle, value, lengths, flow_in)




"""
function tensor_array_split(v4017, v4018, v4019, v4020; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("TensorArraySplit") 
                begin  
                    begin  
                        if v4017 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4017)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4017)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4018 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4018)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4018)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4019 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4019)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4019)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4020 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4020)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4020)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "TensorArraySplit") 
    tf.Tensor(tf.Operation(desc))
end

"""
     check_numerics(tensor)

Checks a tensor for NaN and Inf values.

When run, reports an `InvalidArgument` error if `tensor` has any values
that are not a number (NaN) or infinity (Inf). Otherwise, passes `tensor` as-is.
"""
function check_numerics(v4021; name=nothing, T=nothing, message=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("CheckNumerics") 
                begin  
                    begin  
                        if v4021 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4021)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4021)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if message !== nothing 
                            desc["message"] = message
                        end
                    end
                end
            end), name, "CheckNumerics") 
    tf.Tensor(tf.Operation(desc))
end

"""
     tensor_array_size_v3(handle, flow_in)

Get the current size of the TensorArray.


"""
function tensor_array_size_v3(v4022, v4023; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("TensorArraySizeV3") 
                begin  
                    begin  
                        if v4022 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4022)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4022)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4023 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4023)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4023)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "TensorArraySizeV3") 
    tf.Tensor(tf.Operation(desc))
end

"""
     scatter_nd_add(ref, indices, updates; use_locking=false)

Applies sparse addition between `updates` and individual values or slices

within a given variable according to `indices`.

`ref` is a `Tensor` with rank `P` and `indices` is a `Tensor` of rank `Q`.

`indices` must be integer tensor, containing indices into `ref`.
It must be shape `[d_0, ..., d_{Q-2}, K]` where `0 < K <= P`.

The innermost dimension of `indices` (with length `K`) corresponds to
indices into elements (if `K = P`) or slices (if `K < P`) along the `K`th
dimension of `ref`.

`updates` is `Tensor` of rank `Q-1+P-K` with shape:

```
[d_0, ..., d_{Q-2}, ref.shape[K], ..., ref.shape[P-1]].
```

For example, say we want to add 4 scattered elements to a rank-1 tensor to 8
elements. In Python, that addition would look like this:

    ref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8])
    indices = tf.constant([[4], [3], [1], [7]])
    updates = tf.constant([9, 10, 11, 12])
    add = tf.scatter_nd_add(ref, indices, updates)
    with tf.Session() as sess:
      print sess.run(add)

The resulting update to ref would look like this:

    [1, 13, 3, 14, 14, 6, 7, 20]

See [tf.scatter_nd](#scatter_nd) for more details about how to make updates to
slices.
"""
function scatter_nd_add(v4024, v4025, v4026; name=nothing, T=nothing, Tindices=nothing, use_locking=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ScatterNdAdd") 
                begin  
                    begin  
                        if v4024 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4024)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4024)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4025 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4025)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4025)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4026 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4026)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4026)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tindices !== nothing 
                            desc["Tindices"] = Tindices
                        end
                    end
                    begin  
                        if use_locking !== nothing 
                            desc["use_locking"] = use_locking
                        end
                    end
                end
            end), name, "ScatterNdAdd") 
    tf.Tensor(tf.Operation(desc))
end

"""
     conv_2d_backprop_filter(input, filter_sizes, out_backprop; use_cudnn_on_gpu=true, data_format=NHWC)

Computes the gradients of convolution with respect to the filter.


"""
function conv_2d_backprop_filter(v4027, v4028, v4029; name=nothing, T=nothing, strides=nothing, use_cudnn_on_gpu=nothing, padding=nothing, data_format=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Conv2DBackpropFilter") 
                begin  
                    begin  
                        if v4027 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4027)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4027)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4028 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4028)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4028)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4029 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4029)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4029)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if strides !== nothing 
                            desc["strides"] = strides
                        end
                    end
                    begin  
                        if use_cudnn_on_gpu !== nothing 
                            desc["use_cudnn_on_gpu"] = use_cudnn_on_gpu
                        end
                    end
                    begin  
                        if padding !== nothing 
                            desc["padding"] = padding
                        end
                    end
                    begin  
                        if data_format !== nothing 
                            desc["data_format"] = data_format
                        end
                    end
                end
            end), name, "Conv2DBackpropFilter") 
    tf.Tensor(tf.Operation(desc))
end

"""
     ctcl(inputs, labels_indices, labels_values, sequence_length; preprocess_collapse_repeated=false, ctc_merge_repeated=true)

Calculates the CTC Loss (log probability) for each batch entry.  Also calculates

the gradient.  This class performs the softmax operation for you, so inputs
should be e.g. linear projections of outputs by an LSTM.
"""
function ctcl(v4030, v4031, v4032, v4033; name=nothing, preprocess_collapse_repeated=nothing, ctc_merge_repeated=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("CTCLoss") 
                begin  
                    begin  
                        if v4030 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4030)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4030)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4031 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4031)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4031)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4032 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4032)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4032)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4033 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4033)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4033)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if preprocess_collapse_repeated !== nothing 
                            desc["preprocess_collapse_repeated"] = preprocess_collapse_repeated
                        end
                    end
                    begin  
                        if ctc_merge_repeated !== nothing 
                            desc["ctc_merge_repeated"] = ctc_merge_repeated
                        end
                    end
                end
            end), name, "CTCLoss") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2))
    end
end

"""
     quantized_reshape(tensor, shape, input_min, input_max; Tshape=Int32)

Reshapes a quantized tensor as per the Reshape op.

```
"""
function quantized_reshape(v4034, v4035, v4036, v4037; name=nothing, T=nothing, Tshape=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("QuantizedReshape") 
                begin  
                    begin  
                        if v4034 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4034)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4034)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4035 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4035)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4035)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4036 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4036)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4036)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4037 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4037)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4037)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tshape !== nothing 
                            desc["Tshape"] = Tshape
                        end
                    end
                end
            end), name, "QuantizedReshape") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2), tf.Tensor(op, 3))
    end
end

"""
     floor_div(x, y)

Returns x // y element-wise.

*NOTE*: `FloorDiv` supports broadcasting. More about broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
"""
function floor_div(v4038, v4039; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("FloorDiv") 
                begin  
                    begin  
                        if v4038 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4038)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4038)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4039 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4039)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4039)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "FloorDiv") 
    tf.Tensor(tf.Operation(desc))
end

"""
     max_pool_grad(orig_input, orig_output, grad; data_format=NHWC, T=Float32)

Computes gradients of the maxpooling function.


"""
function max_pool_grad(v4040, v4041, v4042; name=nothing, ksize=nothing, strides=nothing, padding=nothing, data_format=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("MaxPoolGrad") 
                begin  
                    begin  
                        if v4040 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4040)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4040)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4041 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4041)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4041)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4042 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4042)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4042)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if ksize !== nothing 
                            desc["ksize"] = ksize
                        end
                    end
                    begin  
                        if strides !== nothing 
                            desc["strides"] = strides
                        end
                    end
                    begin  
                        if padding !== nothing 
                            desc["padding"] = padding
                        end
                    end
                    begin  
                        if data_format !== nothing 
                            desc["data_format"] = data_format
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "MaxPoolGrad") 
    tf.Tensor(tf.Operation(desc))
end

"""
     tensor_array_v2(size; element_shape=TensorShape[unknown], dynamic_size=false, clear_after_read=true, tensor_array_name=)

Deprecated. Use TensorArrayV3


"""
function tensor_array_v2(v4043; name=nothing, dtype=nothing, element_shape=nothing, dynamic_size=nothing, clear_after_read=nothing, tensor_array_name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("TensorArrayV2") 
                begin  
                    begin  
                        if v4043 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4043)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4043)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if dtype !== nothing 
                            desc["dtype"] = dtype
                        end
                    end
                    begin  
                        if element_shape !== nothing 
                            desc["element_shape"] = element_shape
                        end
                    end
                    begin  
                        if dynamic_size !== nothing 
                            desc["dynamic_size"] = dynamic_size
                        end
                    end
                    begin  
                        if clear_after_read !== nothing 
                            desc["clear_after_read"] = clear_after_read
                        end
                    end
                    begin  
                        if tensor_array_name !== nothing 
                            desc["tensor_array_name"] = tensor_array_name
                        end
                    end
                end
            end), name, "TensorArrayV2") 
    tf.Tensor(tf.Operation(desc))
end

"""
     sparse_segment_mean_grad(grad, indices, segment_ids, output_dim0; Tidx=Int32)

Computes gradients for SparseSegmentMean.

Returns tensor "output" with same shape as grad, except for dimension 0 whose
value is output_dim0.
"""
function sparse_segment_mean_grad(v4044, v4045, v4046, v4047; name=nothing, T=nothing, Tidx=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SparseSegmentMeanGrad") 
                begin  
                    begin  
                        if v4044 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4044)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4044)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4045 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4045)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4045)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4046 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4046)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4046)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4047 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4047)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4047)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tidx !== nothing 
                            desc["Tidx"] = Tidx
                        end
                    end
                end
            end), name, "SparseSegmentMeanGrad") 
    tf.Tensor(tf.Operation(desc))
end

"""
     reader_num_records_produced_v2(reader_handle)

Returns the number of records this Reader has produced.

This is the same as the number of ReaderRead executions that have
succeeded.
"""
function reader_num_records_produced_v2(v4048; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ReaderNumRecordsProducedV2") 
                begin  
                    begin  
                        if v4048 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4048)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4048)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "ReaderNumRecordsProducedV2") 
    tf.Tensor(tf.Operation(desc))
end

"""
     barrier_close(handle; cancel_pending_enqueues=false)

Closes the given barrier.

This operation signals that no more new elements will be inserted in the
given barrier. Subsequent InsertMany that try to introduce a new key will fail.
Subsequent InsertMany operations that just add missing components to already
existing elements will continue to succeed. Subsequent TakeMany operations will
continue to succeed if sufficient completed elements remain in the barrier.
Subsequent TakeMany operations that would block will fail immediately.
"""
function barrier_close(v4049; name=nothing, cancel_pending_enqueues=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("BarrierClose") 
                begin  
                    begin  
                        if v4049 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4049)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4049)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if cancel_pending_enqueues !== nothing 
                            desc["cancel_pending_enqueues"] = cancel_pending_enqueues
                        end
                    end
                end
            end), name, "BarrierClose") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     assign_sub(ref, value; use_locking=false)

Update 'ref' by subtracting 'value' from it.

This operation outputs "ref" after the update is done.
This makes it easier to chain operations that need to use the reset value.
"""
function assign_sub(v4050, v4051; name=nothing, T=nothing, use_locking=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("AssignSub") 
                begin  
                    begin  
                        if v4050 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4050)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4050)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4051 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4051)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4051)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if use_locking !== nothing 
                            desc["use_locking"] = use_locking
                        end
                    end
                end
            end), name, "AssignSub") 
    tf.Tensor(tf.Operation(desc))
end

"""
     read_variable_op(resource)

Reads the value of a variable.

The tensor returned by this operation is immutable.

The value returned by this operation is guaranteed to be influenced by all the
writes on which this operation depends directly or indirectly, and to not be
influenced by any of the writes which depend directly or indirectly on this
operation.
"""
function read_variable_op(v4052; name=nothing, dtype=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ReadVariableOp") 
                begin  
                    begin  
                        if v4052 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4052)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4052)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if dtype !== nothing 
                            desc["dtype"] = dtype
                        end
                    end
                end
            end), name, "ReadVariableOp") 
    tf.Tensor(tf.Operation(desc))
end

"""
     unsorted_segment_sum(data, segment_ids, num_segments)

Computes the sum along segments of a tensor.

Read [the section on
Segmentation](../../api_docs/python/math_ops.md#segmentation) for an explanation
of segments.

Computes a tensor such that
`(output[i] = sum_{j...} data[j...]` where the sum is over tuples `j...` such
that `segment_ids[j...] == i`.  Unlike `SegmentSum`, `segment_ids`
need not be sorted and need not cover all values in the full
range of valid values.

If the sum is empty for a given segment ID `i`, `output[i] = 0`.

`num_segments` should equal the number of distinct segment IDs.

<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="../../images/UnsortedSegmentSum.png" alt>
</div>
"""
function unsorted_segment_sum(v4053, v4054, v4055; name=nothing, T=nothing, Tindices=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("UnsortedSegmentSum") 
                begin  
                    begin  
                        if v4053 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4053)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4053)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4054 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4054)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4054)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4055 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4055)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4055)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tindices !== nothing 
                            desc["Tindices"] = Tindices
                        end
                    end
                end
            end), name, "UnsortedSegmentSum") 
    tf.Tensor(tf.Operation(desc))
end

"""
     fused_batch_norm_grad(y_backprop, x, scale, reserve_space_1, reserve_space_2; epsilon=nothing, data_format=NHWC, is_training=true)

Gradient for batch normalization.

Note that the size of 4D Tensors are defined by either "NHWC" or "NCHW".
The size of 1D Tensors matches the dimension C of the 4D Tensors.
"""
function fused_batch_norm_grad(v4056, v4057, v4058, v4059, v4060; name=nothing, T=nothing, epsilon=nothing, data_format=nothing, is_training=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("FusedBatchNormGrad") 
                begin  
                    begin  
                        if v4056 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4056)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4056)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4057 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4057)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4057)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4058 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4058)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4058)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4059 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4059)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4059)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4060 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4060)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4060)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if epsilon !== nothing 
                            desc["epsilon"] = epsilon
                        end
                    end
                    begin  
                        if data_format !== nothing 
                            desc["data_format"] = data_format
                        end
                    end
                    begin  
                        if is_training !== nothing 
                            desc["is_training"] = is_training
                        end
                    end
                end
            end), name, "FusedBatchNormGrad") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2), tf.Tensor(op, 3), tf.Tensor(op, 4), tf.Tensor(op, 5))
    end
end

"""
     lookup_table_insert(table_handle, keys, values)

Updates the table to associates keys with values.

The tensor `keys` must be of the same type as the keys of the table.
The tensor `values` must be of the type of the table values.
"""
function lookup_table_insert(v4061, v4062, v4063; name=nothing, Tin=nothing, Tout=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("LookupTableInsert") 
                begin  
                    begin  
                        if v4061 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4061)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4061)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4062 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4062)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4062)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4063 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4063)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4063)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if Tin !== nothing 
                            desc["Tin"] = Tin
                        end
                    end
                    begin  
                        if Tout !== nothing 
                            desc["Tout"] = Tout
                        end
                    end
                end
            end), name, "LookupTableInsert") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     quantized_mul(x, y, min_x, max_x, min_y, max_y; Toutput=?)

Returns x * y element-wise, working on quantized buffers.


"""
function quantized_mul(v4064, v4065, v4066, v4067, v4068, v4069; name=nothing, T1=nothing, T2=nothing, Toutput=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("QuantizedMul") 
                begin  
                    begin  
                        if v4064 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4064)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4064)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4065 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4065)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4065)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4066 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4066)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4066)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4067 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4067)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4067)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4068 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4068)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4068)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4069 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4069)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4069)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T1 !== nothing 
                            desc["T1"] = T1
                        end
                    end
                    begin  
                        if T2 !== nothing 
                            desc["T2"] = T2
                        end
                    end
                    begin  
                        if Toutput !== nothing 
                            desc["Toutput"] = Toutput
                        end
                    end
                end
            end), name, "QuantizedMul") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2), tf.Tensor(op, 3))
    end
end

"""
     batch_matrix_triangular_solve(matrix, rhs; lower=true, adjoint=false)




"""
function batch_matrix_triangular_solve(v4070, v4071; name=nothing, lower=nothing, adjoint=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("BatchMatrixTriangularSolve") 
                begin  
                    begin  
                        if v4070 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4070)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4070)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4071 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4071)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4071)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if lower !== nothing 
                            desc["lower"] = lower
                        end
                    end
                    begin  
                        if adjoint !== nothing 
                            desc["adjoint"] = adjoint
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "BatchMatrixTriangularSolve") 
    tf.Tensor(tf.Operation(desc))
end

"""
     retval(input)

A graph node which represents a return value of a function.


"""
function retval(v4072; name=nothing, T=nothing, index=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("_Retval") 
                begin  
                    begin  
                        if v4072 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4072)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4072)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if index !== nothing 
                            desc["index"] = index
                        end
                    end
                end
            end), name, "_Retval") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     parallel_concat_start()

Creates an empty Tensor with shape `shape` and type `dtype`.

The memory can optionally be initialized. This is usually useful in
conjunction with inplace operations.
"""
function parallel_concat_start(; name=nothing, shape=nothing, dtype=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("_ParallelConcatStart") 
                begin  
                end 
                begin  
                    begin  
                        if shape !== nothing 
                            desc["shape"] = shape
                        end
                    end
                    begin  
                        if dtype !== nothing 
                            desc["dtype"] = dtype
                        end
                    end
                end
            end), name, "_ParallelConcatStart") 
    tf.Tensor(tf.Operation(desc))
end

"""
     complex_abs(x; T=?, Tout=Float32)

Computes the complex absolute value of a tensor.

Given a tensor `x` of complex numbers, this operation returns a tensor of type
`float` or `double` that is the absolute value of each element in `x`. All
elements in `x` must be complex numbers of the form \\(a + bj\\). The absolute
value is computed as \\( \sqrt{a^2 + b^2}\\).
"""
function complex_abs(v4073; name=nothing, T=nothing, Tout=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ComplexAbs") 
                begin  
                    begin  
                        if v4073 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4073)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4073)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tout !== nothing 
                            desc["Tout"] = Tout
                        end
                    end
                end
            end), name, "ComplexAbs") 
    tf.Tensor(tf.Operation(desc))
end

"""
     lookup_table_import(table_handle, keys, values)

Replaces the contents of the table with the specified keys and values.

The tensor `keys` must be of the same type as the keys of the table.
The tensor `values` must be of the type of the table values.
"""
function lookup_table_import(v4074, v4075, v4076; name=nothing, Tin=nothing, Tout=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("LookupTableImport") 
                begin  
                    begin  
                        if v4074 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4074)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4074)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4075 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4075)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4075)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4076 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4076)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4076)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if Tin !== nothing 
                            desc["Tin"] = Tin
                        end
                    end
                    begin  
                        if Tout !== nothing 
                            desc["Tout"] = Tout
                        end
                    end
                end
            end), name, "LookupTableImport") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     unique_with_counts(x; out_idx=Int32)

Finds unique elements in a 1-D tensor.

This operation returns a tensor `y` containing all of the unique elements of `x`
sorted in the same order that they occur in `x`. This operation also returns a
tensor `idx` the same size as `x` that contains the index of each value of `x`
in the unique output `y`. Finally, it returns a third tensor `count` that
contains the count of each element of `y` in `x`. In other words:

`y[idx[i]] = x[i] for i in [0, 1,...,rank(x) - 1]`

For example:

```prettyprint
# tensor 'x' is [1, 1, 2, 4, 4, 4, 7, 8, 8]
y, idx, count = unique_with_counts(x)
y ==> [1, 2, 4, 7, 8]
idx ==> [0, 0, 1, 2, 2, 2, 3, 4, 4]
count ==> [2, 1, 3, 1, 2]
```
"""
function unique_with_counts(v4077; name=nothing, T=nothing, out_idx=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("UniqueWithCounts") 
                begin  
                    begin  
                        if v4077 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4077)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4077)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if out_idx !== nothing 
                            desc["out_idx"] = out_idx
                        end
                    end
                end
            end), name, "UniqueWithCounts") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2), tf.Tensor(op, 3))
    end
end

"""
     abs(x)

Computes the absolute value of a tensor.

Given a tensor `x`, this operation returns a tensor containing the absolute
value of each element in `x`. For example, if x is an input element and y is
an output element, this operation computes \\(y = |x|\\).
"""
function abs(v4078; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Abs") 
                begin  
                    begin  
                        if v4078 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4078)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4078)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Abs") 
    tf.Tensor(tf.Operation(desc))
end

"""
     resource_apply_adam(var, m, v, beta1_power, beta2_power, lr, beta1, beta2, epsilon, grad; use_locking=false)

Update '*var' according to the Adam algorithm.

lr_t <- learning_rate * sqrt(1 - beta2^t) / (1 - beta1^t)
m_t <- beta1 * m_{t-1} + (1 - beta1) * g_t
v_t <- beta2 * v_{t-1} + (1 - beta2) * g_t * g_t
variable <- variable - lr_t * m_t / (sqrt(v_t) + epsilon)
"""
function resource_apply_adam(v4079, v4080, v4081, v4082, v4083, v4084, v4085, v4086, v4087, v4088; name=nothing, T=nothing, use_locking=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ResourceApplyAdam") 
                begin  
                    begin  
                        if v4079 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4079)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4079)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4080 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4080)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4080)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4081 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4081)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4081)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4082 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4082)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4082)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4083 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4083)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4083)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4084 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4084)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4084)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4085 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4085)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4085)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4086 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4086)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4086)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4087 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4087)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4087)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4088 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4088)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4088)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if use_locking !== nothing 
                            desc["use_locking"] = use_locking
                        end
                    end
                end
            end), name, "ResourceApplyAdam") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     add(x, y)

Returns x + y element-wise.

*NOTE*: `Add` supports broadcasting. `AddN` does not. More about broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
"""
function add(v4089, v4090; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Add") 
                begin  
                    begin  
                        if v4089 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4089)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4089)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4090 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4090)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4090)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Add") 
    tf.Tensor(tf.Operation(desc))
end

"""
     host_send(tensor; client_terminated=false)

Sends the named tensor from send_device to recv_device.

_HostSend requires its input on host memory whereas _Send requires its
input on device memory.
"""
function host_send(v4091; name=nothing, T=nothing, tensor_name=nothing, send_device=nothing, send_device_incarnation=nothing, recv_device=nothing, client_terminated=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("_HostSend") 
                begin  
                    begin  
                        if v4091 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4091)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4091)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if tensor_name !== nothing 
                            desc["tensor_name"] = tensor_name
                        end
                    end
                    begin  
                        if send_device !== nothing 
                            desc["send_device"] = send_device
                        end
                    end
                    begin  
                        if send_device_incarnation !== nothing 
                            desc["send_device_incarnation"] = send_device_incarnation
                        end
                    end
                    begin  
                        if recv_device !== nothing 
                            desc["recv_device"] = recv_device
                        end
                    end
                    begin  
                        if client_terminated !== nothing 
                            desc["client_terminated"] = client_terminated
                        end
                    end
                end
            end), name, "_HostSend") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     skipgram(; window_size=5, min_count=5, subsample=nothing)

Parses a text file and creates a batch of examples.


"""
function skipgram(; name=nothing, filename=nothing, batch_size=nothing, window_size=nothing, min_count=nothing, subsample=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Skipgram") 
                begin  
                end 
                begin  
                    begin  
                        if filename !== nothing 
                            desc["filename"] = filename
                        end
                    end
                    begin  
                        if batch_size !== nothing 
                            desc["batch_size"] = batch_size
                        end
                    end
                    begin  
                        if window_size !== nothing 
                            desc["window_size"] = window_size
                        end
                    end
                    begin  
                        if min_count !== nothing 
                            desc["min_count"] = min_count
                        end
                    end
                    begin  
                        if subsample !== nothing 
                            desc["subsample"] = subsample
                        end
                    end
                end
            end), name, "Skipgram") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2), tf.Tensor(op, 3), tf.Tensor(op, 4), tf.Tensor(op, 5), tf.Tensor(op, 6), tf.Tensor(op, 7))
    end
end

"""
     arg_min(input, dimension; Tidx=Int32)

Returns the index with the smallest value across dimensions of a tensor.


"""
function arg_min(v4092, v4093; name=nothing, T=nothing, Tidx=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ArgMin") 
                begin  
                    begin  
                        if v4092 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4092)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4092)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4093 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4093)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4093)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tidx !== nothing 
                            desc["Tidx"] = Tidx
                        end
                    end
                end
            end), name, "ArgMin") 
    tf.Tensor(tf.Operation(desc))
end

"""
     greater(x, y)

Returns the truth value of (x > y) element-wise.

*NOTE*: `Greater` supports broadcasting. More about broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
"""
function greater(v4094, v4095; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Greater") 
                begin  
                    begin  
                        if v4094 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4094)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4094)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4095 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4095)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4095)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Greater") 
    tf.Tensor(tf.Operation(desc))
end

"""
     matrix_solve(matrix, rhs; adjoint=false)

Solves systems of linear equations.

`Matrix` is a tensor of shape `[..., M, M]` whose inner-most 2 dimensions
form square matrices. `Rhs` is a tensor of shape `[..., M, K]`. The `output` is
a tensor shape `[..., M, K]`.  If `adjoint` is `False` then each output matrix
satisfies `matrix[..., :, :] * output[..., :, :] = rhs[..., :, :]`.
If `adjoint` is `True` then each output matrix satisfies
`adjoint(matrix[..., :, :]) * output[..., :, :] = rhs[..., :, :]`.
"""
function matrix_solve(v4096, v4097; name=nothing, adjoint=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("MatrixSolve") 
                begin  
                    begin  
                        if v4096 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4096)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4096)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4097 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4097)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4097)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if adjoint !== nothing 
                            desc["adjoint"] = adjoint
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "MatrixSolve") 
    tf.Tensor(tf.Operation(desc))
end

"""
     queue_dequeue_many(handle, n; timeout_ms=-1)

Dequeues n tuples of one or more tensors from the given queue.

If the queue is closed and there are fewer than n elements, then an
OutOfRange error is returned.

This operation concatenates queue-element component tensors along the
0th dimension to make a single component tensor.  All of the components
in the dequeued tuple will have size n in the 0th dimension.

This operation has k outputs, where k is the number of components in
the tuples stored in the given queue, and output i is the ith
component of the dequeued tuple.

N.B. If the queue is empty, this operation will block until n elements
have been dequeued (or 'timeout_ms' elapses, if specified).
"""
function queue_dequeue_many(v4098, v4099; name=nothing, component_types=nothing, timeout_ms=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("QueueDequeueMany") 
                begin  
                    begin  
                        if v4098 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4098)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4098)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4099 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4099)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4099)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if component_types !== nothing 
                            desc["component_types"] = component_types
                        end
                    end
                    begin  
                        if timeout_ms !== nothing 
                            desc["timeout_ms"] = timeout_ms
                        end
                    end
                end
            end), name, "QueueDequeueMany") 
    tf.Tensor(tf.Operation(desc))
end

"""
     assign_add_variable_op(resource, value)

Adds a value to the current value of a variable.

Any ReadVariableOp which depends directly or indirectly on this assign is
guaranteed to see the incremented value or a subsequent newer one.

Outputs the incremented value, which can be used to totally order the
increments to this variable.
"""
function assign_add_variable_op(v4100, v4101; name=nothing, dtype=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("AssignAddVariableOp") 
                begin  
                    begin  
                        if v4100 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4100)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4100)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4101 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4101)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4101)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if dtype !== nothing 
                            desc["dtype"] = dtype
                        end
                    end
                end
            end), name, "AssignAddVariableOp") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     split_v(value, size_splits, split_dim; Tlen=Int64)

Splits a tensor into `num_split` tensors along one dimension.


"""
function split_v(v4102, v4103, v4104; name=nothing, num_split=nothing, T=nothing, Tlen=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SplitV") 
                begin  
                    begin  
                        if v4102 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4102)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4102)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4103 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4103)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4103)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4104 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4104)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4104)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if num_split !== nothing 
                            desc["num_split"] = num_split
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tlen !== nothing 
                            desc["Tlen"] = Tlen
                        end
                    end
                end
            end), name, "SplitV") 
    tf.Tensor(tf.Operation(desc))
end

"""
     assign(ref, value; validate_shape=true, use_locking=true)

Update 'ref' by assigning 'value' to it.

This operation outputs "ref" after the assignment is done.
This makes it easier to chain operations that need to use the reset value.
"""
function assign(v4105, v4106; name=nothing, T=nothing, validate_shape=nothing, use_locking=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Assign") 
                begin  
                    begin  
                        if v4105 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4105)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4105)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4106 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4106)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4106)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if validate_shape !== nothing 
                            desc["validate_shape"] = validate_shape
                        end
                    end
                    begin  
                        if use_locking !== nothing 
                            desc["use_locking"] = use_locking
                        end
                    end
                end
            end), name, "Assign") 
    tf.Tensor(tf.Operation(desc))
end

"""
     adjust_contrastv_2(images, contrast_factor)

Adjust the contrast of one or more images.

`images` is a tensor of at least 3 dimensions.  The last 3 dimensions are
interpreted as `[height, width, channels]`.  The other dimensions only
represent a collection of images, such as `[batch, height, width, channels].`

Contrast is adjusted independently for each channel of each image.

For each channel, the Op first computes the mean of the image pixels in the
channel and then adjusts each component of each pixel to
`(x - mean) * contrast_factor + mean`.
"""
function adjust_contrastv_2(v4107, v4108; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("AdjustContrastv2") 
                begin  
                    begin  
                        if v4107 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4107)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4107)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4108 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4108)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4108)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "AdjustContrastv2") 
    tf.Tensor(tf.Operation(desc))
end

"""
     minimum(x, y)

Returns the min of x and y (i.e. x < y ? x : y) element-wise.

*NOTE*: `Minimum` supports broadcasting. More about broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
"""
function minimum(v4109, v4110; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Minimum") 
                begin  
                    begin  
                        if v4109 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4109)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4109)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4110 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4110)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4110)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Minimum") 
    tf.Tensor(tf.Operation(desc))
end

"""
     max_pool_with_argmax(input; Targmax=Int64, T=Float32)

Performs max pooling on the input and outputs both max values and indices.

The indices in `argmax` are flattened, so that a maximum value at position
`[b, y, x, c]` becomes flattened index
`((b * height + y) * width + x) * channels + c`.
"""
function max_pool_with_argmax(v4111; name=nothing, ksize=nothing, strides=nothing, Targmax=nothing, padding=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("MaxPoolWithArgmax") 
                begin  
                    begin  
                        if v4111 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4111)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4111)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if ksize !== nothing 
                            desc["ksize"] = ksize
                        end
                    end
                    begin  
                        if strides !== nothing 
                            desc["strides"] = strides
                        end
                    end
                    begin  
                        if Targmax !== nothing 
                            desc["Targmax"] = Targmax
                        end
                    end
                    begin  
                        if padding !== nothing 
                            desc["padding"] = padding
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "MaxPoolWithArgmax") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2))
    end
end

"""
     substr(input, pos, len)

Return substrings from `Tensor` of strings.

For each string in the input `Tensor`, creates a substring starting at index
`pos` with a total length of `len`.

If `len` defines a substring that would extend beyond the length of the input
string, then as many characters as possible are used.

If `pos` is negative or specifies a character index larger than any of the input
strings, then an `InvalidArgumentError` is thrown.

`pos` and `len` must have the same shape, otherwise a `ValueError` is thrown on
Op creation.

*NOTE*: `Substr` supports broadcasting up to two dimensions. More about
broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)

---

Examples

Using scalar `pos` and `len`:

```
input = [b'Hello', b'World']
position = 1
length = 3

output = [b'ell', b'orl']
```

Using `pos` and `len` with same shape as `input`:

```
input = [[b'ten', b'eleven', b'twelve'],
         [b'thirteen', b'fourteen', b'fifteen'],
         [b'sixteen', b'seventeen', b'eighteen']]
position = [[1, 2, 3],
            [1, 2, 3],
            [1, 2, 3]]
length =   [[2, 3, 4],
            [4, 3, 2],
            [5, 5, 5]]

output = [[b'en', b'eve', b'lve'],
          [b'hirt', b'urt', b'te'],
          [b'ixtee', b'vente', b'hteen']]
```

Broadcasting `pos` and `len` onto `input`:

```
input = [[b'ten', b'eleven', b'twelve'],
         [b'thirteen', b'fourteen', b'fifteen'],
         [b'sixteen', b'seventeen', b'eighteen'],
         [b'nineteen', b'twenty', b'twentyone']]
position = [1, 2, 3]
length =   [1, 2, 3]

output = [[b'e', b'ev', b'lve'],
          [b'h', b'ur', b'tee'],
          [b'i', b've', b'hte'],
          [b'i', b'en', b'nty']]
```

Broadcasting `input` onto `pos` and `len`:

```
input = b'thirteen'
position = [1, 5, 7]
length =   [3, 2, 1]

output = [b'hir', b'ee', b'n"]
```
"""
function substr(v4112, v4113, v4114; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Substr") 
                begin  
                    begin  
                        if v4112 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4112)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4112)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4113 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4113)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4113)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4114 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4114)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4114)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Substr") 
    tf.Tensor(tf.Operation(desc))
end

"""
     slice(input, begin, size)

Return a slice from 'input'.

The output tensor is a tensor with dimensions described by 'size'
whose values are extracted from 'input' starting at the offsets in
'begin'.

*Requirements*:
  0 <= begin[i] <= begin[i] + size[i] <= Di  for i in [0, n)
"""
function slice(v4115, v4116, v4117; name=nothing, T=nothing, Index=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Slice") 
                begin  
                    begin  
                        if v4115 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4115)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4115)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4116 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Int32}, v4116)
                        else  
                            converted = convert(TensorFlow.Tensor{Int32}, v4116)
                        end 
                        begin  
                            converted = converted - 1
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4117 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Int32}, v4117)
                        else  
                            converted = convert(TensorFlow.Tensor{Int32}, v4117)
                        end 
                        begin  
                            converted = converted - 1
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Index !== nothing 
                            desc["Index"] = Index
                        end
                    end
                end
            end), name, "Slice") 
    tf.Tensor(tf.Operation(desc))
end

"""
     queue_size(handle)

Computes the number of elements in the given queue.


"""
function queue_size(v4118; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("QueueSize") 
                begin  
                    begin  
                        if v4118 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4118)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4118)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "QueueSize") 
    tf.Tensor(tf.Operation(desc))
end

"""
     batch_ifft_3d(input)




"""
function batch_ifft_3d(v4119; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("BatchIFFT3D") 
                begin  
                    begin  
                        if v4119 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4119)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4119)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "BatchIFFT3D") 
    tf.Tensor(tf.Operation(desc))
end

"""
     quantized_relu_x(features, max_value, min_features, max_features; out_type=?)

Computes Quantized Rectified Linear X: `min(max(features, 0), max_value)`


"""
function quantized_relu_x(v4120, v4121, v4122, v4123; name=nothing, Tinput=nothing, out_type=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("QuantizedReluX") 
                begin  
                    begin  
                        if v4120 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4120)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4120)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4121 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4121)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4121)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4122 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4122)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4122)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4123 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4123)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4123)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if Tinput !== nothing 
                            desc["Tinput"] = Tinput
                        end
                    end
                    begin  
                        if out_type !== nothing 
                            desc["out_type"] = out_type
                        end
                    end
                end
            end), name, "QuantizedReluX") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2), tf.Tensor(op, 3))
    end
end

"""
     sparse_segment_mean(data, indices, segment_ids; Tidx=Int32)

Computes the mean along sparse segments of a tensor.

Read [the section on
Segmentation](../../api_docs/python/math_ops.md#segmentation) for an explanation
of segments.

Like `SegmentMean`, but `segment_ids` can have rank less than `data`'s first
dimension, selecting a subset of dimension 0, specified by `indices`.
"""
function sparse_segment_mean(v4124, v4125, v4126; name=nothing, T=nothing, Tidx=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SparseSegmentMean") 
                begin  
                    begin  
                        if v4124 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4124)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4124)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4125 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4125)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4125)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4126 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4126)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4126)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tidx !== nothing 
                            desc["Tidx"] = Tidx
                        end
                    end
                end
            end), name, "SparseSegmentMean") 
    tf.Tensor(tf.Operation(desc))
end

"""
     fft_2d(input)

Compute the 2-dimensional discrete Fourier Transform over the inner-most

2 dimensions of `input`.
"""
function fft_2d(v4127; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("FFT2D") 
                begin  
                    begin  
                        if v4127 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4127)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4127)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "FFT2D") 
    tf.Tensor(tf.Operation(desc))
end

"""
     random_shuffle_queue(; shapes=Int64[], capacity=-1, min_after_dequeue=0, seed=0, seed2=0, container=, shared_name=)

A queue that randomizes the order of elements.


"""
function random_shuffle_queue(; name=nothing, component_types=nothing, shapes=nothing, capacity=nothing, min_after_dequeue=nothing, seed=nothing, seed2=nothing, container=nothing, shared_name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("RandomShuffleQueue") 
                begin  
                end 
                begin  
                    begin  
                        if component_types !== nothing 
                            desc["component_types"] = component_types
                        end
                    end
                    begin  
                        if shapes !== nothing 
                            desc["shapes"] = shapes
                        end
                    end
                    begin  
                        if capacity !== nothing 
                            desc["capacity"] = capacity
                        end
                    end
                    begin  
                        if min_after_dequeue !== nothing 
                            desc["min_after_dequeue"] = min_after_dequeue
                        end
                    end
                    begin  
                        if seed !== nothing 
                            desc["seed"] = seed
                        end
                    end
                    begin  
                        if seed2 !== nothing 
                            desc["seed2"] = seed2
                        end
                    end
                    begin  
                        if container !== nothing 
                            desc["container"] = container
                        end
                    end
                    begin  
                        if shared_name !== nothing 
                            desc["shared_name"] = shared_name
                        end
                    end
                end
            end), name, "RandomShuffleQueue") 
    tf.Tensor(tf.Operation(desc))
end

"""
     sparse_segment_sqrt_ng(grad, indices, segment_ids, output_dim0; Tidx=Int32)

Computes gradients for SparseSegmentSqrtN.

Returns tensor "output" with same shape as grad, except for dimension 0 whose
value is output_dim0.
"""
function sparse_segment_sqrt_ng(v4128, v4129, v4130, v4131; name=nothing, T=nothing, Tidx=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SparseSegmentSqrtNGrad") 
                begin  
                    begin  
                        if v4128 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4128)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4128)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4129 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4129)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4129)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4130 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4130)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4130)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4131 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4131)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4131)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tidx !== nothing 
                            desc["Tidx"] = Tidx
                        end
                    end
                end
            end), name, "SparseSegmentSqrtNGrad") 
    tf.Tensor(tf.Operation(desc))
end

"""
     segment_mean(data, segment_ids)

Computes the mean along segments of a tensor.

Read [the section on
Segmentation](../../api_docs/python/math_ops.md#segmentation) for an explanation
of segments.

Computes a tensor such that
\\(output_i = \frac{\sum_j data_j}{N}\\) where `mean` is
over `j` such that `segment_ids[j] == i` and `N` is the total number of
values summed.

If the mean is empty for a given segment ID `i`, `output[i] = 0`.

<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="../../images/SegmentMean.png" alt>
</div>
"""
function segment_mean(v4132, v4133; name=nothing, T=nothing, Tindices=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SegmentMean") 
                begin  
                    begin  
                        if v4132 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4132)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4132)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4133 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4133)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4133)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tindices !== nothing 
                            desc["Tindices"] = Tindices
                        end
                    end
                end
            end), name, "SegmentMean") 
    tf.Tensor(tf.Operation(desc))
end

"""
     real(input; T=?, Tout=Float32)

Returns the real part of a complex number.

Given a tensor `input` of complex numbers, this operation returns a tensor of
type `float` that is the real part of each element in `input`. All elements in
`input` must be complex numbers of the form \\(a + bj\\), where *a* is the real
 part returned by this operation and *b* is the imaginary part.

For example:

```
# tensor 'input' is [-2.25 + 4.75j, 3.25 + 5.75j]
tf.real(input) ==> [-2.25, 3.25]
```
"""
function real(v4134; name=nothing, T=nothing, Tout=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Real") 
                begin  
                    begin  
                        if v4134 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4134)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4134)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tout !== nothing 
                            desc["Tout"] = Tout
                        end
                    end
                end
            end), name, "Real") 
    tf.Tensor(tf.Operation(desc))
end

"""
     sigmoid(x)

Computes sigmoid of `x` element-wise.

Specifically, `y = 1 / (1 + exp(-x))`.
"""
function sigmoid(v4135; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Sigmoid") 
                begin  
                    begin  
                        if v4135 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4135)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4135)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Sigmoid") 
    tf.Tensor(tf.Operation(desc))
end

"""
     all_candidate_sampler(true_classes; seed=0, seed2=0)

Generates labels for candidate sampling with a learned unigram distribution.

See explanations of candidate sampling and the data formats at
go/candidate-sampling.

For each batch, this op picks a single set of sampled candidate labels.

The advantages of sampling candidates per-batch are simplicity and the
possibility of efficient dense matrix multiplication. The disadvantage is that
the sampled candidates must be chosen independently of the context and of the
true labels.
"""
function all_candidate_sampler(v4136; name=nothing, num_true=nothing, num_sampled=nothing, unique=nothing, seed=nothing, seed2=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("AllCandidateSampler") 
                begin  
                    begin  
                        if v4136 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4136)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4136)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if num_true !== nothing 
                            desc["num_true"] = num_true
                        end
                    end
                    begin  
                        if num_sampled !== nothing 
                            desc["num_sampled"] = num_sampled
                        end
                    end
                    begin  
                        if unique !== nothing 
                            desc["unique"] = unique
                        end
                    end
                    begin  
                        if seed !== nothing 
                            desc["seed"] = seed
                        end
                    end
                    begin  
                        if seed2 !== nothing 
                            desc["seed2"] = seed2
                        end
                    end
                end
            end), name, "AllCandidateSampler") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2), tf.Tensor(op, 3))
    end
end

"""
     conv_2d_backprop_input(input_sizes, filter, out_backprop; use_cudnn_on_gpu=true, data_format=NHWC)

Computes the gradients of convolution with respect to the input.


"""
function conv_2d_backprop_input(v4137, v4138, v4139; name=nothing, T=nothing, strides=nothing, use_cudnn_on_gpu=nothing, padding=nothing, data_format=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Conv2DBackpropInput") 
                begin  
                    begin  
                        if v4137 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4137)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4137)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4138 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4138)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4138)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4139 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4139)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4139)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if strides !== nothing 
                            desc["strides"] = strides
                        end
                    end
                    begin  
                        if use_cudnn_on_gpu !== nothing 
                            desc["use_cudnn_on_gpu"] = use_cudnn_on_gpu
                        end
                    end
                    begin  
                        if padding !== nothing 
                            desc["padding"] = padding
                        end
                    end
                    begin  
                        if data_format !== nothing 
                            desc["data_format"] = data_format
                        end
                    end
                end
            end), name, "Conv2DBackpropInput") 
    tf.Tensor(tf.Operation(desc))
end

"""
     rfft_2d(input, fft_length)

Compute the 2-dimensional discrete Fourier Transform of a real-valued signal

over the inner-most 2 dimensions of `input`.

Since the DFT of a real signal is Hermitian-symmetric, `RFFT2D` only returns the
`fft_length / 2 + 1` unique components of the FFT for the inner-most dimension
of `output`: the zero-frequency term, followed by the `fft_length / 2`
positive-frequency terms.
"""
function rfft_2d(v4140, v4141; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("RFFT2D") 
                begin  
                    begin  
                        if v4140 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4140)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4140)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4141 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4141)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4141)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "RFFT2D") 
    tf.Tensor(tf.Operation(desc))
end

"""
     tensor_array_size_v2(handle, flow_in)

Deprecated. Use TensorArraySizeV3


"""
function tensor_array_size_v2(v4142, v4143; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("TensorArraySizeV2") 
                begin  
                    begin  
                        if v4142 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4142)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4142)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4143 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4143)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4143)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "TensorArraySizeV2") 
    tf.Tensor(tf.Operation(desc))
end

"""
     resource_apply_proximal_adagrad(var, accum, lr, l1, l2, grad; use_locking=false)

Update '*var' and '*accum' according to FOBOS with Adagrad learning rate.

accum += grad * grad
prox_v = var - lr * grad * (1 / sqrt(accum))
var = sign(prox_v)/(1+lr*l2) * max{|prox_v|-lr*l1,0}
"""
function resource_apply_proximal_adagrad(v4144, v4145, v4146, v4147, v4148, v4149; name=nothing, T=nothing, use_locking=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ResourceApplyProximalAdagrad") 
                begin  
                    begin  
                        if v4144 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4144)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4144)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4145 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4145)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4145)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4146 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4146)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4146)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4147 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4147)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4147)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4148 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4148)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4148)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4149 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4149)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4149)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if use_locking !== nothing 
                            desc["use_locking"] = use_locking
                        end
                    end
                end
            end), name, "ResourceApplyProximalAdagrad") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     var_is_initialized_op(resource)

Checks whether a resource handle-based variable has been initialized.


"""
function var_is_initialized_op(v4150; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("VarIsInitializedOp") 
                begin  
                    begin  
                        if v4150 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4150)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4150)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "VarIsInitializedOp") 
    tf.Tensor(tf.Operation(desc))
end

"""
     max_pool_3d(input)

Performs 3D max pooling on the input.


"""
function max_pool_3d(v4151; name=nothing, ksize=nothing, strides=nothing, padding=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("MaxPool3D") 
                begin  
                    begin  
                        if v4151 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4151)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4151)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if ksize !== nothing 
                            desc["ksize"] = ksize
                        end
                    end
                    begin  
                        if strides !== nothing 
                            desc["strides"] = strides
                        end
                    end
                    begin  
                        if padding !== nothing 
                            desc["padding"] = padding
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "MaxPool3D") 
    tf.Tensor(tf.Operation(desc))
end

"""
     fake_quant_with_min_max_vars_gradient(gradients, inputs, min, max)

Compute gradients for a FakeQuantWithMinMaxVars operation.


"""
function fake_quant_with_min_max_vars_gradient(v4152, v4153, v4154, v4155; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("FakeQuantWithMinMaxVarsGradient") 
                begin  
                    begin  
                        if v4152 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4152)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4152)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4153 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4153)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4153)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4154 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4154)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4154)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4155 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4155)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4155)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "FakeQuantWithMinMaxVarsGradient") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2), tf.Tensor(op, 3))
    end
end

"""
     prod(input, reduction_indices; keep_dims=false, Tidx=Int32)

Computes the product of elements across dimensions of a tensor.

Reduces `input` along the dimensions given in `reduction_indices`. Unless
`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in
`reduction_indices`. If `keep_dims` is true, the reduced dimensions are
retained with length 1.
"""
function prod(v4156, v4157; name=nothing, keep_dims=nothing, T=nothing, Tidx=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Prod") 
                begin  
                    begin  
                        if v4156 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4156)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4156)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4157 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4157)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4157)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if keep_dims !== nothing 
                            desc["keep_dims"] = keep_dims
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tidx !== nothing 
                            desc["Tidx"] = Tidx
                        end
                    end
                end
            end), name, "Prod") 
    tf.Tensor(tf.Operation(desc))
end

"""
     tensor_array_gather_v2(handle, indices, flow_in; element_shape=TensorShape[unknown])

Deprecated. Use TensorArrayGatherV3


"""
function tensor_array_gather_v2(v4158, v4159, v4160; name=nothing, dtype=nothing, element_shape=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("TensorArrayGatherV2") 
                begin  
                    begin  
                        if v4158 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4158)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4158)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4159 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4159)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4159)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4160 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4160)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4160)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if dtype !== nothing 
                            desc["dtype"] = dtype
                        end
                    end
                    begin  
                        if element_shape !== nothing 
                            desc["element_shape"] = element_shape
                        end
                    end
                end
            end), name, "TensorArrayGatherV2") 
    tf.Tensor(tf.Operation(desc))
end

"""
     fused_resize_and_pad_conv_2d(input, size, paddings, filter; resize_align_corners=false)

Performs a resize and padding as a preprocess during a convolution.

It's often possible to do spatial transformations more efficiently as part of
the packing stage of a convolution, so this op allows for an optimized
implementation where these stages are fused together. This prevents the need to
write out the intermediate results as whole tensors, reducing memory pressure,
and we can get some latency gains by merging the transformation calculations.
The data_format attribute for Conv2D isn't supported by this op, and defaults to
'NHWC' order.
Internally this op uses a single per-graph scratch buffer, which means that it
will block if multiple versions are being run in parallel. This is because this
operator is primarily an optimization to minimize memory usage.
"""
function fused_resize_and_pad_conv_2d(v4161, v4162, v4163, v4164; name=nothing, T=nothing, resize_align_corners=nothing, mode=nothing, strides=nothing, padding=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("FusedResizeAndPadConv2D") 
                begin  
                    begin  
                        if v4161 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4161)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4161)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4162 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4162)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4162)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4163 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4163)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4163)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4164 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4164)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4164)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if resize_align_corners !== nothing 
                            desc["resize_align_corners"] = resize_align_corners
                        end
                    end
                    begin  
                        if mode !== nothing 
                            desc["mode"] = mode
                        end
                    end
                    begin  
                        if strides !== nothing 
                            desc["strides"] = strides
                        end
                    end
                    begin  
                        if padding !== nothing 
                            desc["padding"] = padding
                        end
                    end
                end
            end), name, "FusedResizeAndPadConv2D") 
    tf.Tensor(tf.Operation(desc))
end

"""
     less(x, y)

Returns the truth value of (x < y) element-wise.

*NOTE*: `Less` supports broadcasting. More about broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
"""
function less(v4165, v4166; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Less") 
                begin  
                    begin  
                        if v4165 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4165)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4165)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4166 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4166)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4166)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Less") 
    tf.Tensor(tf.Operation(desc))
end

"""
     self_adjoint_eig_v2(input; compute_v=true)

Computes the eigen decomposition of one or more square self-adjoint matrices.

Computes the eigenvalues and (optionally) eigenvectors of each inner matrix in
`input` such that `input[..., :, :] = v[..., :, :] * diag(e[..., :])`.

```prettyprint
# a is a tensor.
# e is a tensor of eigenvalues.
# v is a tensor of eigenvectors.
e, v = self_adjoint_eig(a)
e = self_adjoint_eig(a, compute_v=False)
```
"""
function self_adjoint_eig_v2(v4167; name=nothing, compute_v=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SelfAdjointEigV2") 
                begin  
                    begin  
                        if v4167 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4167)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4167)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if compute_v !== nothing 
                            desc["compute_v"] = compute_v
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "SelfAdjointEigV2") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2))
    end
end

"""
     random_poisson(shape, rate; seed=0, seed2=0)

Outputs random values from the Poisson distribution(s) described by rate.

This op uses two algorithms, depending on rate. If rate >= 10, then
the algorithm by Hormann is used to acquire samples via
transformation-rejection.
See http://www.sciencedirect.com/science/article/pii/0167668793909974.

Otherwise, Knuth's algorithm is used to acquire samples via multiplying uniform
random variables.
See Donald E. Knuth (1969). Seminumerical Algorithms. The Art of Computer
Programming, Volume 2. Addison Wesley
"""
function random_poisson(v4168, v4169; name=nothing, seed=nothing, seed2=nothing, S=nothing, dtype=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("RandomPoisson") 
                begin  
                    begin  
                        if v4168 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4168)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4168)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4169 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4169)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4169)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if seed !== nothing 
                            desc["seed"] = seed
                        end
                    end
                    begin  
                        if seed2 !== nothing 
                            desc["seed2"] = seed2
                        end
                    end
                    begin  
                        if S !== nothing 
                            desc["S"] = S
                        end
                    end
                    begin  
                        if dtype !== nothing 
                            desc["dtype"] = dtype
                        end
                    end
                end
            end), name, "RandomPoisson") 
    tf.Tensor(tf.Operation(desc))
end

"""
     reverse_sequence(input, seq_lengths; batch_dim=0, Tlen=Int64)

Reverses variable length slices.

This op first slices `input` along the dimension `batch_dim`, and for each
slice `i`, reverses the first `seq_lengths[i]` elements along
the dimension `seq_dim`.

The elements of `seq_lengths` must obey `seq_lengths[i] <= input.dims[seq_dim]`,
and `seq_lengths` must be a vector of length `input.dims[batch_dim]`.

The output slice `i` along dimension `batch_dim` is then given by input
slice `i`, with the first `seq_lengths[i]` slices along dimension
`seq_dim` reversed.

For example:

```prettyprint
# Given this:
batch_dim = 0
seq_dim = 1
input.dims = (4, 8, ...)
seq_lengths = [7, 2, 3, 5]

# then slices of input are reversed on seq_dim, but only up to seq_lengths:
output[0, 0:7, :, ...] = input[0, 7:0:-1, :, ...]
output[1, 0:2, :, ...] = input[1, 2:0:-1, :, ...]
output[2, 0:3, :, ...] = input[2, 3:0:-1, :, ...]
output[3, 0:5, :, ...] = input[3, 5:0:-1, :, ...]

# while entries past seq_lens are copied through:
output[0, 7:, :, ...] = input[0, 7:, :, ...]
output[1, 2:, :, ...] = input[1, 2:, :, ...]
output[2, 3:, :, ...] = input[2, 3:, :, ...]
output[3, 2:, :, ...] = input[3, 2:, :, ...]
```

In contrast, if:

```prettyprint
# Given this:
batch_dim = 2
seq_dim = 0
input.dims = (8, ?, 4, ...)
seq_lengths = [7, 2, 3, 5]

# then slices of input are reversed on seq_dim, but only up to seq_lengths:
output[0:7, :, 0, :, ...] = input[7:0:-1, :, 0, :, ...]
output[0:2, :, 1, :, ...] = input[2:0:-1, :, 1, :, ...]
output[0:3, :, 2, :, ...] = input[3:0:-1, :, 2, :, ...]
output[0:5, :, 3, :, ...] = input[5:0:-1, :, 3, :, ...]

# while entries past seq_lens are copied through:
output[7:, :, 0, :, ...] = input[7:, :, 0, :, ...]
output[2:, :, 1, :, ...] = input[2:, :, 1, :, ...]
output[3:, :, 2, :, ...] = input[3:, :, 2, :, ...]
output[2:, :, 3, :, ...] = input[2:, :, 3, :, ...]
```
"""
function reverse_sequence(v4170, v4171; name=nothing, seq_dim=nothing, batch_dim=nothing, T=nothing, Tlen=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ReverseSequence") 
                begin  
                    begin  
                        if v4170 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4170)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4170)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4171 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4171)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4171)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if seq_dim !== nothing 
                            desc["seq_dim"] = seq_dim
                        end
                    end
                    begin  
                        if batch_dim !== nothing 
                            desc["batch_dim"] = batch_dim
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tlen !== nothing 
                            desc["Tlen"] = Tlen
                        end
                    end
                end
            end), name, "ReverseSequence") 
    tf.Tensor(tf.Operation(desc))
end

"""
     resource_sparse_apply_adagrad_da(var, gradient_accumulator, gradient_squared_accumulator, grad, indices, lr, l1, l2, global_step; use_locking=false)

Update entries in '*var' and '*accum' according to the proximal adagrad scheme.


"""
function resource_sparse_apply_adagrad_da(v4172, v4173, v4174, v4175, v4176, v4177, v4178, v4179, v4180; name=nothing, T=nothing, Tindices=nothing, use_locking=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ResourceSparseApplyAdagradDA") 
                begin  
                    begin  
                        if v4172 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4172)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4172)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4173 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4173)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4173)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4174 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4174)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4174)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4175 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4175)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4175)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4176 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4176)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4176)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4177 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4177)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4177)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4178 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4178)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4178)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4179 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4179)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4179)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4180 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4180)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4180)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tindices !== nothing 
                            desc["Tindices"] = Tindices
                        end
                    end
                    begin  
                        if use_locking !== nothing 
                            desc["use_locking"] = use_locking
                        end
                    end
                end
            end), name, "ResourceSparseApplyAdagradDA") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     temporary_variable(; var_name=)

Returns a tensor that may be mutated, but only persists within a single step.

This is an experimental op for internal use only and it is possible to use this
op in unsafe ways.  DO NOT USE unless you fully understand the risks.

It is the caller's responsibility to ensure that 'ref' is eventually passed to a
matching 'DestroyTemporaryVariable' op after all other uses have completed.

Outputs a ref to the tensor state so it may be read or modified.

  E.g.
      var = state_ops._temporary_variable([1, 2], types.float_)
      var_name = var.op.name
      var = state_ops.assign(var, [[4.0, 5.0]])
      var = state_ops.assign_add(var, [[6.0, 7.0]])
      final = state_ops._destroy_temporary_variable(var, var_name=var_name)
"""
function temporary_variable(; name=nothing, shape=nothing, dtype=nothing, var_name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("TemporaryVariable") 
                begin  
                end 
                begin  
                    begin  
                        if shape !== nothing 
                            desc["shape"] = shape
                        end
                    end
                    begin  
                        if dtype !== nothing 
                            desc["dtype"] = dtype
                        end
                    end
                    begin  
                        if var_name !== nothing 
                            desc["var_name"] = var_name
                        end
                    end
                end
            end), name, "TemporaryVariable") 
    tf.Tensor(tf.Operation(desc))
end

"""
     batch_to_space_nd(input, block_shape, crops; Tblock_shape=Int32, Tcrops=Int32)

BatchToSpace for N-D tensors of type T.

This operation reshapes the "batch" dimension 0 into `M + 1` dimensions of shape
`block_shape + [batch]`, interleaves these blocks back into the grid defined by
the spatial dimensions `[1, ..., M]`, to obtain a result with the same rank as
the input.  The spatial dimensions of this intermediate result are then
optionally cropped according to `crops` to produce the output.  This is the
reverse of SpaceToBatch.  See below for a precise description.
"""
function batch_to_space_nd(v4181, v4182, v4183; name=nothing, T=nothing, Tblock_shape=nothing, Tcrops=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("BatchToSpaceND") 
                begin  
                    begin  
                        if v4181 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4181)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4181)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4182 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4182)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4182)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4183 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4183)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4183)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tblock_shape !== nothing 
                            desc["Tblock_shape"] = Tblock_shape
                        end
                    end
                    begin  
                        if Tcrops !== nothing 
                            desc["Tcrops"] = Tcrops
                        end
                    end
                end
            end), name, "BatchToSpaceND") 
    tf.Tensor(tf.Operation(desc))
end

"""
     sub(x, y)

Returns x - y element-wise.

*NOTE*: `Sub` supports broadcasting. More about broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
"""
function sub(v4184, v4185; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Sub") 
                begin  
                    begin  
                        if v4184 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4184)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4184)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4185 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4185)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4185)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Sub") 
    tf.Tensor(tf.Operation(desc))
end

"""
     quantized_bias_add(input, bias, min_input, max_input, min_bias, max_bias)

Adds Tensor 'bias' to Tensor 'input' for Quantized types.

Broadcasts the values of bias on dimensions 0..N-2 of 'input'.
"""
function quantized_bias_add(v4186, v4187, v4188, v4189, v4190, v4191; name=nothing, T1=nothing, T2=nothing, out_type=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("QuantizedBiasAdd") 
                begin  
                    begin  
                        if v4186 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4186)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4186)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4187 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4187)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4187)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4188 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4188)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4188)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4189 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4189)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4189)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4190 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4190)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4190)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4191 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4191)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4191)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T1 !== nothing 
                            desc["T1"] = T1
                        end
                    end
                    begin  
                        if T2 !== nothing 
                            desc["T2"] = T2
                        end
                    end
                    begin  
                        if out_type !== nothing 
                            desc["out_type"] = out_type
                        end
                    end
                end
            end), name, "QuantizedBiasAdd") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2), tf.Tensor(op, 3))
    end
end

"""
     string_split(input, delimiter)

Split elements of `input` based on `delimiter` into a `SparseTensor`.

Let N be the size of source (typically N will be the batch size). Split each
element of `input` based on `delimiter` and return a `SparseTensor`
containing the splitted tokens. Empty tokens are ignored.

`delimiter` can be empty, or a string of split characters. If `delimiter` is an
 empty string, each element of `input` is split into individual single-byte
 character strings, including splitting of UTF-8 multibyte sequences. Otherwise
 every character of `delimiter` is a potential split point.

For example:
  N = 2, input[0] is 'hello world' and input[1] is 'a b c', then the output
  will be

  indices = [0, 0;
             0, 1;
             1, 0;
             1, 1;
             1, 2]
  shape = [2, 3]
  values = ['hello', 'world', 'a', 'b', 'c']
"""
function string_split(v4192, v4193; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("StringSplit") 
                begin  
                    begin  
                        if v4192 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4192)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4192)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4193 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4193)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4193)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "StringSplit") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2), tf.Tensor(op, 3))
    end
end

"""
     crop_and_resize(image, boxes, box_ind, crop_size; method=bilinear, extrapolation_value=nothing)

Extracts crops from the input image tensor and bilinearly resizes them (possibly

with aspect ratio change) to a common output size specified by `crop_size`. This
is more general than the `crop_to_bounding_box` op which extracts a fixed size
slice from the input image and does not allow resizing or aspect ratio change.

Returns a tensor with `crops` from the input `image` at positions defined at the
bounding box locations in `boxes`. The cropped boxes are all resized (with
bilinear interpolation) to a fixed `size = [crop_height, crop_width]`. The
result is a 4-D tensor `[num_boxes, crop_height, crop_width, depth]`.
"""
function crop_and_resize(v4194, v4195, v4196, v4197; name=nothing, T=nothing, method=nothing, extrapolation_value=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("CropAndResize") 
                begin  
                    begin  
                        if v4194 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4194)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4194)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4195 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4195)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4195)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4196 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4196)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4196)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4197 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4197)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4197)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if method !== nothing 
                            desc["method"] = method
                        end
                    end
                    begin  
                        if extrapolation_value !== nothing 
                            desc["extrapolation_value"] = extrapolation_value
                        end
                    end
                end
            end), name, "CropAndResize") 
    tf.Tensor(tf.Operation(desc))
end

"""
     cumprod(x, axis; exclusive=false, reverse=false, Tidx=Int32)

Compute the cumulative product of the tensor `x` along `axis`.

By default, this op performs an inclusive cumprod, which means that the first
element of the input is identical to the first element of the output:
```prettyprint
tf.cumprod([a, b, c]) ==> [a, a * b, a * b * c]
```

By setting the `exclusive` kwarg to `True`, an exclusive cumprod is
performed instead:
```prettyprint
tf.cumprod([a, b, c], exclusive=True) ==> [1, a, a * b]
```

By setting the `reverse` kwarg to `True`, the cumprod is performed in the
opposite direction:
```prettyprint
tf.cumprod([a, b, c], reverse=True) ==> [a * b * c, b * c, c]
```
This is more efficient than using separate `tf.reverse` ops.

The `reverse` and `exclusive` kwargs can also be combined:
```prettyprint
tf.cumprod([a, b, c], exclusive=True, reverse=True) ==> [b * c, c, 1]
```
"""
function cumprod(v4198, v4199; name=nothing, exclusive=nothing, reverse=nothing, T=nothing, Tidx=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Cumprod") 
                begin  
                    begin  
                        if v4198 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4198)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4198)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4199 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4199)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4199)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if exclusive !== nothing 
                            desc["exclusive"] = exclusive
                        end
                    end
                    begin  
                        if reverse !== nothing 
                            desc["reverse"] = reverse
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tidx !== nothing 
                            desc["Tidx"] = Tidx
                        end
                    end
                end
            end), name, "Cumprod") 
    tf.Tensor(tf.Operation(desc))
end

"""
     is_variable_initialized(ref)

Checks whether a tensor has been initialized.

Outputs boolean scalar indicating whether the tensor has been initialized.
"""
function is_variable_initialized(v4200; name=nothing, dtype=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("IsVariableInitialized") 
                begin  
                    begin  
                        if v4200 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4200)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4200)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if dtype !== nothing 
                            desc["dtype"] = dtype
                        end
                    end
                end
            end), name, "IsVariableInitialized") 
    tf.Tensor(tf.Operation(desc))
end

"""
     scatter_nd_sub(ref, indices, updates; use_locking=false)

Applies sparse subtraction between `updates` and individual values or slices

within a given variable according to `indices`.

`ref` is a `Tensor` with rank `P` and `indices` is a `Tensor` of rank `Q`.

`indices` must be integer tensor, containing indices into `ref`.
It must be shape `[d_0, ..., d_{Q-2}, K]` where `0 < K <= P`.

The innermost dimension of `indices` (with length `K`) corresponds to
indices into elements (if `K = P`) or slices (if `K < P`) along the `K`th
dimension of `ref`.

`updates` is `Tensor` of rank `Q-1+P-K` with shape:

```
[d_0, ..., d_{Q-2}, ref.shape[K], ..., ref.shape[P-1]].
```

For example, say we want to subtract 4 scattered elements from a rank-1 tensor
with 8 elements. In Python, that subtraction would look like this:

    ref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8])
    indices = tf.constant([[4], [3], [1], [7]])
    updates = tf.constant([9, 10, 11, 12])
    sub = tf.scatter_nd_sub(ref, indices, updates)
    with tf.Session() as sess:
      print sess.run(sub)

The resulting update to ref would look like this:

    [1, -9, 3, -6, -4, 6, 7, -4]

See [tf.scatter_nd](#scatter_nd) for more details about how to make updates to
slices.
"""
function scatter_nd_sub(v4201, v4202, v4203; name=nothing, T=nothing, Tindices=nothing, use_locking=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ScatterNdSub") 
                begin  
                    begin  
                        if v4201 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4201)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4201)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4202 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4202)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4202)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4203 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4203)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4203)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tindices !== nothing 
                            desc["Tindices"] = Tindices
                        end
                    end
                    begin  
                        if use_locking !== nothing 
                            desc["use_locking"] = use_locking
                        end
                    end
                end
            end), name, "ScatterNdSub") 
    tf.Tensor(tf.Operation(desc))
end

"""
     loop_cond(input)

Forwards the input to the output.

This operator represents the loop termination condition used by the
"pivot" switches of a loop.
"""
function loop_cond(v4204; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("LoopCond") 
                begin  
                    begin  
                        if v4204 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4204)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4204)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "LoopCond") 
    tf.Tensor(tf.Operation(desc))
end

"""
     resize_bilinear(images, size; align_corners=false)

Resize `images` to `size` using bilinear interpolation.

Input images can be of different types but output images are always float.
"""
function resize_bilinear(v4205, v4206; name=nothing, T=nothing, align_corners=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ResizeBilinear") 
                begin  
                    begin  
                        if v4205 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4205)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4205)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4206 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4206)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4206)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if align_corners !== nothing 
                            desc["align_corners"] = align_corners
                        end
                    end
                end
            end), name, "ResizeBilinear") 
    tf.Tensor(tf.Operation(desc))
end

"""
     assign_add(ref, value; use_locking=false)

Update 'ref' by adding 'value' to it.

This operation outputs "ref" after the update is done.
This makes it easier to chain operations that need to use the reset value.
"""
function assign_add(v4207, v4208; name=nothing, T=nothing, use_locking=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("AssignAdd") 
                begin  
                    begin  
                        if v4207 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4207)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4207)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4208 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4208)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4208)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if use_locking !== nothing 
                            desc["use_locking"] = use_locking
                        end
                    end
                end
            end), name, "AssignAdd") 
    tf.Tensor(tf.Operation(desc))
end

"""
     depth_to_space(input)

DepthToSpace for tensors of type T.

Rearranges data from depth into blocks of spatial data.
This is the reverse transformation of SpaceToDepth. More specifically,
this op outputs a copy of the input tensor where values from the `depth`
dimension are moved in spatial blocks to the `height` and `width` dimensions.
The attr `block_size` indicates the input block size and how the data is moved.

  * Chunks of data of size `block_size * block_size` from depth are rearranged
    into non-overlapping blocks of size `block_size x block_size`
  * The width the output tensor is `input_depth * block_size`, whereas the
    height is `input_height * block_size`.
  * The depth of the input tensor must be divisible by
    `block_size * block_size`.

That is, assuming the input is in the shape:
`[batch, height, width, depth]`,
the shape of the output will be:
`[batch, height*block_size, width*block_size, depth/(block_size*block_size)]`

This operation requires that the input tensor be of rank 4, and that
`block_size` be >=1 and that `block_size * block_size` be a divisor of the
input depth.

This operation is useful for resizing the activations between convolutions
(but keeping all data), e.g. instead of pooling. It is also useful for training
purely convolutional models.

For example, given this input of shape `[1, 1, 1, 4]`, and a block size of 2:

```prettyprint
x = [[[[1, 2, 3, 4]]]]

```

This operation will output a tensor of shape `[1, 2, 2, 1]`:

```prettyprint
   [[[[1], [2]],
     [[3], [4]]]]
```

Here, the input has a batch of 1 and each batch element has shape `[1, 1, 4]`,
the corresponding output will have 2x2 elements and will have a depth of
1 channel (1 = `4 / (block_size * block_size)`).
The output element shape is `[2, 2, 1]`.

For an input tensor with larger depth, here of shape `[1, 1, 1, 12]`, e.g.

```prettyprint
x = [[[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]]]]
```

This operation, for block size of 2, will return the following tensor of shape
`[1, 2, 2, 3]`

```prettyprint
   [[[[1, 2, 3], [4, 5, 6]],
     [[7, 8, 9], [10, 11, 12]]]]

```

Similarly, for the following input of shape `[1 2 2 4]`, and a block size of 2:

```prettyprint
x =  [[[[1, 2, 3, 4],
       [5, 6, 7, 8]],
      [[9, 10, 11, 12],
       [13, 14, 15, 16]]]]
```

the operator will return the following tensor of shape `[1 4 4 1]`:

```prettyprint
x = [[ [1],   [2],  [5],  [6]],
     [ [3],   [4],  [7],  [8]],
     [ [9],  [10], [13],  [14]],
     [ [11], [12], [15],  [16]]]

```
"""
function depth_to_space(v4209; name=nothing, T=nothing, block_size=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("DepthToSpace") 
                begin  
                    begin  
                        if v4209 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4209)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4209)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if block_size !== nothing 
                            desc["block_size"] = block_size
                        end
                    end
                end
            end), name, "DepthToSpace") 
    tf.Tensor(tf.Operation(desc))
end

"""
     destroy_temporary_variable(ref)

Destroys the temporary variable and returns its final value.

Sets output to the value of the Tensor pointed to by 'ref', then destroys
the temporary variable called 'var_name'.
All other uses of 'ref' *must* have executed before this op.
This is typically achieved by chaining the ref through each assign op, or by
using control dependencies.

Outputs the final value of the tensor pointed to by 'ref'.
"""
function destroy_temporary_variable(v4210; name=nothing, T=nothing, var_name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("DestroyTemporaryVariable") 
                begin  
                    begin  
                        if v4210 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4210)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4210)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if var_name !== nothing 
                            desc["var_name"] = var_name
                        end
                    end
                end
            end), name, "DestroyTemporaryVariable") 
    tf.Tensor(tf.Operation(desc))
end

"""
     fake_quant_with_min_max_vars(inputs, min, max)

Fake-quantize the 'inputs' tensor of type float via global float scalars `min`

and `max` to 'outputs' tensor of same shape as `inputs`.

[min; max] is the clamping range for the 'inputs' data.  Op divides this range
into 255 steps (total of 256 values), then replaces each 'inputs' value with the
closest of the quantized step values.

This operation has a gradient and thus allows for training `min` and `max` values.
"""
function fake_quant_with_min_max_vars(v4211, v4212, v4213; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("FakeQuantWithMinMaxVars") 
                begin  
                    begin  
                        if v4211 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4211)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4211)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4212 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4212)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4212)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4213 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4213)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4213)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "FakeQuantWithMinMaxVars") 
    tf.Tensor(tf.Operation(desc))
end

"""
     tensor_array(size; dynamic_size=false, clear_after_read=true, tensor_array_name=, element_shape=TensorShape[unknown])




"""
function tensor_array(v4214; name=nothing, dtype=nothing, dynamic_size=nothing, clear_after_read=nothing, tensor_array_name=nothing, element_shape=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("TensorArray") 
                begin  
                    begin  
                        if v4214 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4214)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4214)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if dtype !== nothing 
                            desc["dtype"] = dtype
                        end
                    end
                    begin  
                        if dynamic_size !== nothing 
                            desc["dynamic_size"] = dynamic_size
                        end
                    end
                    begin  
                        if clear_after_read !== nothing 
                            desc["clear_after_read"] = clear_after_read
                        end
                    end
                    begin  
                        if tensor_array_name !== nothing 
                            desc["tensor_array_name"] = tensor_array_name
                        end
                    end
                    begin  
                        if element_shape !== nothing 
                            desc["element_shape"] = element_shape
                        end
                    end
                end
            end), name, "TensorArray") 
    tf.Tensor(tf.Operation(desc))
end

"""
     reader_read_up_to_v2(reader_handle, queue_handle, num_records)

Returns up to `num_records` (key, value) pairs produced by a Reader.

Will dequeue from the input queue if necessary (e.g. when the
Reader needs to start reading from a new file since it has finished
with the previous file).
It may return less than `num_records` even before the last batch.
"""
function reader_read_up_to_v2(v4215, v4216, v4217; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ReaderReadUpToV2") 
                begin  
                    begin  
                        if v4215 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4215)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4215)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4216 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4216)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4216)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4217 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4217)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4217)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "ReaderReadUpToV2") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2))
    end
end

"""
     ref_identity(input)

Return the same ref tensor as the input ref tensor.


"""
function ref_identity(v4218; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("RefIdentity") 
                begin  
                    begin  
                        if v4218 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4218)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4218)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "RefIdentity") 
    tf.Tensor(tf.Operation(desc))
end

"""
     complex(real, imag; T=Float32, Tout=?)

Converts two real numbers to a complex number.

Given a tensor `real` representing the real part of a complex number, and a
tensor `imag` representing the imaginary part of a complex number, this
operation returns complex numbers elementwise of the form \\(a + bj\\), where
*a* represents the `real` part and *b* represents the `imag` part.

The input tensors `real` and `imag` must have the same shape.

For example:

```
# tensor 'real' is [2.25, 3.25]
# tensor `imag` is [4.75, 5.75]
tf.complex(real, imag) ==> [[2.25 + 4.75j], [3.25 + 5.75j]]
```
"""
function complex(v4219, v4220; name=nothing, T=nothing, Tout=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Complex") 
                begin  
                    begin  
                        if v4219 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4219)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4219)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4220 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4220)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4220)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tout !== nothing 
                            desc["Tout"] = Tout
                        end
                    end
                end
            end), name, "Complex") 
    tf.Tensor(tf.Operation(desc))
end

"""
     scalar_summary(tags, values)

Outputs a `Summary` protocol buffer with scalar values.

The input `tags` and `values` must have the same shape.  The generated summary
has a summary value for each tag-value pair in `tags` and `values`.
"""
function scalar_summary(v4221, v4222; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ScalarSummary") 
                begin  
                    begin  
                        if v4221 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4221)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4221)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4222 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4222)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4222)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "ScalarSummary") 
    tf.Tensor(tf.Operation(desc))
end

"""
     max_pool_3d_grad(orig_input, orig_output, grad)

Computes gradients of max pooling function.


"""
function max_pool_3d_grad(v4223, v4224, v4225; name=nothing, ksize=nothing, strides=nothing, padding=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("MaxPool3DGrad") 
                begin  
                    begin  
                        if v4223 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4223)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4223)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4224 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4224)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4224)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4225 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4225)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4225)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if ksize !== nothing 
                            desc["ksize"] = ksize
                        end
                    end
                    begin  
                        if strides !== nothing 
                            desc["strides"] = strides
                        end
                    end
                    begin  
                        if padding !== nothing 
                            desc["padding"] = padding
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "MaxPool3DGrad") 
    tf.Tensor(tf.Operation(desc))
end

"""
     pow(x, y)

Computes the power of one value to another.

Given a tensor `x` and a tensor `y`, this operation computes \\(x^y\\) for
corresponding elements in `x` and `y`. For example:

```
# tensor 'x' is [[2, 2]], [3, 3]]
# tensor 'y' is [[8, 16], [2, 3]]
tf.pow(x, y) ==> [[256, 65536], [9, 27]]
```
"""
function pow(v4226, v4227; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Pow") 
                begin  
                    begin  
                        if v4226 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4226)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4226)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4227 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4227)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4227)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Pow") 
    tf.Tensor(tf.Operation(desc))
end

"""
     bitcast(input)

Bitcasts a tensor from one type to another without copying data.

Given a tensor `input`, this operation returns a tensor that has the same buffer
data as `input` with datatype `type`.

If the input datatype `T` is larger than the output datatype `type` then the
shape changes from [...] to [..., sizeof(`T`)/sizeof(`type`)].

If `T` is smaller than `type`, the operator requires that the rightmost
dimension be equal to sizeof(`type`)/sizeof(`T`). The shape then goes from
[..., sizeof(`type`)/sizeof(`T`)] to [...].

*NOTE*: Bitcast is implemented as a low-level cast, so machines with different
endian orderings will give different results.
"""
function bitcast(v4228; name=nothing, T=nothing, type_=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Bitcast") 
                begin  
                    begin  
                        if v4228 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4228)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4228)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if type_ !== nothing 
                            desc["type"] = type_
                        end
                    end
                end
            end), name, "Bitcast") 
    tf.Tensor(tf.Operation(desc))
end

"""
     ref_next_iteration(data)

Makes its input available to the next iteration.


"""
function ref_next_iteration(v4229; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("RefNextIteration") 
                begin  
                    begin  
                        if v4229 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4229)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4229)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "RefNextIteration") 
    tf.Tensor(tf.Operation(desc))
end

"""
     tensor_array_close_v3(handle)

Delete the TensorArray from its resource container.  This enables

the user to close and release the resource in the middle of a step/run.
"""
function tensor_array_close_v3(v4230; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("TensorArrayCloseV3") 
                begin  
                    begin  
                        if v4230 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4230)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4230)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "TensorArrayCloseV3") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     padding_fifoq_v2(; shapes=Int64[], capacity=-1, container=, shared_name=)

A queue that produces elements in first-in first-out order.

Variable-size shapes are allowed by setting the corresponding shape dimensions
to 0 in the shape attr.  In this case DequeueMany will pad up to the maximum
size of any given element in the minibatch.  See below for details.
"""
function padding_fifoq_v2(; name=nothing, component_types=nothing, shapes=nothing, capacity=nothing, container=nothing, shared_name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("PaddingFIFOQueueV2") 
                begin  
                end 
                begin  
                    begin  
                        if component_types !== nothing 
                            desc["component_types"] = component_types
                        end
                    end
                    begin  
                        if shapes !== nothing 
                            desc["shapes"] = shapes
                        end
                    end
                    begin  
                        if capacity !== nothing 
                            desc["capacity"] = capacity
                        end
                    end
                    begin  
                        if container !== nothing 
                            desc["container"] = container
                        end
                    end
                    begin  
                        if shared_name !== nothing 
                            desc["shared_name"] = shared_name
                        end
                    end
                end
            end), name, "PaddingFIFOQueueV2") 
    tf.Tensor(tf.Operation(desc))
end

"""
     conv_3d_backprop_input(input, filter, out_backprop)

Computes the gradients of 3-D convolution with respect to the input.


"""
function conv_3d_backprop_input(v4231, v4232, v4233; name=nothing, T=nothing, strides=nothing, padding=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Conv3DBackpropInput") 
                begin  
                    begin  
                        if v4231 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4231)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4231)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4232 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4232)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4232)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4233 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4233)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4233)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if strides !== nothing 
                            desc["strides"] = strides
                        end
                    end
                    begin  
                        if padding !== nothing 
                            desc["padding"] = padding
                        end
                    end
                end
            end), name, "Conv3DBackpropInput") 
    tf.Tensor(tf.Operation(desc))
end

"""
     pack(values; axis=0)

Packs a list of `N` rank-`R` tensors into one rank-`(R+1)` tensor.

Packs the `N` tensors in `values` into a tensor with rank one higher than each
tensor in `values`, by packing them along the `axis` dimension.
Given a list of tensors of shape `(A, B, C)`;

if `axis == 0` then the `output` tensor will have the shape `(N, A, B, C)`.
if `axis == 1` then the `output` tensor will have the shape `(A, N, B, C)`.
Etc.

For example:

```prettyprint
# 'x' is [1, 4]
# 'y' is [2, 5]
# 'z' is [3, 6]
pack([x, y, z]) => [[1, 4], [2, 5], [3, 6]]  # Pack along first dim.
pack([x, y, z], axis=1) => [[1, 2, 3], [4, 5, 6]]
```

This is the opposite of `unpack`.
"""
function pack(v4234; name=nothing, N=nothing, T=nothing, axis=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Pack") 
                begin  
                    begin  
                        if v4234 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4234)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4234)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if N !== nothing 
                            desc["N"] = N
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if axis !== nothing 
                            desc["axis"] = axis
                        end
                    end
                end
            end), name, "Pack") 
    tf.Tensor(tf.Operation(desc))
end

"""
     priority_queue(; component_types=Int64[], capacity=-1, container=, shared_name=)

A queue that produces elements sorted by the first component value.

Note that the PriorityQueue requires the first component of any element
to be a scalar int64, in addition to the other elements declared by
component_types.  Therefore calls to Enqueue and EnqueueMany (resp. Dequeue
and DequeueMany) on a PriorityQueue will all require (resp. output) one extra
entry in their input (resp. output) lists.
"""
function priority_queue(; name=nothing, component_types=nothing, shapes=nothing, capacity=nothing, container=nothing, shared_name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("PriorityQueue") 
                begin  
                end 
                begin  
                    begin  
                        if component_types !== nothing 
                            desc["component_types"] = component_types
                        end
                    end
                    begin  
                        if shapes !== nothing 
                            desc["shapes"] = shapes
                        end
                    end
                    begin  
                        if capacity !== nothing 
                            desc["capacity"] = capacity
                        end
                    end
                    begin  
                        if container !== nothing 
                            desc["container"] = container
                        end
                    end
                    begin  
                        if shared_name !== nothing 
                            desc["shared_name"] = shared_name
                        end
                    end
                end
            end), name, "PriorityQueue") 
    tf.Tensor(tf.Operation(desc))
end

"""
     quantized_batch_norm_with_global_normalization(t, t_min, t_max, m, m_min, m_max, v, v_min, v_max, beta, beta_min, beta_max, gamma, gamma_min, gamma_max)

Quantized Batch normalization.

This op is deprecated and will be removed in the future. Prefer
`tf.nn.batch_normalization`.
"""
function quantized_batch_norm_with_global_normalization(v4235, v4236, v4237, v4238, v4239, v4240, v4241, v4242, v4243, v4244, v4245, v4246, v4247, v4248, v4249; name=nothing, Tinput=nothing, out_type=nothing, variance_epsilon=nothing, scale_after_normalization=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("QuantizedBatchNormWithGlobalNormalization") 
                begin  
                    begin  
                        if v4235 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4235)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4235)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4236 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4236)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4236)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4237 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4237)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4237)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4238 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4238)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4238)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4239 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4239)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4239)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4240 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4240)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4240)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4241 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4241)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4241)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4242 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4242)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4242)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4243 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4243)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4243)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4244 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4244)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4244)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4245 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4245)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4245)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4246 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4246)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4246)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4247 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4247)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4247)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4248 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4248)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4248)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4249 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4249)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4249)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if Tinput !== nothing 
                            desc["Tinput"] = Tinput
                        end
                    end
                    begin  
                        if out_type !== nothing 
                            desc["out_type"] = out_type
                        end
                    end
                    begin  
                        if variance_epsilon !== nothing 
                            desc["variance_epsilon"] = variance_epsilon
                        end
                    end
                    begin  
                        if scale_after_normalization !== nothing 
                            desc["scale_after_normalization"] = scale_after_normalization
                        end
                    end
                end
            end), name, "QuantizedBatchNormWithGlobalNormalization") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2), tf.Tensor(op, 3))
    end
end

"""
     cos(x)

Computes cos of x element-wise.


"""
function cos(v4250; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Cos") 
                begin  
                    begin  
                        if v4250 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4250)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4250)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Cos") 
    tf.Tensor(tf.Operation(desc))
end

"""
     unique(x; out_idx=Int32)

Finds unique elements in a 1-D tensor.

This operation returns a tensor `y` containing all of the unique elements of `x`
sorted in the same order that they occur in `x`. This operation also returns a
tensor `idx` the same size as `x` that contains the index of each value of `x`
in the unique output `y`. In other words:

`y[idx[i]] = x[i] for i in [0, 1,...,rank(x) - 1]`

For example:

```prettyprint
# tensor 'x' is [1, 1, 2, 4, 4, 4, 7, 8, 8]
y, idx = unique(x)
y ==> [1, 2, 4, 7, 8]
idx ==> [0, 0, 1, 2, 2, 2, 3, 4, 4]
```
"""
function unique(v4251; name=nothing, T=nothing, out_idx=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Unique") 
                begin  
                    begin  
                        if v4251 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4251)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4251)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if out_idx !== nothing 
                            desc["out_idx"] = out_idx
                        end
                    end
                end
            end), name, "Unique") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2))
    end
end

"""
     quantize_down_and_shrink_range(input, input_min, input_max)

Convert the quantized 'input' tensor into a lower-precision 'output', using the

actual distribution of the values to maximize the usage of the lower bit depth
and adjusting the output min and max ranges accordingly.

[input_min, input_max] are scalar floats that specify the range for the float
interpretation of the 'input' data. For example, if input_min is -1.0f and
input_max is 1.0f, and we are dealing with quint16 quantized data, then a 0
value in the 16-bit data should be interpreted as -1.0f, and a 65535 means 1.0f.

This operator tries to squeeze as much precision as possible into an output with
a lower bit depth by calculating the actual min and max values found in the
data. For example, maybe that quint16 input has no values lower than 16,384 and
none higher than 49,152. That means only half the range is actually needed, all
the float interpretations are between -0.5f and 0.5f, so if we want to compress
the data into a quint8 output, we can use that range rather than the theoretical
-1.0f to 1.0f that is suggested by the input min and max.

In practice, this is most useful for taking output from operations like
QuantizedMatMul that can produce higher bit-depth outputs than their inputs and
may have large potential output ranges, but in practice have a distribution of
input values that only uses a small fraction of the possible range. By feeding
that output into this operator, we can reduce it from 32 bits down to 8 with
minimal loss of accuracy.
"""
function quantize_down_and_shrink_range(v4252, v4253, v4254; name=nothing, Tinput=nothing, out_type=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("QuantizeDownAndShrinkRange") 
                begin  
                    begin  
                        if v4252 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4252)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4252)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4253 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4253)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4253)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4254 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4254)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4254)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if Tinput !== nothing 
                            desc["Tinput"] = Tinput
                        end
                    end
                    begin  
                        if out_type !== nothing 
                            desc["out_type"] = out_type
                        end
                    end
                end
            end), name, "QuantizeDownAndShrinkRange") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2), tf.Tensor(op, 3))
    end
end

"""
     tensor_array_grad_v2(handle, flow_in)

Deprecated. Use TensorArrayGradV3


"""
function tensor_array_grad_v2(v4255, v4256; name=nothing, source=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("TensorArrayGradV2") 
                begin  
                    begin  
                        if v4255 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4255)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4255)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4256 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4256)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4256)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if source !== nothing 
                            desc["source"] = source
                        end
                    end
                end
            end), name, "TensorArrayGradV2") 
    tf.Tensor(tf.Operation(desc))
end

"""
     whole_file_reader_v2(; container=, shared_name=)

A Reader that outputs the entire contents of a file as a value.

To use, enqueue filenames in a Queue.  The output of ReaderRead will
be a filename (key) and the contents of that file (value).
"""
function whole_file_reader_v2(; name=nothing, container=nothing, shared_name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("WholeFileReaderV2") 
                begin  
                end 
                begin  
                    begin  
                        if container !== nothing 
                            desc["container"] = container
                        end
                    end
                    begin  
                        if shared_name !== nothing 
                            desc["shared_name"] = shared_name
                        end
                    end
                end
            end), name, "WholeFileReaderV2") 
    tf.Tensor(tf.Operation(desc))
end

"""
     batch_fft_2d(input)




"""
function batch_fft_2d(v4257; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("BatchFFT2D") 
                begin  
                    begin  
                        if v4257 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4257)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4257)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "BatchFFT2D") 
    tf.Tensor(tf.Operation(desc))
end

"""
     rank(input)

Returns the rank of a tensor.

This operation returns an integer representing the rank of `input`.

For example:

```prettyprint
# 't' is [[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]
# shape of tensor 't' is [2, 2, 3]
rank(t) ==> 3
```

**Note**: The rank of a tensor is not the same as the rank of a matrix. The rank
of a tensor is the number of indices required to uniquely select each element
of the tensor. Rank is also known as "order", "degree", or "ndims."
"""
function rank(v4258; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Rank") 
                begin  
                    begin  
                        if v4258 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4258)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4258)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Rank") 
    tf.Tensor(tf.Operation(desc))
end

"""
     abort(; error_msg=, exit_without_error=false)

Raise a exception to abort the process when called. If exit_without_error is true, the process will exit normally, otherwise it will exit with a SIGABORT signal.

Returns nothing but an exception.
"""
function abort(; name=nothing, error_msg=nothing, exit_without_error=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Abort") 
                begin  
                end 
                begin  
                    begin  
                        if error_msg !== nothing 
                            desc["error_msg"] = error_msg
                        end
                    end
                    begin  
                        if exit_without_error !== nothing 
                            desc["exit_without_error"] = exit_without_error
                        end
                    end
                end
            end), name, "Abort") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     fft_3d(input)

Compute the 3-dimensional discrete Fourier Transform over the inner-most 3

dimensions of `input`.
"""
function fft_3d(v4259; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("FFT3D") 
                begin  
                    begin  
                        if v4259 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4259)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4259)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "FFT3D") 
    tf.Tensor(tf.Operation(desc))
end

"""
     apply_ftrl(var, accum, linear, grad, lr, l1, l2, lr_power; use_locking=false)

Update '*var' according to the Ftrl-proximal scheme.

accum_new = accum + grad * grad
linear += grad + (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var
quadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2
var = (sign(linear) * l1 - linear) / quadratic if |linear| > l1 else 0.0
accum = accum_new
"""
function apply_ftrl(v4260, v4261, v4262, v4263, v4264, v4265, v4266, v4267; name=nothing, T=nothing, use_locking=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ApplyFtrl") 
                begin  
                    begin  
                        if v4260 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4260)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4260)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4261 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4261)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4261)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4262 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4262)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4262)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4263 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4263)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4263)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4264 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4264)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4264)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4265 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4265)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4265)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4266 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4266)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4266)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4267 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4267)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4267)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if use_locking !== nothing 
                            desc["use_locking"] = use_locking
                        end
                    end
                end
            end), name, "ApplyFtrl") 
    tf.Tensor(tf.Operation(desc))
end

"""
     assign_sub_variable_op(resource, value)

Subtracts a value from the current value of a variable.

Any ReadVariableOp which depends directly or indirectly on this assign is
guaranteed to see the incremented value or a subsequent newer one.

Outputs the incremented value, which can be used to totally order the
increments to this variable.
"""
function assign_sub_variable_op(v4268, v4269; name=nothing, dtype=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("AssignSubVariableOp") 
                begin  
                    begin  
                        if v4268 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4268)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4268)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4269 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4269)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4269)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if dtype !== nothing 
                            desc["dtype"] = dtype
                        end
                    end
                end
            end), name, "AssignSubVariableOp") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     next_iteration(data)

Makes its input available to the next iteration.


"""
function next_iteration(v4270; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("NextIteration") 
                begin  
                    begin  
                        if v4270 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4270)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4270)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "NextIteration") 
    tf.Tensor(tf.Operation(desc))
end

"""
     ref_exit(data)

Exits the current frame to its parent frame.

Exit makes its input `data` available to the parent frame.
"""
function ref_exit(v4271; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("RefExit") 
                begin  
                    begin  
                        if v4271 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4271)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4271)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "RefExit") 
    tf.Tensor(tf.Operation(desc))
end

"""
     sqrt(x)

Computes square root of x element-wise.

I.e., \\(y = \sqrt{x} = x^{1/2}\\).
"""
function sqrt(v4272; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Sqrt") 
                begin  
                    begin  
                        if v4272 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4272)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4272)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Sqrt") 
    tf.Tensor(tf.Operation(desc))
end

"""
     accumulator_take_gradient(handle, num_required)

Extracts the average gradient in the given ConditionalAccumulator, provided

that sufficient (i.e., more than num_required) gradients have been accumulated.
The op blocks until sufficient gradients have been accumulated.
If the accumulator has already aggregated more than num_required gradients, it
returns the average of the accumulated gradients.
Also automatically increments the recorded global_step in the accumulator by 1,
and resets the aggregate to 0.
"""
function accumulator_take_gradient(v4273, v4274; name=nothing, dtype=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("AccumulatorTakeGradient") 
                begin  
                    begin  
                        if v4273 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4273)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4273)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4274 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4274)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4274)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if dtype !== nothing 
                            desc["dtype"] = dtype
                        end
                    end
                end
            end), name, "AccumulatorTakeGradient") 
    tf.Tensor(tf.Operation(desc))
end

"""
     reciprocal(x)

Computes the reciprocal of x element-wise.

I.e., \\(y = 1 / x\\).
"""
function reciprocal(v4275; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Reciprocal") 
                begin  
                    begin  
                        if v4275 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4275)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4275)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Reciprocal") 
    tf.Tensor(tf.Operation(desc))
end

"""
     sparse_conditional_accumulator(; container=, shared_name=)

A conditional accumulator for aggregating sparse gradients. The accumulator

accepts gradients marked with local_step greater or equal to the most recent
global_step known to the accumulator. The average can be extracted from the
accumulator, provided sufficient gradients have been accumulated. Extracting the
average automatically resets the aggregate to 0, and increments the global_step
recorded by the accumulator.
"""
function sparse_conditional_accumulator(; name=nothing, dtype=nothing, shape=nothing, container=nothing, shared_name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SparseConditionalAccumulator") 
                begin  
                end 
                begin  
                    begin  
                        if dtype !== nothing 
                            desc["dtype"] = dtype
                        end
                    end
                    begin  
                        if shape !== nothing 
                            desc["shape"] = shape
                        end
                    end
                    begin  
                        if container !== nothing 
                            desc["container"] = container
                        end
                    end
                    begin  
                        if shared_name !== nothing 
                            desc["shared_name"] = shared_name
                        end
                    end
                end
            end), name, "SparseConditionalAccumulator") 
    tf.Tensor(tf.Operation(desc))
end

"""
     segment_min(data, segment_ids)

Computes the minimum along segments of a tensor.

Read [the section on
Segmentation](../../api_docs/python/math_ops.md#segmentation) for an explanation
of segments.

Computes a tensor such that
\\(output_i = \min_j(data_j)\\) where `min` is over `j` such
that `segment_ids[j] == i`.

If the min is empty for a given segment ID `i`, `output[i] = 0`.

<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="../../images/SegmentMin.png" alt>
</div>
"""
function segment_min(v4276, v4277; name=nothing, T=nothing, Tindices=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SegmentMin") 
                begin  
                    begin  
                        if v4276 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4276)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4276)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4277 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4277)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4277)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tindices !== nothing 
                            desc["Tindices"] = Tindices
                        end
                    end
                end
            end), name, "SegmentMin") 
    tf.Tensor(tf.Operation(desc))
end

"""
     fifoq_v2(; shapes=Int64[], capacity=-1, container=, shared_name=)

A queue that produces elements in first-in first-out order.


"""
function fifoq_v2(; name=nothing, component_types=nothing, shapes=nothing, capacity=nothing, container=nothing, shared_name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("FIFOQueueV2") 
                begin  
                end 
                begin  
                    begin  
                        if component_types !== nothing 
                            desc["component_types"] = component_types
                        end
                    end
                    begin  
                        if shapes !== nothing 
                            desc["shapes"] = shapes
                        end
                    end
                    begin  
                        if capacity !== nothing 
                            desc["capacity"] = capacity
                        end
                    end
                    begin  
                        if container !== nothing 
                            desc["container"] = container
                        end
                    end
                    begin  
                        if shared_name !== nothing 
                            desc["shared_name"] = shared_name
                        end
                    end
                end
            end), name, "FIFOQueueV2") 
    tf.Tensor(tf.Operation(desc))
end

"""
     fake_quant_with_min_max_vars_per_channel(inputs, min, max)

Fake-quantize the 'inputs' tensor of type float and one of the shapes: `[d]`,

`[b, d]` `[b, h, w, d]` via per-channel floats `min` and `max` of shape `[d]`
to 'outputs' tensor of same shape as `inputs`.

[min; max] is the clamping range for the 'inputs' data in the corresponding
depth channel.  Op divides this range into 255 steps (total of 256 values), then
replaces each 'inputs' value with the closest of the quantized step values.

This operation has a gradient and thus allows for training `min` and `max` values.
"""
function fake_quant_with_min_max_vars_per_channel(v4278, v4279, v4280; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("FakeQuantWithMinMaxVarsPerChannel") 
                begin  
                    begin  
                        if v4278 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4278)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4278)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4279 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4279)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4279)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4280 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4280)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4280)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "FakeQuantWithMinMaxVarsPerChannel") 
    tf.Tensor(tf.Operation(desc))
end

"""
     barrier_ready_size(handle)

Computes the number of complete elements in the given barrier.


"""
function barrier_ready_size(v4281; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("BarrierReadySize") 
                begin  
                    begin  
                        if v4281 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4281)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4281)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "BarrierReadySize") 
    tf.Tensor(tf.Operation(desc))
end

"""
     variable(; container=, shared_name=)

Use VariableV2 instead.


"""
function variable(; name=nothing, shape=nothing, dtype=nothing, container=nothing, shared_name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Variable") 
                begin  
                end 
                begin  
                    begin  
                        if shape !== nothing 
                            desc["shape"] = shape
                        end
                    end
                    begin  
                        if dtype !== nothing 
                            desc["dtype"] = dtype
                        end
                    end
                    begin  
                        if container !== nothing 
                            desc["container"] = container
                        end
                    end
                    begin  
                        if shared_name !== nothing 
                            desc["shared_name"] = shared_name
                        end
                    end
                end
            end), name, "Variable") 
    tf.Tensor(tf.Operation(desc))
end

"""
     cholesky_grad(l, grad)

Computes the reverse mode backpropagated gradient of the Cholesky algorithm.

For an explanation see "Differentiation of the Cholesky algorithm" by
Iain Murray http://arxiv.org/abs/1602.07527.
"""
function cholesky_grad(v4282, v4283; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("CholeskyGrad") 
                begin  
                    begin  
                        if v4282 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4282)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4282)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4283 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4283)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4283)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "CholeskyGrad") 
    tf.Tensor(tf.Operation(desc))
end

"""
     log_uniform_candidate_sampler(true_classes; seed=0, seed2=0)

Generates labels for candidate sampling with a log-uniform distribution.

See explanations of candidate sampling and the data formats at
go/candidate-sampling.

For each batch, this op picks a single set of sampled candidate labels.

The advantages of sampling candidates per-batch are simplicity and the
possibility of efficient dense matrix multiplication. The disadvantage is that
the sampled candidates must be chosen independently of the context and of the
true labels.
"""
function log_uniform_candidate_sampler(v4284; name=nothing, num_true=nothing, num_sampled=nothing, unique=nothing, range_max=nothing, seed=nothing, seed2=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("LogUniformCandidateSampler") 
                begin  
                    begin  
                        if v4284 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4284)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4284)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if num_true !== nothing 
                            desc["num_true"] = num_true
                        end
                    end
                    begin  
                        if num_sampled !== nothing 
                            desc["num_sampled"] = num_sampled
                        end
                    end
                    begin  
                        if unique !== nothing 
                            desc["unique"] = unique
                        end
                    end
                    begin  
                        if range_max !== nothing 
                            desc["range_max"] = range_max
                        end
                    end
                    begin  
                        if seed !== nothing 
                            desc["seed"] = seed
                        end
                    end
                    begin  
                        if seed2 !== nothing 
                            desc["seed2"] = seed2
                        end
                    end
                end
            end), name, "LogUniformCandidateSampler") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2), tf.Tensor(op, 3))
    end
end

"""
     string_to_hash_bucket(string_tensor)

Converts each string in the input Tensor to its hash mod by a number of buckets.

The hash function is deterministic on the content of the string within the
process.

Note that the hash function may change from time to time.
This functionality will be deprecated and it's recommended to use
`tf.string_to_hash_bucket_fast()` or `tf.string_to_hash_bucket_strong()`.
"""
function string_to_hash_bucket(v4285; name=nothing, num_buckets=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("StringToHashBucket") 
                begin  
                    begin  
                        if v4285 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4285)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4285)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if num_buckets !== nothing 
                            desc["num_buckets"] = num_buckets
                        end
                    end
                end
            end), name, "StringToHashBucket") 
    tf.Tensor(tf.Operation(desc))
end

"""
     max_pool_grad_with_argmax(input, grad, argmax; T=Float32)

Computes gradients of the maxpooling function.


"""
function max_pool_grad_with_argmax(v4286, v4287, v4288; name=nothing, ksize=nothing, strides=nothing, padding=nothing, Targmax=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("MaxPoolGradWithArgmax") 
                begin  
                    begin  
                        if v4286 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4286)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4286)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4287 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4287)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4287)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4288 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4288)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4288)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if ksize !== nothing 
                            desc["ksize"] = ksize
                        end
                    end
                    begin  
                        if strides !== nothing 
                            desc["strides"] = strides
                        end
                    end
                    begin  
                        if padding !== nothing 
                            desc["padding"] = padding
                        end
                    end
                    begin  
                        if Targmax !== nothing 
                            desc["Targmax"] = Targmax
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "MaxPoolGradWithArgmax") 
    tf.Tensor(tf.Operation(desc))
end

"""
     tensor_array_concat(handle, flow_in; element_shape_except0=TensorShape[unknown])




"""
function tensor_array_concat(v4289, v4290; name=nothing, dtype=nothing, element_shape_except0=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("TensorArrayConcat") 
                begin  
                    begin  
                        if v4289 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4289)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4289)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4290 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4290)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4290)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if dtype !== nothing 
                            desc["dtype"] = dtype
                        end
                    end
                    begin  
                        if element_shape_except0 !== nothing 
                            desc["element_shape_except0"] = element_shape_except0
                        end
                    end
                end
            end), name, "TensorArrayConcat") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2))
    end
end

"""
     serialize_sparse(sparse_indices, sparse_values, sparse_shape)

Serialize a `SparseTensor` into a string 3-vector (1-D `Tensor`) object.


"""
function serialize_sparse(v4291, v4292, v4293; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SerializeSparse") 
                begin  
                    begin  
                        if v4291 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4291)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4291)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4292 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4292)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4292)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4293 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4293)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4293)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "SerializeSparse") 
    tf.Tensor(tf.Operation(desc))
end

"""
     matrix_band_part(input, num_lower, num_upper)

Copy a tensor setting everything outside a central band in each innermost matrix

to zero.

The `band` part is computed as follows:
Assume `input` has `k` dimensions `[I, J, K, ..., M, N]`, then the output is a
tensor with the same shape where

`band[i, j, k, ..., m, n] = in_band(m, n) * input[i, j, k, ..., m, n]`.

The indicator function

`in_band(m, n) = (num_lower < 0 || (m-n) <= num_lower)) &&
                 (num_upper < 0 || (n-m) <= num_upper)`.

For example:

```prettyprint
# if 'input' is [[ 0,  1,  2, 3]
                 [-1,  0,  1, 2]
                 [-2, -1,  0, 1]
                 [-3, -2, -1, 0]],

tf.matrix_band_part(input, 1, -1) ==> [[ 0,  1,  2, 3]
                                       [-1,  0,  1, 2]
                                       [ 0, -1,  0, 1]
                                       [ 0,  0, -1, 0]],

tf.matrix_band_part(input, 2, 1) ==> [[ 0,  1,  0, 0]
                                      [-1,  0,  1, 0]
                                      [-2, -1,  0, 1]
                                      [ 0, -2, -1, 0]]
```

Useful special cases:

```prettyprint
 tf.matrix_band_part(input, 0, -1) ==> Upper triangular part.
 tf.matrix_band_part(input, -1, 0) ==> Lower triangular part.
 tf.matrix_band_part(input, 0, 0) ==> Diagonal.
```
"""
function matrix_band_part(v4294, v4295, v4296; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("MatrixBandPart") 
                begin  
                    begin  
                        if v4294 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4294)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4294)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4295 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4295)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4295)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4296 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4296)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4296)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "MatrixBandPart") 
    tf.Tensor(tf.Operation(desc))
end

"""
     sharded_filename(basename, shard, num_shards)

Generate a sharded filename. The filename is printf formatted as

   %s-%05d-of-%05d, basename, shard, num_shards.
"""
function sharded_filename(v4297, v4298, v4299; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ShardedFilename") 
                begin  
                    begin  
                        if v4297 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4297)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4297)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4298 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4298)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4298)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4299 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4299)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4299)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "ShardedFilename") 
    tf.Tensor(tf.Operation(desc))
end

"""
     queue_dequeue_up_to(handle, n; timeout_ms=-1)

Dequeues n tuples of one or more tensors from the given queue.

This operation is not supported by all queues.  If a queue does not support
DequeueUpTo, then an Unimplemented error is returned.

If the queue is closed and there are more than 0 but less than n elements
remaining, then instead of returning an OutOfRange error like
QueueDequeueMany, less than `n` elements are returned immediately.  If the queue
is closed and there are 0 elements left in the queue, then an OutOfRange
error is returned just like in QueueDequeueMany.  Otherwise the behavior
is identical to QueueDequeueMany:

This operation concatenates queue-element component tensors along the
0th dimension to make a single component tensor.  All of the components
in the dequeued tuple will have size n in the 0th dimension.

This operation has k outputs, where k is the number of components in
the tuples stored in the given queue, and output i is the ith
component of the dequeued tuple.
"""
function queue_dequeue_up_to(v4300, v4301; name=nothing, component_types=nothing, timeout_ms=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("QueueDequeueUpTo") 
                begin  
                    begin  
                        if v4300 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4300)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4300)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4301 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4301)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4301)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if component_types !== nothing 
                            desc["component_types"] = component_types
                        end
                    end
                    begin  
                        if timeout_ms !== nothing 
                            desc["timeout_ms"] = timeout_ms
                        end
                    end
                end
            end), name, "QueueDequeueUpTo") 
    tf.Tensor(tf.Operation(desc))
end

"""
     shape_n(input; out_type=Int32)

Returns shape of tensors.

This operation returns N 1-D integer tensors representing shape of `input[i]s`.
"""
function shape_n(v4302; name=nothing, N=nothing, T=nothing, out_type=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ShapeN") 
                begin  
                    begin  
                        if v4302 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4302)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4302)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if N !== nothing 
                            desc["N"] = N
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if out_type !== nothing 
                            desc["out_type"] = out_type
                        end
                    end
                end
            end), name, "ShapeN") 
    tf.Tensor(tf.Operation(desc))
end

"""
     ref_switch(data, pred)

Forwards the ref tensor `data` to the output port determined by `pred`.

If `pred` is true, the `data` input is forwarded to `output_true`. Otherwise,
the data goes to `output_false`.

See also `Switch` and `Merge`.
"""
function ref_switch(v4303, v4304; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("RefSwitch") 
                begin  
                    begin  
                        if v4303 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4303)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4303)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4304 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4304)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4304)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "RefSwitch") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2))
    end
end

"""
     ref_merge(inputs)

Forwards the value of an available tensor from `inputs` to `output`.

`Merge` waits for at least one of the tensors in `inputs` to become available.
It is usually combined with `Switch` to implement branching.

`Merge` forwards the first tensor for become available to `output`, and sets
`value_index` to its index in `inputs`.
"""
function ref_merge(v4305; name=nothing, T=nothing, N=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("RefMerge") 
                begin  
                    begin  
                        if v4305 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4305)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4305)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if N !== nothing 
                            desc["N"] = N
                        end
                    end
                end
            end), name, "RefMerge") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2))
    end
end

"""
     concat(concat_dim, values)

Concatenates tensors along one dimension.


"""
function concat(v4306, v4307; name=nothing, N=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Concat") 
                begin  
                    begin  
                        if v4306 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4306)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4306)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4307 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4307)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4307)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if N !== nothing 
                            desc["N"] = N
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Concat") 
    tf.Tensor(tf.Operation(desc))
end

"""
     sdca_fprint(input)

Computes fingerprints of the input strings.


"""
function sdca_fprint(v4308; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SdcaFprint") 
                begin  
                    begin  
                        if v4308 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4308)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4308)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "SdcaFprint") 
    tf.Tensor(tf.Operation(desc))
end

"""
     count_up_to(ref)

Increments 'ref' until it reaches 'limit'.


"""
function count_up_to(v4309; name=nothing, limit=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("CountUpTo") 
                begin  
                    begin  
                        if v4309 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4309)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4309)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if limit !== nothing 
                            desc["limit"] = limit
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "CountUpTo") 
    tf.Tensor(tf.Operation(desc))
end

"""
     random_gamma(shape, alpha; seed=0, seed2=0)

Outputs random values from the Gamma distribution(s) described by alpha.

This op uses the algorithm by Marsaglia et al. to acquire samples via
transformation-rejection from pairs of uniform and normal random variables.
See http://dl.acm.org/citation.cfm?id=358414
"""
function random_gamma(v4310, v4311; name=nothing, seed=nothing, seed2=nothing, S=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("RandomGamma") 
                begin  
                    begin  
                        if v4310 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4310)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4310)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4311 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4311)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4311)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if seed !== nothing 
                            desc["seed"] = seed
                        end
                    end
                    begin  
                        if seed2 !== nothing 
                            desc["seed2"] = seed2
                        end
                    end
                    begin  
                        if S !== nothing 
                            desc["S"] = S
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "RandomGamma") 
    tf.Tensor(tf.Operation(desc))
end

"""
     sparse_apply_adadelta(var, accum, accum_update, lr, rho, epsilon, grad, indices; use_locking=false)

var: Should be from a Variable().


"""
function sparse_apply_adadelta(v4312, v4313, v4314, v4315, v4316, v4317, v4318, v4319; name=nothing, T=nothing, Tindices=nothing, use_locking=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SparseApplyAdadelta") 
                begin  
                    begin  
                        if v4312 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4312)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4312)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4313 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4313)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4313)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4314 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4314)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4314)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4315 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4315)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4315)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4316 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4316)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4316)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4317 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4317)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4317)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4318 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4318)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4318)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4319 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4319)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4319)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tindices !== nothing 
                            desc["Tindices"] = Tindices
                        end
                    end
                    begin  
                        if use_locking !== nothing 
                            desc["use_locking"] = use_locking
                        end
                    end
                end
            end), name, "SparseApplyAdadelta") 
    tf.Tensor(tf.Operation(desc))
end

"""
     tensor_array_close(handle)




"""
function tensor_array_close(v4320; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("TensorArrayClose") 
                begin  
                    begin  
                        if v4320 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4320)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4320)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "TensorArrayClose") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     dilation_2d(input, filter)

Computes the grayscale dilation of 4-D `input` and 3-D `filter` tensors.

The `input` tensor has shape `[batch, in_height, in_width, depth]` and the
`filter` tensor has shape `[filter_height, filter_width, depth]`, i.e., each
input channel is processed independently of the others with its own structuring
function. The `output` tensor has shape
`[batch, out_height, out_width, depth]`. The spatial dimensions of the output
tensor depend on the `padding` algorithm. We currently only support the default
"NHWC" `data_format`.

In detail, the grayscale morphological 2-D dilation is the max-sum correlation
(for consistency with `conv2d`, we use unmirrored filters):

    output[b, y, x, c] =
       max_{dy, dx} input[b,
                          strides[1] * y + rates[1] * dy,
                          strides[2] * x + rates[2] * dx,
                          c] +
                    filter[dy, dx, c]

Max-pooling is a special case when the filter has size equal to the pooling
kernel size and contains all zeros.

Note on duality: The dilation of `input` by the `filter` is equal to the
negation of the erosion of `-input` by the reflected `filter`.
"""
function dilation_2d(v4321, v4322; name=nothing, T=nothing, strides=nothing, rates=nothing, padding=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Dilation2D") 
                begin  
                    begin  
                        if v4321 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4321)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4321)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4322 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4322)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4322)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if strides !== nothing 
                            desc["strides"] = strides
                        end
                    end
                    begin  
                        if rates !== nothing 
                            desc["rates"] = rates
                        end
                    end
                    begin  
                        if padding !== nothing 
                            desc["padding"] = padding
                        end
                    end
                end
            end), name, "Dilation2D") 
    tf.Tensor(tf.Operation(desc))
end

"""
     get_session_handle(value)




"""
function get_session_handle(v4323; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("GetSessionHandle") 
                begin  
                    begin  
                        if v4323 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4323)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4323)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "GetSessionHandle") 
    tf.Tensor(tf.Operation(desc))
end

"""
     softplus(features)

Computes softplus: `log(exp(features) + 1)`.


"""
function softplus(v4324; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Softplus") 
                begin  
                    begin  
                        if v4324 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4324)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4324)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Softplus") 
    tf.Tensor(tf.Operation(desc))
end

"""
     identity_reader(; container=, shared_name=)

A Reader that outputs the queued work as both the key and value.

To use, enqueue strings in a Queue.  ReaderRead will take the front
work string and output (work, work).
"""
function identity_reader(; name=nothing, container=nothing, shared_name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("IdentityReader") 
                begin  
                end 
                begin  
                    begin  
                        if container !== nothing 
                            desc["container"] = container
                        end
                    end
                    begin  
                        if shared_name !== nothing 
                            desc["shared_name"] = shared_name
                        end
                    end
                end
            end), name, "IdentityReader") 
    tf.Tensor(tf.Operation(desc))
end

"""
     crop_and_resize_grad_image(grads, boxes, box_ind, image_size; method=bilinear)

Computes the gradient of the crop_and_resize op wrt the input image tensor.


"""
function crop_and_resize_grad_image(v4325, v4326, v4327, v4328; name=nothing, T=nothing, method=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("CropAndResizeGradImage") 
                begin  
                    begin  
                        if v4325 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4325)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4325)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4326 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4326)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4326)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4327 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4327)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4327)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4328 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4328)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4328)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if method !== nothing 
                            desc["method"] = method
                        end
                    end
                end
            end), name, "CropAndResizeGradImage") 
    tf.Tensor(tf.Operation(desc))
end

"""
     tensor_array_grad(handle, flow_in)




"""
function tensor_array_grad(v4329, v4330; name=nothing, source=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("TensorArrayGrad") 
                begin  
                    begin  
                        if v4329 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4329)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4329)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4330 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4330)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4330)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if source !== nothing 
                            desc["source"] = source
                        end
                    end
                end
            end), name, "TensorArrayGrad") 
    tf.Tensor(tf.Operation(desc))
end

"""
     rfft(input, fft_length)

Compute the 1-dimensional discrete Fourier Transform of a real-valued signal

over the inner-most dimension of `input`.

Since the DFT of a real signal is Hermitian-symmetric, `RFFT` only returns the
`fft_length / 2 + 1` unique components of the FFT: the zero-frequency term,
followed by the `fft_length / 2` positive-frequency terms.
"""
function rfft(v4331, v4332; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("RFFT") 
                begin  
                    begin  
                        if v4331 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4331)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4331)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4332 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4332)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4332)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "RFFT") 
    tf.Tensor(tf.Operation(desc))
end

"""
     sparse_apply_ftrl(var, accum, linear, grad, indices, lr, l1, l2, lr_power; use_locking=false)

Update relevant entries in '*var' according to the Ftrl-proximal scheme.

That is for rows we have grad for, we update var, accum and linear as follows:
accum_new = accum + grad * grad
linear += grad + (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var
quadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2
var = (sign(linear) * l1 - linear) / quadratic if |linear| > l1 else 0.0
accum = accum_new
"""
function sparse_apply_ftrl(v4333, v4334, v4335, v4336, v4337, v4338, v4339, v4340, v4341; name=nothing, T=nothing, Tindices=nothing, use_locking=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SparseApplyFtrl") 
                begin  
                    begin  
                        if v4333 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4333)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4333)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4334 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4334)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4334)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4335 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4335)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4335)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4336 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4336)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4336)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4337 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4337)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4337)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4338 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4338)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4338)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4339 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4339)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4339)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4340 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4340)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4340)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4341 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4341)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4341)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tindices !== nothing 
                            desc["Tindices"] = Tindices
                        end
                    end
                    begin  
                        if use_locking !== nothing 
                            desc["use_locking"] = use_locking
                        end
                    end
                end
            end), name, "SparseApplyFtrl") 
    tf.Tensor(tf.Operation(desc))
end

"""
     matrix_determinant(input)

Computes the determinant of one ore more square matrices.

The input is a tensor of shape `[..., M, M]` whose inner-most 2 dimensions
form square matrices. The output is a tensor containing the determinants
for all input submatrices `[..., :, :]`.
"""
function matrix_determinant(v4342; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("MatrixDeterminant") 
                begin  
                    begin  
                        if v4342 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4342)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4342)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "MatrixDeterminant") 
    tf.Tensor(tf.Operation(desc))
end

"""
     avg_pool(value; data_format=NHWC)

Performs average pooling on the input.

Each entry in `output` is the mean of the corresponding size `ksize`
window in `value`.
"""
function avg_pool(v4343; name=nothing, ksize=nothing, strides=nothing, padding=nothing, data_format=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("AvgPool") 
                begin  
                    begin  
                        if v4343 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4343)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4343)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if ksize !== nothing 
                            desc["ksize"] = ksize
                        end
                    end
                    begin  
                        if strides !== nothing 
                            desc["strides"] = strides
                        end
                    end
                    begin  
                        if padding !== nothing 
                            desc["padding"] = padding
                        end
                    end
                    begin  
                        if data_format !== nothing 
                            desc["data_format"] = data_format
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "AvgPool") 
    tf.Tensor(tf.Operation(desc))
end

"""
     resource_sparse_apply_proximal_adagrad(var, accum, lr, l1, l2, grad, indices; use_locking=false)

Sparse update entries in '*var' and '*accum' according to FOBOS algorithm.

That is for rows we have grad for, we update var and accum as follows:
accum += grad * grad
prox_v = var
prox_v -= lr * grad * (1 / sqrt(accum))
var = sign(prox_v)/(1+lr*l2) * max{|prox_v|-lr*l1,0}
"""
function resource_sparse_apply_proximal_adagrad(v4344, v4345, v4346, v4347, v4348, v4349, v4350; name=nothing, T=nothing, Tindices=nothing, use_locking=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ResourceSparseApplyProximalAdagrad") 
                begin  
                    begin  
                        if v4344 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4344)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4344)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4345 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4345)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4345)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4346 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4346)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4346)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4347 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4347)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4347)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4348 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4348)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4348)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4349 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4349)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4349)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4350 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4350)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4350)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tindices !== nothing 
                            desc["Tindices"] = Tindices
                        end
                    end
                    begin  
                        if use_locking !== nothing 
                            desc["use_locking"] = use_locking
                        end
                    end
                end
            end), name, "ResourceSparseApplyProximalAdagrad") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     sparse_dense_cwise_add(sp_indices, sp_values, sp_shape, dense)

Adds up a SparseTensor and a dense Tensor, using these special rules:

(1) Broadcasts the dense side to have the same shape as the sparse side, if
    eligible;
(2) Then, only the dense values pointed to by the indices of the SparseTensor
    participate in the cwise addition.

By these rules, the result is a logical SparseTensor with exactly the same
indices and shape, but possibly with different non-zero values.  The output of
this Op is the resultant non-zero values.
"""
function sparse_dense_cwise_add(v4351, v4352, v4353, v4354; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SparseDenseCwiseAdd") 
                begin  
                    begin  
                        if v4351 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4351)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4351)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4352 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4352)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4352)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4353 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4353)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4353)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4354 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4354)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4354)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "SparseDenseCwiseAdd") 
    tf.Tensor(tf.Operation(desc))
end

"""
     bias_add_v1(value, bias)

Adds `bias` to `value`.

This is a deprecated version of BiasAdd and will be soon removed.

This is a special case of `tf.add` where `bias` is restricted to be 1-D.
Broadcasting is supported, so `value` may have any number of dimensions.
"""
function bias_add_v1(v4355, v4356; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("BiasAddV1") 
                begin  
                    begin  
                        if v4355 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4355)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4355)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4356 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4356)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4356)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "BiasAddV1") 
    tf.Tensor(tf.Operation(desc))
end

"""
     invert_permutation(x; T=Int32)

Computes the inverse permutation of a tensor.

This operation computes the inverse of an index permutation. It takes a 1-D
integer tensor `x`, which represents the indices of a zero-based array, and
swaps each value with its index position. In other words, for an output tensor
`y` and an input tensor `x`, this operation computes the following:

`y[x[i]] = i for i in [0, 1, ..., len(x) - 1]`

The values must include 0. There can be no duplicate values or negative values.

For example:

```prettyprint
# tensor `x` is [3, 4, 0, 2, 1]
invert_permutation(x) ==> [2, 4, 3, 0, 1]
```
"""
function invert_permutation(v4357; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("InvertPermutation") 
                begin  
                    begin  
                        if v4357 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4357)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4357)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "InvertPermutation") 
    tf.Tensor(tf.Operation(desc))
end

"""
     requantization_range(input, input_min, input_max)

Given a quantized tensor described by (input, input_min, input_max), outputs a

range that covers the actual values present in that tensor.  This op is
typically used to produce the requested_output_min and requested_output_max for
Requantize.
"""
function requantization_range(v4358, v4359, v4360; name=nothing, Tinput=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("RequantizationRange") 
                begin  
                    begin  
                        if v4358 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4358)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4358)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4359 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4359)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4359)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4360 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4360)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4360)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if Tinput !== nothing 
                            desc["Tinput"] = Tinput
                        end
                    end
                end
            end), name, "RequantizationRange") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2))
    end
end

"""
     maximum(x, y)

Returns the max of x and y (i.e. x > y ? x : y) element-wise.

*NOTE*: `Maximum` supports broadcasting. More about broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
"""
function maximum(v4361, v4362; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Maximum") 
                begin  
                    begin  
                        if v4361 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4361)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4361)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4362 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4362)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4362)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Maximum") 
    tf.Tensor(tf.Operation(desc))
end

"""
     matrix_solve_ls(matrix, rhs, l2_regularizer; fast=true)

Solves one or more linear least-squares problems.

`matrix` is a tensor of shape `[..., M, N]` whose inner-most 2 dimensions
form matrices of size `[M, N]`. Rhs is a tensor of shape `[..., M, K]`.
The output is a tensor shape `[..., N, K]` where each output matrix solves
each of the equations matrix[..., :, :] * output[..., :, :] = rhs[..., :, :]
in the least squares sense.

matrix and right-hand sides in the batch:

`matrix`=\\(A \in \Re^{m \times n}\\),
`rhs`=\\(B  \in \Re^{m \times k}\\),
`output`=\\(X  \in \Re^{n \times k}\\),
`l2_regularizer`=\\(\lambda\\).

If `fast` is `True`, then the solution is computed by solving the normal
equations using Cholesky decomposition. Specifically, if \\(m \ge n\\) then
\\(X = (A^T A + \lambda I)^{-1} A^T B\\), which solves the least-squares
problem \\(X = \mathrm{argmin}_{Z \in \Re^{n \times k} } ||A Z - B||_F^2 +
\lambda ||Z||_F^2\\). If \\(m \lt n\\) then `output` is computed as
\\(X = A^T (A A^T + \lambda I)^{-1} B\\), which (for \\(\lambda = 0\\)) is the
minimum-norm solution to the under-determined linear system, i.e.
\\(X = \mathrm{argmin}_{Z \in \Re^{n \times k} } ||Z||_F^2 \\), subject to
\\(A Z = B\\). Notice that the fast path is only numerically stable when
\\(A\\) is numerically full rank and has a condition number
\\(\mathrm{cond}(A) \lt \frac{1}{\sqrt{\epsilon_{mach} } }\\) or\\(\lambda\\) is
sufficiently large.

If `fast` is `False` an algorithm based on the numerically robust complete
orthogonal decomposition is used. This computes the minimum-norm
least-squares solution, even when \\(A\\) is rank deficient. This path is
typically 6-7 times slower than the fast path. If `fast` is `False` then
`l2_regularizer` is ignored.
"""
function matrix_solve_ls(v4363, v4364, v4365; name=nothing, T=nothing, fast=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("MatrixSolveLs") 
                begin  
                    begin  
                        if v4363 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4363)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4363)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4364 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4364)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4364)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4365 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4365)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4365)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if fast !== nothing 
                            desc["fast"] = fast
                        end
                    end
                end
            end), name, "MatrixSolveLs") 
    tf.Tensor(tf.Operation(desc))
end

"""
     reshape(tensor, shape; Tshape=Int32)

Reshapes a tensor.

Given `tensor`, this operation returns a tensor that has the same values
as `tensor` with shape `shape`.

If one component of `shape` is the special value -1, the size of that dimension
is computed so that the total size remains constant.  In particular, a `shape`
of `[-1]` flattens into 1-D.  At most one component of `shape` can be -1.

If `shape` is 1-D or higher, then the operation returns a tensor with shape
`shape` filled with the values of `tensor`. In this case, the number of elements
implied by `shape` must be the same as the number of elements in `tensor`.

For example:

```prettyprint
# tensor 't' is [1, 2, 3, 4, 5, 6, 7, 8, 9]
# tensor 't' has shape [9]
reshape(t, [3, 3]) ==> [[1, 2, 3],
                        [4, 5, 6],
                        [7, 8, 9]]

# tensor 't' is [[[1, 1], [2, 2]],
#                [[3, 3], [4, 4]]]
# tensor 't' has shape [2, 2, 2]
reshape(t, [2, 4]) ==> [[1, 1, 2, 2],
                        [3, 3, 4, 4]]

# tensor 't' is [[[1, 1, 1],
#                 [2, 2, 2]],
#                [[3, 3, 3],
#                 [4, 4, 4]],
#                [[5, 5, 5],
#                 [6, 6, 6]]]
# tensor 't' has shape [3, 2, 3]
# pass '[-1]' to flatten 't'
reshape(t, [-1]) ==> [1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6]

# -1 can also be used to infer the shape

# -1 is inferred to be 9:
reshape(t, [2, -1]) ==> [[1, 1, 1, 2, 2, 2, 3, 3, 3],
                         [4, 4, 4, 5, 5, 5, 6, 6, 6]]
# -1 is inferred to be 2:
reshape(t, [-1, 9]) ==> [[1, 1, 1, 2, 2, 2, 3, 3, 3],
                         [4, 4, 4, 5, 5, 5, 6, 6, 6]]
# -1 is inferred to be 3:
reshape(t, [ 2, -1, 3]) ==> [[[1, 1, 1],
                              [2, 2, 2],
                              [3, 3, 3]],
                             [[4, 4, 4],
                              [5, 5, 5],
                              [6, 6, 6]]]

# tensor 't' is [7]
# shape `[]` reshapes to a scalar
reshape(t, []) ==> 7
```
"""
function reshape(v4366, v4367; name=nothing, T=nothing, Tshape=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Reshape") 
                begin  
                    begin  
                        if v4366 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4366)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4366)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4367 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4367)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4367)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tshape !== nothing 
                            desc["Tshape"] = Tshape
                        end
                    end
                end
            end), name, "Reshape") 
    tf.Tensor(tf.Operation(desc))
end

"""
     sparse_sparse_minimum(a_indices, a_values, a_shape, b_indices, b_values, b_shape)

Returns the element-wise min of two SparseTensors.

Assumes the two SparseTensors have the same shape, i.e., no broadcasting.
"""
function sparse_sparse_minimum(v4368, v4369, v4370, v4371, v4372, v4373; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SparseSparseMinimum") 
                begin  
                    begin  
                        if v4368 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4368)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4368)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4369 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4369)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4369)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4370 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4370)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4370)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4371 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4371)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4371)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4372 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4372)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4372)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4373 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4373)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4373)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "SparseSparseMinimum") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2))
    end
end

"""
     parse_single_sequence_example(serialized, feature_list_dense_missing_assumed_empty, context_sparse_keys, context_dense_keys, feature_list_sparse_keys, feature_list_dense_keys, context_dense_defaults, debug_name; Ncontext_sparse=0, Ncontext_dense=0, Nfeature_list_sparse=0, Nfeature_list_dense=0, context_sparse_types=Int64[], Tcontext_dense=Int64[], feature_list_dense_types=Int64[], context_dense_shapes=Int64[], feature_list_sparse_types=Int64[], feature_list_dense_shapes=Int64[])

Transforms a scalar brain.SequenceExample proto (as strings) into typed tensors.


"""
function parse_single_sequence_example(v4374, v4375, v4376, v4377, v4378, v4379, v4380, v4381; name=nothing, Ncontext_sparse=nothing, Ncontext_dense=nothing, Nfeature_list_sparse=nothing, Nfeature_list_dense=nothing, context_sparse_types=nothing, Tcontext_dense=nothing, feature_list_dense_types=nothing, context_dense_shapes=nothing, feature_list_sparse_types=nothing, feature_list_dense_shapes=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ParseSingleSequenceExample") 
                begin  
                    begin  
                        if v4374 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4374)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4374)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4375 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4375)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4375)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4376 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4376)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4376)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4377 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4377)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4377)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4378 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4378)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4378)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4379 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4379)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4379)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4380 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4380)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4380)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4381 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4381)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4381)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if Ncontext_sparse !== nothing 
                            desc["Ncontext_sparse"] = Ncontext_sparse
                        end
                    end
                    begin  
                        if Ncontext_dense !== nothing 
                            desc["Ncontext_dense"] = Ncontext_dense
                        end
                    end
                    begin  
                        if Nfeature_list_sparse !== nothing 
                            desc["Nfeature_list_sparse"] = Nfeature_list_sparse
                        end
                    end
                    begin  
                        if Nfeature_list_dense !== nothing 
                            desc["Nfeature_list_dense"] = Nfeature_list_dense
                        end
                    end
                    begin  
                        if context_sparse_types !== nothing 
                            desc["context_sparse_types"] = context_sparse_types
                        end
                    end
                    begin  
                        if Tcontext_dense !== nothing 
                            desc["Tcontext_dense"] = Tcontext_dense
                        end
                    end
                    begin  
                        if feature_list_dense_types !== nothing 
                            desc["feature_list_dense_types"] = feature_list_dense_types
                        end
                    end
                    begin  
                        if context_dense_shapes !== nothing 
                            desc["context_dense_shapes"] = context_dense_shapes
                        end
                    end
                    begin  
                        if feature_list_sparse_types !== nothing 
                            desc["feature_list_sparse_types"] = feature_list_sparse_types
                        end
                    end
                    begin  
                        if feature_list_dense_shapes !== nothing 
                            desc["feature_list_dense_shapes"] = feature_list_dense_shapes
                        end
                    end
                end
            end), name, "ParseSingleSequenceExample") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2), tf.Tensor(op, 3), tf.Tensor(op, 4), tf.Tensor(op, 5), tf.Tensor(op, 6), tf.Tensor(op, 7), tf.Tensor(op, 8))
    end
end

"""
     sparse_apply_momentum(var, accum, lr, grad, indices, momentum; use_locking=false, use_nesterov=false)

Update relevant entries in '*var' and '*accum' according to the momentum scheme.

Set use_nesterov = True if you want to use Nesterov momentum.

That is for rows we have grad for, we update var and accum as follows:

accum = accum * momentum + grad
var -= lr * accum
"""
function sparse_apply_momentum(v4382, v4383, v4384, v4385, v4386, v4387; name=nothing, T=nothing, Tindices=nothing, use_locking=nothing, use_nesterov=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SparseApplyMomentum") 
                begin  
                    begin  
                        if v4382 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4382)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4382)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4383 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4383)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4383)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4384 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4384)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4384)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4385 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4385)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4385)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4386 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4386)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4386)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4387 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4387)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4387)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tindices !== nothing 
                            desc["Tindices"] = Tindices
                        end
                    end
                    begin  
                        if use_locking !== nothing 
                            desc["use_locking"] = use_locking
                        end
                    end
                    begin  
                        if use_nesterov !== nothing 
                            desc["use_nesterov"] = use_nesterov
                        end
                    end
                end
            end), name, "SparseApplyMomentum") 
    tf.Tensor(tf.Operation(desc))
end

"""
     matrix_diag(diagonal)

Returns a batched diagonal tensor with a given batched diagonal values.

Given a `diagonal`, this operation returns a tensor with the `diagonal` and
everything else padded with zeros. The diagonal is computed as follows:

Assume `diagonal` has `k` dimensions `[I, J, K, ..., N]`, then the output is a
tensor of rank `k+1` with dimensions [I, J, K, ..., N, N]` where:

`output[i, j, k, ..., m, n] = 1{m=n} * diagonal[i, j, k, ..., n]`.

For example:

```prettyprint
# 'diagonal' is [[1, 2, 3, 4], [5, 6, 7, 8]]

and diagonal.shape = (2, 4)

tf.matrix_diag(diagonal) ==> [[[1, 0, 0, 0]
                                     [0, 2, 0, 0]
                                     [0, 0, 3, 0]
                                     [0, 0, 0, 4]],
                                    [[5, 0, 0, 0]
                                     [0, 6, 0, 0]
                                     [0, 0, 7, 0]
                                     [0, 0, 0, 8]]]

which has shape (2, 4, 4)
```
"""
function matrix_diag(v4388; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("MatrixDiag") 
                begin  
                    begin  
                        if v4388 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4388)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4388)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "MatrixDiag") 
    tf.Tensor(tf.Operation(desc))
end

"""
     hsvt_rgb(images; T=Float32)

Convert one or more images from HSV to RGB.

Outputs a tensor of the same shape as the `images` tensor, containing the RGB
value of the pixels. The output is only well defined if the value in `images`
are in `[0,1]`.

See `rgb_to_hsv` for a description of the HSV encoding.
"""
function hsvt_rgb(v4389; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("HSVToRGB") 
                begin  
                    begin  
                        if v4389 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4389)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4389)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "HSVToRGB") 
    tf.Tensor(tf.Operation(desc))
end

"""
     scatter_div(ref, indices, updates; use_locking=false)

Divides a variable reference by sparse updates.

This operation computes

    # Scalar indices
    ref[indices, ...] /= updates[...]

    # Vector indices (for each i)
    ref[indices[i], ...] /= updates[i, ...]

    # High rank indices (for each i, ..., j)
    ref[indices[i, ..., j], ...] /= updates[i, ..., j, ...]

This operation outputs `ref` after the update is done.
This makes it easier to chain operations that need to use the reset value.

Duplicate entries are handled correctly: if multiple `indices` reference
the same location, their contributions divide.

Requires `updates.shape = indices.shape + ref.shape[1:]`.
"""
function scatter_div(v4390, v4391, v4392; name=nothing, T=nothing, Tindices=nothing, use_locking=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ScatterDiv") 
                begin  
                    begin  
                        if v4390 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4390)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4390)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4391 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4391)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4391)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4392 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4392)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4392)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tindices !== nothing 
                            desc["Tindices"] = Tindices
                        end
                    end
                    begin  
                        if use_locking !== nothing 
                            desc["use_locking"] = use_locking
                        end
                    end
                end
            end), name, "ScatterDiv") 
    tf.Tensor(tf.Operation(desc))
end

"""
     fact()

Output a fact about factorials.


"""
function fact(; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Fact") 
                begin  
                end 
                begin  
                end
            end), name, "Fact") 
    tf.Tensor(tf.Operation(desc))
end

"""
     send(tensor; client_terminated=false)

Sends the named tensor from send_device to recv_device.


"""
function send(v4393; name=nothing, T=nothing, tensor_name=nothing, send_device=nothing, send_device_incarnation=nothing, recv_device=nothing, client_terminated=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("_Send") 
                begin  
                    begin  
                        if v4393 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4393)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4393)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if tensor_name !== nothing 
                            desc["tensor_name"] = tensor_name
                        end
                    end
                    begin  
                        if send_device !== nothing 
                            desc["send_device"] = send_device
                        end
                    end
                    begin  
                        if send_device_incarnation !== nothing 
                            desc["send_device_incarnation"] = send_device_incarnation
                        end
                    end
                    begin  
                        if recv_device !== nothing 
                            desc["recv_device"] = recv_device
                        end
                    end
                    begin  
                        if client_terminated !== nothing 
                            desc["client_terminated"] = client_terminated
                        end
                    end
                end
            end), name, "_Send") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     reverse_v2(tensor, axis; Tidx=Int32)

Reverses specific dimensions of a tensor.

NOTE `tf.reverse` has now changed behavior in preparation for 1.0.
`tf.reverse_v2` is currently an alias that will be deprecated before TF 1.0.

Given a `tensor`, and a `int32` tensor `axis` representing the set of
dimensions of `tensor` to reverse. This operation reverses each dimension
`i` for which there exists `j` s.t. `axis[j] == i`.

`tensor` can have up to 8 dimensions. The number of dimensions specified
in `axis` may be 0 or more entries. If an index is specified more than
once, a InvalidArgument error is raised.

For example:

```prettyprint
# tensor 't' is [[[[ 0,  1,  2,  3],
#                  [ 4,  5,  6,  7],
#                  [ 8,  9, 10, 11]],
#                 [[12, 13, 14, 15],
#                  [16, 17, 18, 19],
#                  [20, 21, 22, 23]]]]
# tensor 't' shape is [1, 2, 3, 4]

# 'dims' is [3] or 'dims' is -1
reverse(t, dims) ==> [[[[ 3,  2,  1,  0],
                        [ 7,  6,  5,  4],
                        [ 11, 10, 9, 8]],
                       [[15, 14, 13, 12],
                        [19, 18, 17, 16],
                        [23, 22, 21, 20]]]]

# 'dims' is '[1]' (or 'dims' is '[-3]')
reverse(t, dims) ==> [[[[12, 13, 14, 15],
                        [16, 17, 18, 19],
                        [20, 21, 22, 23]
                       [[ 0,  1,  2,  3],
                        [ 4,  5,  6,  7],
                        [ 8,  9, 10, 11]]]]

# 'dims' is '[2]' (or 'dims' is '[-2]')
reverse(t, dims) ==> [[[[8, 9, 10, 11],
                        [4, 5, 6, 7],
                        [0, 1, 2, 3]]
                       [[20, 21, 22, 23],
                        [16, 17, 18, 19],
                        [12, 13, 14, 15]]]]
```
"""
function reverse_v2(v4394, v4395; name=nothing, Tidx=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ReverseV2") 
                begin  
                    begin  
                        if v4394 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4394)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4394)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4395 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4395)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4395)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if Tidx !== nothing 
                            desc["Tidx"] = Tidx
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "ReverseV2") 
    tf.Tensor(tf.Operation(desc))
end

"""
     resize_bilinear_grad(grads, original_image; align_corners=false)

Computes the gradient of bilinear interpolation.


"""
function resize_bilinear_grad(v4396, v4397; name=nothing, T=nothing, align_corners=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ResizeBilinearGrad") 
                begin  
                    begin  
                        if v4396 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4396)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4396)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4397 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4397)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4397)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if align_corners !== nothing 
                            desc["align_corners"] = align_corners
                        end
                    end
                end
            end), name, "ResizeBilinearGrad") 
    tf.Tensor(tf.Operation(desc))
end

"""
     batch_to_space(input, crops; Tidx=Int32)

BatchToSpace for 4-D tensors of type T.

This is a legacy version of the more general BatchToSpaceND.

Rearranges (permutes) data from batch into blocks of spatial data, followed by
cropping. This is the reverse transformation of SpaceToBatch. More specifically,
this op outputs a copy of the input tensor where values from the `batch`
dimension are moved in spatial blocks to the `height` and `width` dimensions,
followed by cropping along the `height` and `width` dimensions.
"""
function batch_to_space(v4398, v4399; name=nothing, T=nothing, block_size=nothing, Tidx=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("BatchToSpace") 
                begin  
                    begin  
                        if v4398 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4398)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4398)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4399 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4399)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4399)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if block_size !== nothing 
                            desc["block_size"] = block_size
                        end
                    end
                    begin  
                        if Tidx !== nothing 
                            desc["Tidx"] = Tidx
                        end
                    end
                end
            end), name, "BatchToSpace") 
    tf.Tensor(tf.Operation(desc))
end

"""
     strided_slice(input, begin, end, strides; begin_mask=0, end_mask=0, ellipsis_mask=0, new_axis_mask=0, shrink_axis_mask=0)

Return a strided slice from `input`.

Note, most python users will want to use the Python `Tensor.__getitem__`
or `Variable.__getitem__` rather than this op directly.

The goal of this op is to produce a new tensor with a subset of
the elements from the `n` dimensional `input` tensor. The subset is chosen using
a sequence of `m` sparse range specifications encoded into the arguments
of this function. Note, in some cases
`m` could be equal to `n`, but this need not be the case. Each
range specification entry can be one of the following:

- An ellipsis (...). Ellipses are used to imply zero or more
  dimensions of full-dimension selection and are produced using
  `ellipsis_mask`. For example, `foo[...]` is the identity slice.

- A new axis. This is used to insert a new shape=1 dimension and is
  produced using `new_axis_mask`. For example, `foo[:, ...]` where
  `foo` is shape `(3, 4)` produces a `(1, 3, 4)` tensor.


- A range `begin:end:stride`. This is used to specify how much to choose from
  a given dimension. `stride` can be any integer but 0.  `begin` is an integer
  which represents the index of the first value to select while `end` represents
  the index of the last value to select. The number of values selected in each
  dimension is `end - begin` if `stride > 0` and `begin - end` if `stride < 0`.
  `begin` and `end` can be negative where `-1` is the last element, `-2` is
  the second to last. `begin_mask` controls whether to replace the explicitly
  given `begin` with an implicit effective value of `0` if `stride > 0` and
  `-1` if `stride < 0`. `end_mask` is analogous but produces the number
  required to create the largest open interval. For example, given a shape
  `(3,)` tensor `foo[:]`, the effective `begin` and `end` are `0` and `3`. Do
  not assume this is equivalent to `foo[0:-1]` which has an effective `begin`
  and `end` of `0` and `2`. Another example is `foo[-2::-1]` which reverses the
  first dimension of a tensor while dropping the last two (in the original
  order elements). For example `foo = [1,2,3,4]; foo[-2::-1]` is `[4,3]`.

- A single index. This is used to keep only elements that have a given
  index. For example (`foo[2, :]` on a shape `(5,6)` tensor produces a
  shape `(6,)` tensor. This is encoded in `begin` and `end` and
  `shrink_axis_mask`.

Each conceptual range specification is encoded in the op's argument. This
encoding is best understand by considering a non-trivial example. In
particular,
`foo[1, 2:4, None, ..., :-3:-1, :]` will be encoded as

```prettyprint
begin = [1, 2, x, x, 0, x] # x denotes don't care (usually 0)
end = [2, 4, x, x, -3, x]
strides = [1, 1, x, x, -1, 1]
begin_mask = 1<<4 | 1 << 5 = 48
end_mask = 1<<5 = 32
ellipsis_mask = 1<<3 = 8
new_axis_mask = 1<<2 4
shrink_axis_mask = 1<<0
```

In this case if `foo.shape` is (5, 5, 5, 5, 5, 5) the final shape of
the slice becomes (2, 1, 5, 5, 2, 5).
Let us walk step by step through each argument specification.

1.  The first argument in the example slice is turned into `begin = 1` and
`end = begin + 1 = 2`. To disambiguate from the original spec `2:4` we
also set the appropriate bit in `shrink_axis_mask`.

2. `2:4` is contributes 2, 4, 1 to begin, end, and stride. All masks have
zero bits contributed.

3. None is a synonym for `tf.newaxis`. This means insert a dimension of size 1
dimension in the final shape. Dummy values are contributed to begin,
end and stride, while the new_axis_mask bit is set.

4. `...` grab the full ranges from as many dimensions as needed to
fully specify a slice for every dimension of the input shape.

5. `:-3:-1` shows the use of negative indices. A negative index `i` associated
with a dimension that has shape `s` is converted to a positive index
`s + i`. So `-1` becomes `s-1` (i.e. the last element). This conversion
is done internally so begin, end and strides receive x, -3, and -1.
The appropriate begin_mask bit is set to indicate the start range is the
full range (ignoring the x).

6. `:` indicates that the entire contents of the corresponding dimension
is selected. This is equivalent to `::` or `0::1`. begin, end, and strides
receive 0, 0, and 1, respectively. The appropriate bits in `begin_mask` and
`end_mask` are also set.

*Requirements*:
  `0 != strides[i] for i in [0, m)`
  `ellipsis_mask must be a power of two (only one ellipsis)`
"""
function strided_slice(v4400, v4401, v4402, v4403; name=nothing, T=nothing, Index=nothing, begin_mask=nothing, end_mask=nothing, ellipsis_mask=nothing, new_axis_mask=nothing, shrink_axis_mask=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("StridedSlice") 
                begin  
                    begin  
                        if v4400 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4400)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4400)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4401 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Int32}, v4401)
                        else  
                            converted = convert(TensorFlow.Tensor{Int32}, v4401)
                        end 
                        begin  
                            converted = converted - 1
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4402 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Int32}, v4402)
                        else  
                            converted = convert(TensorFlow.Tensor{Int32}, v4402)
                        end 
                        begin  
                            converted = converted - 1
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4403 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Int32}, v4403)
                        else  
                            converted = convert(TensorFlow.Tensor{Int32}, v4403)
                        end 
                        begin  
                            converted = converted - 1
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Index !== nothing 
                            desc["Index"] = Index
                        end
                    end
                    begin  
                        if begin_mask !== nothing 
                            desc["begin_mask"] = begin_mask
                        end
                    end
                    begin  
                        if end_mask !== nothing 
                            desc["end_mask"] = end_mask
                        end
                    end
                    begin  
                        if ellipsis_mask !== nothing 
                            desc["ellipsis_mask"] = ellipsis_mask
                        end
                    end
                    begin  
                        if new_axis_mask !== nothing 
                            desc["new_axis_mask"] = new_axis_mask
                        end
                    end
                    begin  
                        if shrink_axis_mask !== nothing 
                            desc["shrink_axis_mask"] = shrink_axis_mask
                        end
                    end
                end
            end), name, "StridedSlice") 
    tf.Tensor(tf.Operation(desc))
end

"""
     matching_files(pattern)

Returns the set of files matching one or more glob patterns.

Note that this routine only supports wildcard characters in the
basename portion of the pattern, not in the directory portion.
"""
function matching_files(v4404; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("MatchingFiles") 
                begin  
                    begin  
                        if v4404 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4404)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4404)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "MatchingFiles") 
    tf.Tensor(tf.Operation(desc))
end

"""
     log(x)

Computes natural logarithm of x element-wise.

I.e., \\(y = \log_e x\\).
"""
function log(v4405; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Log") 
                begin  
                    begin  
                        if v4405 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4405)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4405)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Log") 
    tf.Tensor(tf.Operation(desc))
end

"""
     encode_base_64(input; pad=false)

Encode strings into web-safe base64 format.

Refer to the following article for more information on base64 format:
en.wikipedia.org/wiki/Base64. Base64 strings may have padding with '=' at the
end so that the encoded has length multiple of 4. See Padding section of the
link above.

Web-safe means that the encoder uses - and _ instead of + and /.
"""
function encode_base_64(v4406; name=nothing, pad=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("EncodeBase64") 
                begin  
                    begin  
                        if v4406 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4406)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4406)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if pad !== nothing 
                            desc["pad"] = pad
                        end
                    end
                end
            end), name, "EncodeBase64") 
    tf.Tensor(tf.Operation(desc))
end

"""
     cross(a, b)

Compute the pairwise cross product.

`a` and `b` must be the same shape; they can either be simple 3-element vectors,
or any shape where the innermost dimension is 3. In the latter case, each pair
of corresponding 3-element vectors is cross-multiplied independently.
"""
function cross(v4407, v4408; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Cross") 
                begin  
                    begin  
                        if v4407 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4407)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4407)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4408 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4408)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4408)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Cross") 
    tf.Tensor(tf.Operation(desc))
end

"""
     padding_fifoq(; shapes=Int64[], capacity=-1, container=, shared_name=)

A queue that produces elements in first-in first-out order.

Variable-size shapes are allowed by setting the corresponding shape dimensions
to 0 in the shape attr.  In this case DequeueMany will pad up to the maximum
size of any given element in the minibatch.  See below for details.
"""
function padding_fifoq(; name=nothing, component_types=nothing, shapes=nothing, capacity=nothing, container=nothing, shared_name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("PaddingFIFOQueue") 
                begin  
                end 
                begin  
                    begin  
                        if component_types !== nothing 
                            desc["component_types"] = component_types
                        end
                    end
                    begin  
                        if shapes !== nothing 
                            desc["shapes"] = shapes
                        end
                    end
                    begin  
                        if capacity !== nothing 
                            desc["capacity"] = capacity
                        end
                    end
                    begin  
                        if container !== nothing 
                            desc["container"] = container
                        end
                    end
                    begin  
                        if shared_name !== nothing 
                            desc["shared_name"] = shared_name
                        end
                    end
                end
            end), name, "PaddingFIFOQueue") 
    tf.Tensor(tf.Operation(desc))
end

"""
     save_v2(prefix, tensor_names, shape_and_slices, tensors)

Saves tensors in V2 checkpoint format.

By default, saves the named tensors in full.  If the caller wishes to save
specific slices of full tensors, "shape_and_slices" should be non-empty strings
and correspondingly well-formed.
"""
function save_v2(v4409, v4410, v4411, v4412; name=nothing, dtypes=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SaveV2") 
                begin  
                    begin  
                        if v4409 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4409)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4409)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4410 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4410)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4410)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4411 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4411)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4411)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4412 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4412)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4412)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if dtypes !== nothing 
                            desc["dtypes"] = dtypes
                        end
                    end
                end
            end), name, "SaveV2") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     sparse_apply_centered_rmsp(var, mg, ms, mom, lr, rho, momentum, epsilon, grad, indices; use_locking=false)

Update '*var' according to the centered RMSProp algorithm.

The centered RMSProp algorithm uses an estimate of the centered second moment
(i.e., the variance) for normalization, as opposed to regular RMSProp, which
uses the (uncentered) second moment. This often helps with training, but is
slightly more expensive in terms of computation and memory.

Note that in dense implementation of this algorithm, mg, ms, and mom will
update even if the grad is zero, but in this sparse implementation, mg, ms,
and mom will not update in iterations during which the grad is zero.

mean_square = decay * mean_square + (1-decay) * gradient ** 2
mean_grad = decay * mean_grad + (1-decay) * gradient
Delta = learning_rate * gradient / sqrt(mean_square + epsilon - mean_grad ** 2)

ms <- rho * ms_{t-1} + (1-rho) * grad * grad
mom <- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)
var <- var - mom
"""
function sparse_apply_centered_rmsp(v4413, v4414, v4415, v4416, v4417, v4418, v4419, v4420, v4421, v4422; name=nothing, T=nothing, Tindices=nothing, use_locking=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SparseApplyCenteredRMSProp") 
                begin  
                    begin  
                        if v4413 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4413)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4413)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4414 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4414)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4414)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4415 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4415)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4415)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4416 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4416)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4416)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4417 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4417)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4417)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4418 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4418)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4418)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4419 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4419)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4419)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4420 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4420)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4420)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4421 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4421)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4421)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4422 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4422)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4422)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tindices !== nothing 
                            desc["Tindices"] = Tindices
                        end
                    end
                    begin  
                        if use_locking !== nothing 
                            desc["use_locking"] = use_locking
                        end
                    end
                end
            end), name, "SparseApplyCenteredRMSProp") 
    tf.Tensor(tf.Operation(desc))
end

"""
     elu_grad(gradients, outputs)

Computes gradients for the exponential linear (Elu) operation.


"""
function elu_grad(v4423, v4424; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("EluGrad") 
                begin  
                    begin  
                        if v4423 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4423)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4423)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4424 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4424)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4424)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "EluGrad") 
    tf.Tensor(tf.Operation(desc))
end

"""
     conv_3d_backprop_input_v2(input_sizes, filter, out_backprop)

Computes the gradients of 3-D convolution with respect to the input.


"""
function conv_3d_backprop_input_v2(v4425, v4426, v4427; name=nothing, T=nothing, strides=nothing, padding=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Conv3DBackpropInputV2") 
                begin  
                    begin  
                        if v4425 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4425)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4425)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4426 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4426)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4426)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4427 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4427)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4427)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if strides !== nothing 
                            desc["strides"] = strides
                        end
                    end
                    begin  
                        if padding !== nothing 
                            desc["padding"] = padding
                        end
                    end
                end
            end), name, "Conv3DBackpropInputV2") 
    tf.Tensor(tf.Operation(desc))
end

"""
     string_to_hash_bucket_fast(input)

Converts each string in the input Tensor to its hash mod by a number of buckets.

The hash function is deterministic on the content of the string within the
process and will never change. However, it is not suitable for cryptography.
This function may be used when CPU time is scarce and inputs are trusted or
unimportant. There is a risk of adversaries constructing inputs that all hash
to the same bucket. To prevent this problem, use a strong hash function with
`tf.string_to_hash_bucket_strong`.
"""
function string_to_hash_bucket_fast(v4428; name=nothing, num_buckets=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("StringToHashBucketFast") 
                begin  
                    begin  
                        if v4428 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4428)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4428)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if num_buckets !== nothing 
                            desc["num_buckets"] = num_buckets
                        end
                    end
                end
            end), name, "StringToHashBucketFast") 
    tf.Tensor(tf.Operation(desc))
end

"""
     random_shuffle(value; seed=0, seed2=0)

Randomly shuffles a tensor along its first dimension.

  The tensor is shuffled along dimension 0, such that each `value[j]` is mapped
  to one and only one `output[i]`. For example, a mapping that might occur for a
  3x2 tensor is:

```prettyprint
[[1, 2],       [[5, 6],
 [3, 4],  ==>   [1, 2],
 [5, 6]]        [3, 4]]
```
"""
function random_shuffle(v4429; name=nothing, seed=nothing, seed2=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("RandomShuffle") 
                begin  
                    begin  
                        if v4429 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4429)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4429)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if seed !== nothing 
                            desc["seed"] = seed
                        end
                    end
                    begin  
                        if seed2 !== nothing 
                            desc["seed2"] = seed2
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "RandomShuffle") 
    tf.Tensor(tf.Operation(desc))
end

"""
     multinomial(logits, num_samples; seed=0, seed2=0)

Draws samples from a multinomial distribution.


"""
function multinomial(v4430, v4431; name=nothing, seed=nothing, seed2=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Multinomial") 
                begin  
                    begin  
                        if v4430 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4430)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4430)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4431 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4431)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4431)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if seed !== nothing 
                            desc["seed"] = seed
                        end
                    end
                    begin  
                        if seed2 !== nothing 
                            desc["seed2"] = seed2
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Multinomial") 
    tf.Tensor(tf.Operation(desc))
end

"""
     uniform_candidate_sampler(true_classes; seed=0, seed2=0)

Generates labels for candidate sampling with a uniform distribution.

See explanations of candidate sampling and the data formats at
go/candidate-sampling.

For each batch, this op picks a single set of sampled candidate labels.

The advantages of sampling candidates per-batch are simplicity and the
possibility of efficient dense matrix multiplication. The disadvantage is that
the sampled candidates must be chosen independently of the context and of the
true labels.
"""
function uniform_candidate_sampler(v4432; name=nothing, num_true=nothing, num_sampled=nothing, unique=nothing, range_max=nothing, seed=nothing, seed2=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("UniformCandidateSampler") 
                begin  
                    begin  
                        if v4432 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4432)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4432)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if num_true !== nothing 
                            desc["num_true"] = num_true
                        end
                    end
                    begin  
                        if num_sampled !== nothing 
                            desc["num_sampled"] = num_sampled
                        end
                    end
                    begin  
                        if unique !== nothing 
                            desc["unique"] = unique
                        end
                    end
                    begin  
                        if range_max !== nothing 
                            desc["range_max"] = range_max
                        end
                    end
                    begin  
                        if seed !== nothing 
                            desc["seed"] = seed
                        end
                    end
                    begin  
                        if seed2 !== nothing 
                            desc["seed2"] = seed2
                        end
                    end
                end
            end), name, "UniformCandidateSampler") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2), tf.Tensor(op, 3))
    end
end

"""
     tensor_array_split_v2(handle, value, lengths, flow_in)

Deprecated. Use TensorArraySplitV3


"""
function tensor_array_split_v2(v4433, v4434, v4435, v4436; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("TensorArraySplitV2") 
                begin  
                    begin  
                        if v4433 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4433)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4433)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4434 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4434)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4434)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4435 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4435)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4435)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4436 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4436)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4436)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "TensorArraySplitV2") 
    tf.Tensor(tf.Operation(desc))
end

"""
     tensor_array_write_v2(handle, index, value, flow_in)

Deprecated. Use TensorArrayGradV3


"""
function tensor_array_write_v2(v4437, v4438, v4439, v4440; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("TensorArrayWriteV2") 
                begin  
                    begin  
                        if v4437 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4437)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4437)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4438 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4438)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4438)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4439 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4439)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4439)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4440 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4440)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4440)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "TensorArrayWriteV2") 
    tf.Tensor(tf.Operation(desc))
end

"""
     queue_size_v2(handle)

Computes the number of elements in the given queue.


"""
function queue_size_v2(v4441; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("QueueSizeV2") 
                begin  
                    begin  
                        if v4441 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4441)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4441)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "QueueSizeV2") 
    tf.Tensor(tf.Operation(desc))
end

"""
     mutable_hash_table(; container=, shared_name=, use_node_name_sharing=false)

Creates an empty hash table.

This op creates a mutable hash table, specifying the type of its keys and
values. Each value must be a scalar. Data can be inserted into the table using
the insert operations. It does not support the initialization operation.
"""
function mutable_hash_table(; name=nothing, container=nothing, shared_name=nothing, use_node_name_sharing=nothing, key_dtype=nothing, value_dtype=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("MutableHashTable") 
                begin  
                end 
                begin  
                    begin  
                        if container !== nothing 
                            desc["container"] = container
                        end
                    end
                    begin  
                        if shared_name !== nothing 
                            desc["shared_name"] = shared_name
                        end
                    end
                    begin  
                        if use_node_name_sharing !== nothing 
                            desc["use_node_name_sharing"] = use_node_name_sharing
                        end
                    end
                    begin  
                        if key_dtype !== nothing 
                            desc["key_dtype"] = key_dtype
                        end
                    end
                    begin  
                        if value_dtype !== nothing 
                            desc["value_dtype"] = value_dtype
                        end
                    end
                end
            end), name, "MutableHashTable") 
    tf.Tensor(tf.Operation(desc))
end

"""
     relu(features)

Computes rectified linear: `max(features, 0)`.


"""
function relu(v4442; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Relu") 
                begin  
                    begin  
                        if v4442 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4442)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4442)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Relu") 
    tf.Tensor(tf.Operation(desc))
end

"""
     draw_bounding_boxes(images, boxes; T=Float32)

Draw bounding boxes on a batch of images.

Outputs a copy of `images` but draws on top of the pixels zero or more bounding
boxes specified by the locations in `boxes`. The coordinates of the each
bounding box in `boxes` are encoded as `[y_min, x_min, y_max, x_max]`. The
bounding box coordinates are floats in `[0.0, 1.0]` relative to the width and
height of the underlying image.

For example, if an image is 100 x 200 pixels and the bounding box is
`[0.1, 0.2, 0.5, 0.9]`, the bottom-left and upper-right coordinates of the
bounding box will be `(10, 40)` to `(50, 180)`.

Parts of the bounding box may fall outside the image.
"""
function draw_bounding_boxes(v4443, v4444; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("DrawBoundingBoxes") 
                begin  
                    begin  
                        if v4443 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4443)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4443)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4444 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4444)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4444)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "DrawBoundingBoxes") 
    tf.Tensor(tf.Operation(desc))
end

"""
     tensor_array_read(handle, index, flow_in)




"""
function tensor_array_read(v4445, v4446, v4447; name=nothing, dtype=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("TensorArrayRead") 
                begin  
                    begin  
                        if v4445 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4445)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4445)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4446 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4446)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4446)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4447 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4447)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4447)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if dtype !== nothing 
                            desc["dtype"] = dtype
                        end
                    end
                end
            end), name, "TensorArrayRead") 
    tf.Tensor(tf.Operation(desc))
end

"""
     expm_1(x)

Computes exponential of x - 1 element-wise.

I.e., \\(y = (\exp x) - 1\\).
"""
function expm_1(v4448; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Expm1") 
                begin  
                    begin  
                        if v4448 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4448)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4448)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Expm1") 
    tf.Tensor(tf.Operation(desc))
end

"""
     sparse_apply_proximal_adagrad(var, accum, lr, l1, l2, grad, indices; use_locking=false)

Sparse update entries in '*var' and '*accum' according to FOBOS algorithm.

That is for rows we have grad for, we update var and accum as follows:
accum += grad * grad
prox_v = var
prox_v -= lr * grad * (1 / sqrt(accum))
var = sign(prox_v)/(1+lr*l2) * max{|prox_v|-lr*l1,0}
"""
function sparse_apply_proximal_adagrad(v4449, v4450, v4451, v4452, v4453, v4454, v4455; name=nothing, T=nothing, Tindices=nothing, use_locking=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SparseApplyProximalAdagrad") 
                begin  
                    begin  
                        if v4449 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4449)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4449)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4450 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4450)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4450)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4451 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4451)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4451)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4452 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4452)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4452)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4453 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4453)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4453)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4454 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4454)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4454)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4455 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4455)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4455)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tindices !== nothing 
                            desc["Tindices"] = Tindices
                        end
                    end
                    begin  
                        if use_locking !== nothing 
                            desc["use_locking"] = use_locking
                        end
                    end
                end
            end), name, "SparseApplyProximalAdagrad") 
    tf.Tensor(tf.Operation(desc))
end

"""
     batch_matrix_band_part(input, num_lower, num_upper)




"""
function batch_matrix_band_part(v4456, v4457, v4458; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("BatchMatrixBandPart") 
                begin  
                    begin  
                        if v4456 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4456)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4456)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4457 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4457)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4457)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4458 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4458)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4458)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "BatchMatrixBandPart") 
    tf.Tensor(tf.Operation(desc))
end

"""
     softsign(features)

Computes softsign: `features / (abs(features) + 1)`.


"""
function softsign(v4459; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Softsign") 
                begin  
                    begin  
                        if v4459 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4459)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4459)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Softsign") 
    tf.Tensor(tf.Operation(desc))
end

"""
     mutable_dense_hash_table(empty_key; container=, shared_name=, use_node_name_sharing=false, value_shape=TensorShape[], initial_num_buckets=131072, max_load_factor=nothing)

Creates an empty hash table that uses tensors as the backing store. It uses

"open addressing" with quadratic reprobing to resolve collisions.

This op creates a mutable hash table, specifying the type of its keys and
values. Each value must be a scalar. Data can be inserted into the table using
the insert operations. It does not support the initialization operation.
"""
function mutable_dense_hash_table(v4460; name=nothing, container=nothing, shared_name=nothing, use_node_name_sharing=nothing, key_dtype=nothing, value_dtype=nothing, value_shape=nothing, initial_num_buckets=nothing, max_load_factor=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("MutableDenseHashTable") 
                begin  
                    begin  
                        if v4460 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4460)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4460)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if container !== nothing 
                            desc["container"] = container
                        end
                    end
                    begin  
                        if shared_name !== nothing 
                            desc["shared_name"] = shared_name
                        end
                    end
                    begin  
                        if use_node_name_sharing !== nothing 
                            desc["use_node_name_sharing"] = use_node_name_sharing
                        end
                    end
                    begin  
                        if key_dtype !== nothing 
                            desc["key_dtype"] = key_dtype
                        end
                    end
                    begin  
                        if value_dtype !== nothing 
                            desc["value_dtype"] = value_dtype
                        end
                    end
                    begin  
                        if value_shape !== nothing 
                            desc["value_shape"] = value_shape
                        end
                    end
                    begin  
                        if initial_num_buckets !== nothing 
                            desc["initial_num_buckets"] = initial_num_buckets
                        end
                    end
                    begin  
                        if max_load_factor !== nothing 
                            desc["max_load_factor"] = max_load_factor
                        end
                    end
                end
            end), name, "MutableDenseHashTable") 
    tf.Tensor(tf.Operation(desc))
end

"""
     decode_gif(contents)

Decode the first frame of a GIF-encoded image to a uint8 tensor.

GIF with frame or transparency compression are not supported
convert animated GIF from compressed to uncompressed by:

convert src.gif -coalesce dst.gif
"""
function decode_gif(v4461; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("DecodeGif") 
                begin  
                    begin  
                        if v4461 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4461)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4461)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "DecodeGif") 
    tf.Tensor(tf.Operation(desc))
end

"""
     unsorted_segment_max(data, segment_ids, num_segments)

Computes the Max along segments of a tensor.

Read [the section on
Segmentation](../../api_docs/python/math_ops.md#segmentation) for an explanation
of segments.

This operator is similar to the [unsorted segment sum operator](../../api_docs/python/math_ops.md#UnsortedSegmentSum).
Instead of computing the sum over segments, it computes the maximum
such that:

\\(output_i = \max_j data_j\\) where max is over `j` such
that `segment_ids[j] == i`.

If the maximum is empty for a given segment ID `i`, it outputs the smallest possible value for specific numeric type,
 `output[i] = numeric_limits<T>::min()`.

<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="../../images/UnsortedSegmentSum.png" alt>
</div>
"""
function unsorted_segment_max(v4462, v4463, v4464; name=nothing, T=nothing, Tindices=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("UnsortedSegmentMax") 
                begin  
                    begin  
                        if v4462 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4462)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4462)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4463 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4463)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4463)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4464 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4464)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4464)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tindices !== nothing 
                            desc["Tindices"] = Tindices
                        end
                    end
                end
            end), name, "UnsortedSegmentMax") 
    tf.Tensor(tf.Operation(desc))
end

"""
     conv_3d_backprop_filter(input, filter, out_backprop)

Computes the gradients of 3-D convolution with respect to the filter.


"""
function conv_3d_backprop_filter(v4465, v4466, v4467; name=nothing, T=nothing, strides=nothing, padding=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Conv3DBackpropFilter") 
                begin  
                    begin  
                        if v4465 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4465)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4465)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4466 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4466)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4466)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4467 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4467)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4467)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if strides !== nothing 
                            desc["strides"] = strides
                        end
                    end
                    begin  
                        if padding !== nothing 
                            desc["padding"] = padding
                        end
                    end
                end
            end), name, "Conv3DBackpropFilter") 
    tf.Tensor(tf.Operation(desc))
end

"""
     shape(input; out_type=Int32)

Returns the shape of a tensor.

This operation returns a 1-D integer tensor representing the shape of `input`.

For example:

```prettyprint
# 't' is [[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]
shape(t) ==> [2, 2, 3]
```
"""
function shape(v4468; name=nothing, T=nothing, out_type=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Shape") 
                begin  
                    begin  
                        if v4468 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4468)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4468)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if out_type !== nothing 
                            desc["out_type"] = out_type
                        end
                    end
                end
            end), name, "Shape") 
    tf.Tensor(tf.Operation(desc))
end

"""
     batch_self_adjoint_eig_v2(input; compute_v=true)




"""
function batch_self_adjoint_eig_v2(v4469; name=nothing, compute_v=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("BatchSelfAdjointEigV2") 
                begin  
                    begin  
                        if v4469 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4469)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4469)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if compute_v !== nothing 
                            desc["compute_v"] = compute_v
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "BatchSelfAdjointEigV2") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2))
    end
end

"""
     polygamma(a, x)

Compute the polygamma function \\(\psi^{(n)}(x)\\).

The polygamma function is defined as:

```
\psi^{(n)}(x) = \frac{d^n}{dx^n} \psi(x)
```
where \\(\psi(x)\\) is the digamma function.
"""
function polygamma(v4470, v4471; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Polygamma") 
                begin  
                    begin  
                        if v4470 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4470)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4470)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4471 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4471)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4471)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Polygamma") 
    tf.Tensor(tf.Operation(desc))
end

"""
     reciprocal_grad(x, y)

Computes the gradient for the inverse of `x` wrt its input.

Specifically, `grad = -dy * y*y`, where `y = 1/x`, and `dy`
is the corresponding input gradient.
"""
function reciprocal_grad(v4472, v4473; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ReciprocalGrad") 
                begin  
                    begin  
                        if v4472 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4472)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4472)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4473 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4473)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4473)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "ReciprocalGrad") 
    tf.Tensor(tf.Operation(desc))
end

"""
     crop_and_resize_grad_boxes(grads, image, boxes, box_ind; method=bilinear)

Computes the gradient of the crop_and_resize op wrt the input boxes tensor.


"""
function crop_and_resize_grad_boxes(v4474, v4475, v4476, v4477; name=nothing, T=nothing, method=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("CropAndResizeGradBoxes") 
                begin  
                    begin  
                        if v4474 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4474)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4474)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4475 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4475)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4475)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4476 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4476)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4476)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4477 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4477)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4477)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if method !== nothing 
                            desc["method"] = method
                        end
                    end
                end
            end), name, "CropAndResizeGradBoxes") 
    tf.Tensor(tf.Operation(desc))
end

"""
     reader_restore_state_v2(reader_handle, state)

Restore a reader to a previously saved state.

Not all Readers support being restored, so this can produce an
Unimplemented error.
"""
function reader_restore_state_v2(v4478, v4479; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ReaderRestoreStateV2") 
                begin  
                    begin  
                        if v4478 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4478)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4478)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4479 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4479)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4479)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "ReaderRestoreStateV2") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     softsign_grad(gradients, features)

Computes softsign gradients for a softsign operation.


"""
function softsign_grad(v4480, v4481; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SoftsignGrad") 
                begin  
                    begin  
                        if v4480 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4480)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4480)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4481 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4481)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4481)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "SoftsignGrad") 
    tf.Tensor(tf.Operation(desc))
end

"""
     top_kv_2(input, k; sorted=true)

Finds values and indices of the `k` largest elements for the last dimension.

If the input is a vector (rank-1), finds the `k` largest entries in the vector
and outputs their values and indices as vectors.  Thus `values[j]` is the
`j`-th largest entry in `input`, and its index is `indices[j]`.

For matrices (resp. higher rank input), computes the top `k` entries in each
row (resp. vector along the last dimension).  Thus,

    values.shape = indices.shape = input.shape[:-1] + [k]

If two elements are equal, the lower-index element appears first.
"""
function top_kv_2(v4482, v4483; name=nothing, sorted=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("TopKV2") 
                begin  
                    begin  
                        if v4482 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4482)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4482)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4483 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4483)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4483)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if sorted !== nothing 
                            desc["sorted"] = sorted
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "TopKV2") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2))
    end
end

"""
     arg_max(input, dimension; Tidx=Int32)

Returns the index with the largest value across dimensions of a tensor.


"""
function arg_max(v4484, v4485; name=nothing, T=nothing, Tidx=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ArgMax") 
                begin  
                    begin  
                        if v4484 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4484)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4484)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4485 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4485)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4485)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tidx !== nothing 
                            desc["Tidx"] = Tidx
                        end
                    end
                end
            end), name, "ArgMax") 
    tf.Tensor(tf.Operation(desc))
end

"""
     batch_matrix_solve(matrix, rhs; adjoint=false)




"""
function batch_matrix_solve(v4486, v4487; name=nothing, adjoint=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("BatchMatrixSolve") 
                begin  
                    begin  
                        if v4486 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4486)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4486)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4487 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4487)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4487)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if adjoint !== nothing 
                            desc["adjoint"] = adjoint
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "BatchMatrixSolve") 
    tf.Tensor(tf.Operation(desc))
end

"""
     sparse_add_grad(backprop_val_grad, a_indices, b_indices, sum_indices)

The gradient operator for the SparseAdd op.

The SparseAdd op calculates A + B, where A, B, and the sum are all represented
as `SparseTensor` objects.  This op takes in the upstream gradient w.r.t.
non-empty values of the sum, and outputs the gradients w.r.t. the non-empty
values of A and B.
"""
function sparse_add_grad(v4488, v4489, v4490, v4491; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SparseAddGrad") 
                begin  
                    begin  
                        if v4488 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4488)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4488)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4489 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4489)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4489)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4490 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4490)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4490)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4491 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4491)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4491)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "SparseAddGrad") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2))
    end
end

"""
     resource_scatter_add(resource, indices, updates)

Adds sparse updates to the variable referenced by `resource`.

This operation computes

    # Scalar indices
    ref[indices, ...] += updates[...]

    # Vector indices (for each i)
    ref[indices[i], ...] += updates[i, ...]

    # High rank indices (for each i, ..., j)
    ref[indices[i, ..., j], ...] += updates[i, ..., j, ...]

Duplicate entries are handled correctly: if multiple `indices` reference
the same location, their contributions add.

Requires `updates.shape = indices.shape + ref.shape[1:]`.

<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="../../images/ScatterAdd.png" alt>
</div>
"""
function resource_scatter_add(v4492, v4493, v4494; name=nothing, dtype=nothing, Tindices=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ResourceScatterAdd") 
                begin  
                    begin  
                        if v4492 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4492)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4492)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4493 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4493)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4493)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4494 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4494)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4494)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if dtype !== nothing 
                            desc["dtype"] = dtype
                        end
                    end
                    begin  
                        if Tindices !== nothing 
                            desc["Tindices"] = Tindices
                        end
                    end
                end
            end), name, "ResourceScatterAdd") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     ceil(x)

Returns element-wise smallest integer in not less than x.


"""
function ceil(v4495; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Ceil") 
                begin  
                    begin  
                        if v4495 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4495)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4495)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Ceil") 
    tf.Tensor(tf.Operation(desc))
end

"""
     save(filename, tensor_names, data)

Saves the input tensors to disk.

The size of `tensor_names` must match the number of tensors in `data`. `data[i]`
is written to `filename` with name `tensor_names[i]`.

See also `SaveSlices`.
"""
function save(v4496, v4497, v4498; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Save") 
                begin  
                    begin  
                        if v4496 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4496)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4496)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4497 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4497)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4497)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4498 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4498)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4498)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Save") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     lin_space(start, stop, num; Tidx=Int32)

Generates values in an interval.

A sequence of `num` evenly-spaced values are generated beginning at `start`.
If `num > 1`, the values in the sequence increase by `stop - start / num - 1`,
so that the last one is exactly `stop`.

For example:

```
tf.linspace(10.0, 12.0, 3, name="linspace") => [ 10.0  11.0  12.0]
```
"""
function lin_space(v4499, v4500, v4501; name=nothing, T=nothing, Tidx=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("LinSpace") 
                begin  
                    begin  
                        if v4499 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4499)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4499)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4500 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4500)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4500)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4501 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4501)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4501)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tidx !== nothing 
                            desc["Tidx"] = Tidx
                        end
                    end
                end
            end), name, "LinSpace") 
    tf.Tensor(tf.Operation(desc))
end

"""
     exit(data)

Exits the current frame to its parent frame.

Exit makes its input `data` available to the parent frame.
"""
function exit(v4502; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Exit") 
                begin  
                    begin  
                        if v4502 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4502)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4502)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Exit") 
    tf.Tensor(tf.Operation(desc))
end

"""
     quantized_concat(concat_dim, values, input_mins, input_maxes)

Concatenates quantized tensors along one dimension.


"""
function quantized_concat(v4503, v4504, v4505, v4506; name=nothing, N=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("QuantizedConcat") 
                begin  
                    begin  
                        if v4503 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4503)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4503)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4504 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4504)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4504)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4505 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4505)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4505)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4506 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4506)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4506)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if N !== nothing 
                            desc["N"] = N
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "QuantizedConcat") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2), tf.Tensor(op, 3))
    end
end

"""
     lrn(input; depth_radius=5, bias=nothing, alpha=nothing, beta=nothing, T=Float32)

Local Response Normalization.

The 4-D `input` tensor is treated as a 3-D array of 1-D vectors (along the last
dimension), and each vector is normalized independently.  Within a given vector,
each component is divided by the weighted, squared sum of inputs within
`depth_radius`.  In detail,

    sqr_sum[a, b, c, d] =
        sum(input[a, b, c, d - depth_radius : d + depth_radius + 1] ** 2)
    output = input / (bias + alpha * sqr_sum) ** beta

For details, see [Krizhevsky et al., ImageNet classification with deep
convolutional neural networks (NIPS 2012)](http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks).
"""
function lrn(v4507; name=nothing, depth_radius=nothing, bias=nothing, alpha=nothing, beta=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("LRN") 
                begin  
                    begin  
                        if v4507 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4507)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4507)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if depth_radius !== nothing 
                            desc["depth_radius"] = depth_radius
                        end
                    end
                    begin  
                        if bias !== nothing 
                            desc["bias"] = bias
                        end
                    end
                    begin  
                        if alpha !== nothing 
                            desc["alpha"] = alpha
                        end
                    end
                    begin  
                        if beta !== nothing 
                            desc["beta"] = beta
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "LRN") 
    tf.Tensor(tf.Operation(desc))
end

"""
     parallel_concat_update(value, update)

Updates input `value` at `loc` with `update`.

If you use this function you will almost certainly want to add
a control dependency as done in the implementation of parallel_stack to
avoid race conditions.
"""
function parallel_concat_update(v4508, v4509; name=nothing, T=nothing, loc=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("_ParallelConcatUpdate") 
                begin  
                    begin  
                        if v4508 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4508)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4508)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4509 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4509)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4509)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if loc !== nothing 
                            desc["loc"] = loc
                        end
                    end
                end
            end), name, "_ParallelConcatUpdate") 
    tf.Tensor(tf.Operation(desc))
end

"""
     matrix_set_diag(input, diagonal)

Returns a batched matrix tensor with new batched diagonal values.

Given `input` and `diagonal`, this operation returns a tensor with the
same shape and values as `input`, except for the main diagonal of the
innermost matrices.  These will be overwritten by the values in `diagonal`.

The output is computed as follows:

Assume `input` has `k+1` dimensions `[I, J, K, ..., M, N]` and `diagonal` has
`k` dimensions `[I, J, K, ..., min(M, N)]`.  Then the output is a
tensor of rank `k+1` with dimensions `[I, J, K, ..., M, N]` where:

  * `output[i, j, k, ..., m, n] = diagonal[i, j, k, ..., n]` for `m == n`.
  * `output[i, j, k, ..., m, n] = input[i, j, k, ..., m, n]` for `m != n`.
"""
function matrix_set_diag(v4510, v4511; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("MatrixSetDiag") 
                begin  
                    begin  
                        if v4510 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4510)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4510)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4511 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4511)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4511)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "MatrixSetDiag") 
    tf.Tensor(tf.Operation(desc))
end

"""
     zeros_like(x)

Returns a tensor of zeros with the same shape and type as x.


"""
function zeros_like(v4512; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ZerosLike") 
                begin  
                    begin  
                        if v4512 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4512)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4512)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "ZerosLike") 
    tf.Tensor(tf.Operation(desc))
end

"""
     fractional_avg_pool(value; pseudo_random=false, overlapping=false, deterministic=false, seed=0, seed2=0)

Performs fractional average pooling on the input.

Fractional average pooling is similar to Fractional max pooling in the pooling
region generation step. The only difference is that after pooling regions are
generated, a mean operation is performed instead of a max operation in each
pooling region.
"""
function fractional_avg_pool(v4513; name=nothing, pooling_ratio=nothing, pseudo_random=nothing, overlapping=nothing, deterministic=nothing, seed=nothing, seed2=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("FractionalAvgPool") 
                begin  
                    begin  
                        if v4513 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4513)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4513)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if pooling_ratio !== nothing 
                            desc["pooling_ratio"] = pooling_ratio
                        end
                    end
                    begin  
                        if pseudo_random !== nothing 
                            desc["pseudo_random"] = pseudo_random
                        end
                    end
                    begin  
                        if overlapping !== nothing 
                            desc["overlapping"] = overlapping
                        end
                    end
                    begin  
                        if deterministic !== nothing 
                            desc["deterministic"] = deterministic
                        end
                    end
                    begin  
                        if seed !== nothing 
                            desc["seed"] = seed
                        end
                    end
                    begin  
                        if seed2 !== nothing 
                            desc["seed2"] = seed2
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "FractionalAvgPool") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2), tf.Tensor(op, 3))
    end
end

"""
     space_to_batch_nd(input, block_shape, paddings; Tblock_shape=Int32, Tpaddings=Int32)

SpaceToBatch for N-D tensors of type T.

This operation divides "spatial" dimensions `[1, ..., M]` of the input into a
grid of blocks of shape `block_shape`, and interleaves these blocks with the
"batch" dimension (0) such that in the output, the spatial dimensions
`[1, ..., M]` correspond to the position within the grid, and the batch
dimension combines both the position within a spatial block and the original
batch position.  Prior to division into blocks, the spatial dimensions of the
input are optionally zero padded according to `paddings`.  See below for a
precise description.
"""
function space_to_batch_nd(v4514, v4515, v4516; name=nothing, T=nothing, Tblock_shape=nothing, Tpaddings=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SpaceToBatchND") 
                begin  
                    begin  
                        if v4514 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4514)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4514)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4515 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4515)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4515)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4516 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4516)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4516)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tblock_shape !== nothing 
                            desc["Tblock_shape"] = Tblock_shape
                        end
                    end
                    begin  
                        if Tpaddings !== nothing 
                            desc["Tpaddings"] = Tpaddings
                        end
                    end
                end
            end), name, "SpaceToBatchND") 
    tf.Tensor(tf.Operation(desc))
end

"""
     edit_distance(hypothesis_indices, hypothesis_values, hypothesis_shape, truth_indices, truth_values, truth_shape; normalize=true)

Computes the (possibly normalized) Levenshtein Edit Distance.

The inputs are variable-length sequences provided by SparseTensors
  (hypothesis_indices, hypothesis_values, hypothesis_shape)
and
  (truth_indices, truth_values, truth_shape).

The inputs are:
"""
function edit_distance(v4517, v4518, v4519, v4520, v4521, v4522; name=nothing, normalize=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("EditDistance") 
                begin  
                    begin  
                        if v4517 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4517)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4517)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4518 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4518)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4518)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4519 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4519)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4519)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4520 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4520)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4520)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4521 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4521)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4521)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4522 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4522)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4522)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if normalize !== nothing 
                            desc["normalize"] = normalize
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "EditDistance") 
    tf.Tensor(tf.Operation(desc))
end

"""
     sparse_reshape(input_indices, input_shape, new_shape)

Reshapes a SparseTensor to represent values in a new dense shape.

This operation has the same semantics as reshape on the represented dense
tensor.  The `input_indices` are recomputed based on the requested `new_shape`.

If one component of `new_shape` is the special value -1, the size of that
dimension is computed so that the total dense size remains constant.  At
most one component of `new_shape` can be -1.  The number of dense elements
implied by `new_shape` must be the same as the number of dense elements
originally implied by `input_shape`.

Reshaping does not affect the order of values in the SparseTensor.

If the input tensor has rank `R_in` and `N` non-empty values, and `new_shape`
has length `R_out`, then `input_indices` has shape `[N, R_in]`,
`input_shape` has length `R_in`, `output_indices` has shape `[N, R_out]`, and
`output_shape` has length `R_out`.
"""
function sparse_reshape(v4523, v4524, v4525; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SparseReshape") 
                begin  
                    begin  
                        if v4523 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4523)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4523)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4524 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4524)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4524)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4525 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4525)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4525)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "SparseReshape") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2))
    end
end

"""
     stack(; stack_name=)

A stack that produces elements in first-in last-out order.


"""
function stack(; name=nothing, elem_type=nothing, stack_name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Stack") 
                begin  
                end 
                begin  
                    begin  
                        if elem_type !== nothing 
                            desc["elem_type"] = elem_type
                        end
                    end
                    begin  
                        if stack_name !== nothing 
                            desc["stack_name"] = stack_name
                        end
                    end
                end
            end), name, "Stack") 
    tf.Tensor(tf.Operation(desc))
end

"""
     concat_v2(values, axis; Tidx=Int32)

Concatenates tensors along one dimension.


"""
function concat_v2(v4526, v4527; name=nothing, N=nothing, T=nothing, Tidx=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ConcatV2") 
                begin  
                    begin  
                        if v4526 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4526)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4526)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4527 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4527)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4527)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if N !== nothing 
                            desc["N"] = N
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tidx !== nothing 
                            desc["Tidx"] = Tidx
                        end
                    end
                end
            end), name, "ConcatV2") 
    tf.Tensor(tf.Operation(desc))
end

"""
     resource_sparse_apply_adadelta(var, accum, accum_update, lr, rho, epsilon, grad, indices; use_locking=false)

var: Should be from a Variable().


"""
function resource_sparse_apply_adadelta(v4528, v4529, v4530, v4531, v4532, v4533, v4534, v4535; name=nothing, T=nothing, Tindices=nothing, use_locking=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ResourceSparseApplyAdadelta") 
                begin  
                    begin  
                        if v4528 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4528)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4528)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4529 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4529)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4529)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4530 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4530)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4530)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4531 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4531)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4531)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4532 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4532)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4532)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4533 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4533)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4533)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4534 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4534)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4534)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4535 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4535)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4535)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tindices !== nothing 
                            desc["Tindices"] = Tindices
                        end
                    end
                    begin  
                        if use_locking !== nothing 
                            desc["use_locking"] = use_locking
                        end
                    end
                end
            end), name, "ResourceSparseApplyAdadelta") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     tile(input, multiples; Tmultiples=Int32)

Constructs a tensor by tiling a given tensor.

This operation creates a new tensor by replicating `input` `multiples` times.
The output tensor's i'th dimension has `input.dims(i) * multiples[i]` elements,
and the values of `input` are replicated `multiples[i]` times along the 'i'th
dimension. For example, tiling `[a b c d]` by `[2]` produces
`[a b c d a b c d]`.
"""
function tile(v4536, v4537; name=nothing, T=nothing, Tmultiples=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Tile") 
                begin  
                    begin  
                        if v4536 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4536)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4536)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4537 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4537)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4537)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tmultiples !== nothing 
                            desc["Tmultiples"] = Tmultiples
                        end
                    end
                end
            end), name, "Tile") 
    tf.Tensor(tf.Operation(desc))
end

"""
     rsqrt(x)

Computes reciprocal of square root of x element-wise.

I.e., \\(y = 1 / \sqrt{x}\\).
"""
function rsqrt(v4538; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Rsqrt") 
                begin  
                    begin  
                        if v4538 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4538)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4538)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Rsqrt") 
    tf.Tensor(tf.Operation(desc))
end

"""
     quantize_and_dequantize(input; signed_input=true, num_bits=8, range_given=false, input_min=nothing, input_max=nothing)

Use QuantizeAndDequantizeV2 instead.


"""
function quantize_and_dequantize(v4539; name=nothing, signed_input=nothing, num_bits=nothing, range_given=nothing, input_min=nothing, input_max=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("QuantizeAndDequantize") 
                begin  
                    begin  
                        if v4539 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4539)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4539)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if signed_input !== nothing 
                            desc["signed_input"] = signed_input
                        end
                    end
                    begin  
                        if num_bits !== nothing 
                            desc["num_bits"] = num_bits
                        end
                    end
                    begin  
                        if range_given !== nothing 
                            desc["range_given"] = range_given
                        end
                    end
                    begin  
                        if input_min !== nothing 
                            desc["input_min"] = input_min
                        end
                    end
                    begin  
                        if input_max !== nothing 
                            desc["input_max"] = input_max
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "QuantizeAndDequantize") 
    tf.Tensor(tf.Operation(desc))
end

"""
     quantize_and_dequantize_v2(input, input_min, input_max; signed_input=true, num_bits=8, range_given=false)

Quantizes then dequantizes a tensor.

This op simulates the precision loss from the quantized forward pass by:
1. Quantizing the tensor to fixed point numbers, which should match the target
   quantization method when it is used in inference.
2. Dequantizing it back to floating point numbers for the following ops, most
   likely matmul.

There are different ways to quantize. This version does not use the full range
of the output type, choosing to elide the lowest possible value for symmetry
(e.g., output range is -127 to 127, not -128 to 127 for signed 8 bit
quantization), so that 0.0 maps to 0.

To perform this op, we first find the range of values in our tensor. The range
we use is always centered on 0, so we find m such that

1. m = max(abs(input_min), abs(input_max)) if range_given is true,
2. m = max(abs(min_elem(input)), abs(max_elem(input))) otherwise.

Our input tensor range is then [-m, m].

Next, we choose our fixed-point quantization buckets, [min_fixed, max_fixed].
If signed_input is true, this is

  [min_fixed, max_fixed ] =
      [-(1 << (num_bits - 1) - 1), (1 << (num_bits - 1)) - 1].

Otherwise, if signed_input is false, the fixed-point range is

  [min_fixed, max_fixed] = [0, (1 << num_bits) - 1].

From this we compute our scaling factor, s:

  s = (max_fixed - min_fixed) / (2 * m).

Now we can quantize and dequantize the elements of our tensor.  An element e
is transformed into e':

  e' = (e * s).round_to_nearest() / s.

Note that we have a different number of buckets in the signed vs. unsigned
cases.  For example, if num_bits == 8, we get 254 buckets in the signed case
vs. 255 in the unsigned case.

For example, suppose num_bits = 8 and m = 1.  Then

  [min_fixed, max_fixed] = [-127, 127], and
  s = (127 + 127) / 2 = 127.

Given the vector {-1, -0.5, 0, 0.3}, this is quantized to
{-127, -63, 0, 38}, and dequantized to {-1, -63.0/127, 0, 38.0/127}.
"""
function quantize_and_dequantize_v2(v4540, v4541, v4542; name=nothing, signed_input=nothing, num_bits=nothing, range_given=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("QuantizeAndDequantizeV2") 
                begin  
                    begin  
                        if v4540 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4540)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4540)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4541 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4541)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4541)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4542 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4542)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4542)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if signed_input !== nothing 
                            desc["signed_input"] = signed_input
                        end
                    end
                    begin  
                        if num_bits !== nothing 
                            desc["num_bits"] = num_bits
                        end
                    end
                    begin  
                        if range_given !== nothing 
                            desc["range_given"] = range_given
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "QuantizeAndDequantizeV2") 
    tf.Tensor(tf.Operation(desc))
end

"""
     serialize_many_sparse(sparse_indices, sparse_values, sparse_shape)

Serialize an `N`-minibatch `SparseTensor` into an `[N, 3]` string `Tensor`.

The `SparseTensor` must have rank `R` greater than 1, and the first dimension
is treated as the minibatch dimension.  Elements of the `SparseTensor`
must be sorted in increasing order of this first dimension.  The serialized
`SparseTensor` objects going into each row of `serialized_sparse` will have
rank `R-1`.

The minibatch size `N` is extracted from `sparse_shape[0]`.
"""
function serialize_many_sparse(v4543, v4544, v4545; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SerializeManySparse") 
                begin  
                    begin  
                        if v4543 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4543)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4543)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4544 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4544)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4544)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4545 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4545)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4545)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "SerializeManySparse") 
    tf.Tensor(tf.Operation(desc))
end

"""
     delete_session_tensor(handle)

Delete the tensor specified by its handle in the session.


"""
function delete_session_tensor(v4546; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("DeleteSessionTensor") 
                begin  
                    begin  
                        if v4546 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4546)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4546)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "DeleteSessionTensor") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     one_hot(indices, depth, on_value, off_value; axis=-1, TI=Int64)

Returns a one-hot tensor.

The locations represented by indices in `indices` take value `on_value`,
while all other locations take value `off_value`.

If the input `indices` is rank `N`, the output will have rank `N+1`,
The new axis is created at dimension `axis` (default: the new axis is
appended at the end).

If `indices` is a scalar the output shape will be a vector of length `depth`.

If `indices` is a vector of length `features`, the output shape will be:
```
  features x depth if axis == -1
  depth x features if axis == 0
```

If `indices` is a matrix (batch) with shape `[batch, features]`,
the output shape will be:
```
  batch x features x depth if axis == -1
  batch x depth x features if axis == 1
  depth x batch x features if axis == 0
```


Examples
=========

Suppose that

```
  indices = [0, 2, -1, 1]
  depth = 3
  on_value = 5.0
  off_value = 0.0
  axis = -1
```

Then output is `[4 x 3]`:

    ```output =
      [5.0 0.0 0.0]  // one_hot(0)
      [0.0 0.0 5.0]  // one_hot(2)
      [0.0 0.0 0.0]  // one_hot(-1)
      [0.0 5.0 0.0]  // one_hot(1)
    ```

Suppose that

```
  indices = [0, 2, -1, 1]
  depth = 3
  on_value = 0.0
  off_value = 3.0
  axis = 0
```

Then output is `[3 x 4]`:

    ```output =
      [0.0 3.0 3.0 3.0]
      [3.0 3.0 3.0 0.0]
      [3.0 3.0 3.0 3.0]
      [3.0 0.0 3.0 3.0]
    //  ^                one_hot(0)
    //      ^            one_hot(2)
    //          ^        one_hot(-1)
    //              ^    one_hot(1)
    ```
Suppose that

```
  indices = [[0, 2], [1, -1]]
  depth = 3
  on_value = 1.0
  off_value = 0.0
  axis = -1
```

Then output is `[2 x 2 x 3]`:

    ```output =
      [
        [1.0, 0.0, 0.0]  // one_hot(0)
        [0.0, 0.0, 1.0]  // one_hot(2)
      ][
        [0.0, 1.0, 0.0]  // one_hot(1)
        [0.0, 0.0, 0.0]  // one_hot(-1)
      ]```
"""
function one_hot(v4547, v4548, v4549, v4550; name=nothing, axis=nothing, T=nothing, TI=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("OneHot") 
                begin  
                    begin  
                        if v4547 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4547)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4547)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4548 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4548)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4548)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4549 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4549)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4549)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4550 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4550)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4550)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if axis !== nothing 
                            desc["axis"] = axis
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if TI !== nothing 
                            desc["TI"] = TI
                        end
                    end
                end
            end), name, "OneHot") 
    tf.Tensor(tf.Operation(desc))
end

"""
     resource_apply_ftrl(var, accum, linear, grad, lr, l1, l2, lr_power; use_locking=false)

Update '*var' according to the Ftrl-proximal scheme.

accum_new = accum + grad * grad
linear += grad + (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var
quadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2
var = (sign(linear) * l1 - linear) / quadratic if |linear| > l1 else 0.0
accum = accum_new
"""
function resource_apply_ftrl(v4551, v4552, v4553, v4554, v4555, v4556, v4557, v4558; name=nothing, T=nothing, use_locking=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ResourceApplyFtrl") 
                begin  
                    begin  
                        if v4551 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4551)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4551)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4552 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4552)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4552)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4553 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4553)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4553)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4554 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4554)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4554)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4555 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4555)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4555)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4556 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4556)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4556)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4557 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4557)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4557)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4558 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4558)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4558)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if use_locking !== nothing 
                            desc["use_locking"] = use_locking
                        end
                    end
                end
            end), name, "ResourceApplyFtrl") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     apply_adagrad_da(var, gradient_accumulator, gradient_squared_accumulator, grad, lr, l1, l2, global_step; use_locking=false)

Update '*var' according to the proximal adagrad scheme.


"""
function apply_adagrad_da(v4559, v4560, v4561, v4562, v4563, v4564, v4565, v4566; name=nothing, T=nothing, use_locking=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ApplyAdagradDA") 
                begin  
                    begin  
                        if v4559 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4559)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4559)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4560 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4560)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4560)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4561 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4561)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4561)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4562 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4562)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4562)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4563 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4563)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4563)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4564 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4564)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4564)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4565 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4565)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4565)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4566 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4566)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4566)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if use_locking !== nothing 
                            desc["use_locking"] = use_locking
                        end
                    end
                end
            end), name, "ApplyAdagradDA") 
    tf.Tensor(tf.Operation(desc))
end

"""
     assign_variable_op(resource, value)

Assigns a new value to a variable.

Any ReadVariableOp with a control dependency on this op is guaranteed to return
this value or a subsequent newer value of the variable.
"""
function assign_variable_op(v4567, v4568; name=nothing, dtype=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("AssignVariableOp") 
                begin  
                    begin  
                        if v4567 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4567)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4567)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4568 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4568)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4568)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if dtype !== nothing 
                            desc["dtype"] = dtype
                        end
                    end
                end
            end), name, "AssignVariableOp") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     ctcb_search_decoder(inputs, sequence_length; merge_repeated=true)

Performs beam search decoding on the logits given in input.

A note about the attribute merge_repeated: For the beam search decoder,
this means that if consecutive entries in a beam are the same, only
the first of these is emitted.  That is, when the top path is "A B B B B",
"A B" is returned if merge_repeated = True but "A B B B B" is
returned if merge_repeated = False.
"""
function ctcb_search_decoder(v4569, v4570; name=nothing, beam_width=nothing, top_paths=nothing, merge_repeated=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("CTCBeamSearchDecoder") 
                begin  
                    begin  
                        if v4569 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4569)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4569)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4570 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4570)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4570)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if beam_width !== nothing 
                            desc["beam_width"] = beam_width
                        end
                    end
                    begin  
                        if top_paths !== nothing 
                            desc["top_paths"] = top_paths
                        end
                    end
                    begin  
                        if merge_repeated !== nothing 
                            desc["merge_repeated"] = merge_repeated
                        end
                    end
                end
            end), name, "CTCBeamSearchDecoder") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2), tf.Tensor(op, 3), tf.Tensor(op, 4))
    end
end

"""
     queue_enqueue(handle, components; timeout_ms=-1)

Enqueues a tuple of one or more tensors in the given queue.

The components input has k elements, which correspond to the components of
tuples stored in the given queue.

N.B. If the queue is full, this operation will block until the given
element has been enqueued (or 'timeout_ms' elapses, if specified).
"""
function queue_enqueue(v4571, v4572; name=nothing, Tcomponents=nothing, timeout_ms=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("QueueEnqueue") 
                begin  
                    begin  
                        if v4571 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4571)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4571)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4572 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4572)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4572)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if Tcomponents !== nothing 
                            desc["Tcomponents"] = Tcomponents
                        end
                    end
                    begin  
                        if timeout_ms !== nothing 
                            desc["timeout_ms"] = timeout_ms
                        end
                    end
                end
            end), name, "QueueEnqueue") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     conditional_accumulator(; container=, shared_name=)

A conditional accumulator for aggregating gradients. The accumulator accepts

gradients marked with local_step greater or equal to the most recent global_step
known to the accumulator. The average can be extracted from the accumulator,
provided sufficient gradients have been accumulated. Extracting the average
automatically resets the aggregate to 0, and increments the global_step recorded
by the accumulator.
"""
function conditional_accumulator(; name=nothing, dtype=nothing, shape=nothing, container=nothing, shared_name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ConditionalAccumulator") 
                begin  
                end 
                begin  
                    begin  
                        if dtype !== nothing 
                            desc["dtype"] = dtype
                        end
                    end
                    begin  
                        if shape !== nothing 
                            desc["shape"] = shape
                        end
                    end
                    begin  
                        if container !== nothing 
                            desc["container"] = container
                        end
                    end
                    begin  
                        if shared_name !== nothing 
                            desc["shared_name"] = shared_name
                        end
                    end
                end
            end), name, "ConditionalAccumulator") 
    tf.Tensor(tf.Operation(desc))
end

"""
     batch_matrix_solve_ls(matrix, rhs, l2_regularizer; fast=true)




"""
function batch_matrix_solve_ls(v4573, v4574, v4575; name=nothing, T=nothing, fast=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("BatchMatrixSolveLs") 
                begin  
                    begin  
                        if v4573 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4573)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4573)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4574 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4574)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4574)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4575 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4575)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4575)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if fast !== nothing 
                            desc["fast"] = fast
                        end
                    end
                end
            end), name, "BatchMatrixSolveLs") 
    tf.Tensor(tf.Operation(desc))
end

"""
     sparse_split(split_dim, indices, values, shape)

Split a `SparseTensor` into `num_split` tensors along one dimension.

If the `shape[split_dim]` is not an integer multiple of `num_split`. Slices
`[0 : shape[split_dim] % num_split]` gets one extra dimension.
For example, if `split_dim = 1` and `num_split = 2` and the input is

    input_tensor = shape = [2, 7]
    [    a   d e  ]
    [b c          ]

Graphically the output tensors are:

    output_tensor[0] = shape = [2, 4]
    [    a  ]
    [b c    ]

    output_tensor[1] = shape = [2, 3]
    [ d e  ]
    [      ]
"""
function sparse_split(v4576, v4577, v4578, v4579; name=nothing, num_split=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SparseSplit") 
                begin  
                    begin  
                        if v4576 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4576)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4576)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4577 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4577)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4577)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4578 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4578)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4578)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4579 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4579)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4579)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if num_split !== nothing 
                            desc["num_split"] = num_split
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "SparseSplit") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2), tf.Tensor(op, 3))
    end
end

"""
     depthwise_conv_2d_native(input, filter; data_format=NHWC)

Computes a 2-D depthwise convolution given 4-D `input` and `filter` tensors.

Given an input tensor of shape `[batch, in_height, in_width, in_channels]`
and a filter / kernel tensor of shape
`[filter_height, filter_width, in_channels, channel_multiplier]`, containing
`in_channels` convolutional filters of depth 1, `depthwise_conv2d` applies
a different filter to each input channel (expanding from 1 channel to
`channel_multiplier` channels for each), then concatenates the results
together. Thus, the output has `in_channels * channel_multiplier` channels.

for k in 0..in_channels-1
  for q in 0..channel_multiplier-1
    output[b, i, j, k * channel_multiplier + q] =
      sum_{di, dj} input[b, strides[1] * i + di, strides[2] * j + dj, k] *
                        filter[di, dj, k, q]

Must have `strides[0] = strides[3] = 1`.  For the most common case of the same
horizontal and vertices strides, `strides = [1, stride, stride, 1]`.
"""
function depthwise_conv_2d_native(v4580, v4581; name=nothing, T=nothing, strides=nothing, padding=nothing, data_format=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("DepthwiseConv2dNative") 
                begin  
                    begin  
                        if v4580 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4580)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4580)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4581 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4581)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4581)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if strides !== nothing 
                            desc["strides"] = strides
                        end
                    end
                    begin  
                        if padding !== nothing 
                            desc["padding"] = padding
                        end
                    end
                    begin  
                        if data_format !== nothing 
                            desc["data_format"] = data_format
                        end
                    end
                end
            end), name, "DepthwiseConv2dNative") 
    tf.Tensor(tf.Operation(desc))
end

"""
     not_equal(x, y)

Returns the truth value of (x != y) element-wise.

*NOTE*: `NotEqual` supports broadcasting. More about broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
"""
function not_equal(v4582, v4583; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("NotEqual") 
                begin  
                    begin  
                        if v4582 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4582)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4582)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4583 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4583)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4583)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "NotEqual") 
    tf.Tensor(tf.Operation(desc))
end

"""
     tensor_array_unpack(handle, value, flow_in)




"""
function tensor_array_unpack(v4584, v4585, v4586; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("TensorArrayUnpack") 
                begin  
                    begin  
                        if v4584 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4584)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4584)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4585 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4585)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4585)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4586 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4586)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4586)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "TensorArrayUnpack") 
    tf.Tensor(tf.Operation(desc))
end

"""
     lgamma(x)

Computes the log of the absolute value of `Gamma(x)` element-wise.


"""
function lgamma(v4587; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Lgamma") 
                begin  
                    begin  
                        if v4587 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4587)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4587)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Lgamma") 
    tf.Tensor(tf.Operation(desc))
end

"""
     top_k(input; sorted=true)

Finds values and indices of the `k` largest elements for the last dimension.

If the input is a vector (rank-1), finds the `k` largest entries in the vector
and outputs their values and indices as vectors.  Thus `values[j]` is the
`j`-th largest entry in `input`, and its index is `indices[j]`.

For matrices (resp. higher rank input), computes the top `k` entries in each
row (resp. vector along the last dimension).  Thus,

    values.shape = indices.shape = input.shape[:-1] + [k]

If two elements are equal, the lower-index element appears first.

If `k` varies dynamically, use `TopKV2` below.
"""
function top_k(v4588; name=nothing, k=nothing, sorted=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("TopK") 
                begin  
                    begin  
                        if v4588 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4588)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4588)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if k !== nothing 
                            desc["k"] = k
                        end
                    end
                    begin  
                        if sorted !== nothing 
                            desc["sorted"] = sorted
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "TopK") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2))
    end
end

"""
     barrier_incomplete_size(handle)

Computes the number of incomplete elements in the given barrier.


"""
function barrier_incomplete_size(v4589; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("BarrierIncompleteSize") 
                begin  
                    begin  
                        if v4589 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4589)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4589)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "BarrierIncompleteSize") 
    tf.Tensor(tf.Operation(desc))
end

"""
     whole_file_reader(; container=, shared_name=)

A Reader that outputs the entire contents of a file as a value.

To use, enqueue filenames in a Queue.  The output of ReaderRead will
be a filename (key) and the contents of that file (value).
"""
function whole_file_reader(; name=nothing, container=nothing, shared_name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("WholeFileReader") 
                begin  
                end 
                begin  
                    begin  
                        if container !== nothing 
                            desc["container"] = container
                        end
                    end
                    begin  
                        if shared_name !== nothing 
                            desc["shared_name"] = shared_name
                        end
                    end
                end
            end), name, "WholeFileReader") 
    tf.Tensor(tf.Operation(desc))
end

"""
     self_adjoint_eig(input)

Computes the Eigen Decomposition of a batch of square self-adjoint matrices.

The input is a tensor of shape `[..., M, M]` whose inner-most 2 dimensions
form square matrices, with the same constraints as the single matrix
SelfAdjointEig.

The result is a [..., M+1, M] matrix with [..., 0,:] containing the
eigenvalues, and subsequent [...,1:, :] containing the eigenvectors.
"""
function self_adjoint_eig(v4590; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SelfAdjointEig") 
                begin  
                    begin  
                        if v4590 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4590)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4590)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "SelfAdjointEig") 
    tf.Tensor(tf.Operation(desc))
end

"""
     apply_rmsp(var, ms, mom, lr, rho, momentum, epsilon, grad; use_locking=false)

Update '*var' according to the RMSProp algorithm.

Note that in dense implementation of this algorithm, ms and mom will
update even if the grad is zero, but in this sparse implementation, ms
and mom will not update in iterations during which the grad is zero.

mean_square = decay * mean_square + (1-decay) * gradient ** 2
Delta = learning_rate * gradient / sqrt(mean_square + epsilon)

ms <- rho * ms_{t-1} + (1-rho) * grad * grad
mom <- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)
var <- var - mom
"""
function apply_rmsp(v4591, v4592, v4593, v4594, v4595, v4596, v4597, v4598; name=nothing, T=nothing, use_locking=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ApplyRMSProp") 
                begin  
                    begin  
                        if v4591 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4591)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4591)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4592 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4592)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4592)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4593 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4593)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4593)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4594 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4594)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4594)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4595 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4595)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4595)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4596 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4596)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4596)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4597 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4597)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4597)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4598 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4598)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4598)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if use_locking !== nothing 
                            desc["use_locking"] = use_locking
                        end
                    end
                end
            end), name, "ApplyRMSProp") 
    tf.Tensor(tf.Operation(desc))
end

"""
     acos(x)

Computes acos of x element-wise.


"""
function acos(v4599; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Acos") 
                begin  
                    begin  
                        if v4599 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4599)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4599)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Acos") 
    tf.Tensor(tf.Operation(desc))
end

"""
     restore(file_pattern, tensor_name; preferred_shard=-1)

Restores a tensor from checkpoint files.

Reads a tensor stored in one or several files. If there are several files (for
instance because a tensor was saved as slices), `file_pattern` may contain
wildcard symbols (`*` and `?`) in the filename portion only, not in the
directory portion.

If a `file_pattern` matches several files, `preferred_shard` can be used to hint
in which file the requested tensor is likely to be found. This op will first
open the file at index `preferred_shard` in the list of matching files and try
to restore tensors from that file.  Only if some tensors or tensor slices are
not found in that first file, then the Op opens all the files. Setting
`preferred_shard` to match the value passed as the `shard` input
of a matching `Save` Op may speed up Restore.  This attribute only affects
performance, not correctness.  The default value -1 means files are processed in
order.

See also `RestoreSlice`.
"""
function restore(v4600, v4601; name=nothing, dt=nothing, preferred_shard=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Restore") 
                begin  
                    begin  
                        if v4600 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4600)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4600)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4601 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4601)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4601)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if dt !== nothing 
                            desc["dt"] = dt
                        end
                    end
                    begin  
                        if preferred_shard !== nothing 
                            desc["preferred_shard"] = preferred_shard
                        end
                    end
                end
            end), name, "Restore") 
    tf.Tensor(tf.Operation(desc))
end

"""
     adjust_saturation(images, scale)

Adjust the saturation of one or more images.

`images` is a tensor of at least 3 dimensions.  The last dimension is
interpretted as channels, and must be three.

The input image is considered in the RGB colorspace. Conceptually, the RGB
colors are first mapped into HSV. A scale is then applied all the saturation
values, and then remapped back to RGB colorspace.
"""
function adjust_saturation(v4602, v4603; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("AdjustSaturation") 
                begin  
                    begin  
                        if v4602 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4602)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4602)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4603 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4603)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4603)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "AdjustSaturation") 
    tf.Tensor(tf.Operation(desc))
end

"""
     all(input, reduction_indices; keep_dims=false, Tidx=Int32)

Computes the "logical and" of elements across dimensions of a tensor.

Reduces `input` along the dimensions given in `reduction_indices`. Unless
`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in
`reduction_indices`. If `keep_dims` is true, the reduced dimensions are
retained with length 1.
"""
function all(v4604, v4605; name=nothing, keep_dims=nothing, Tidx=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("All") 
                begin  
                    begin  
                        if v4604 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4604)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4604)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4605 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4605)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4605)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if keep_dims !== nothing 
                            desc["keep_dims"] = keep_dims
                        end
                    end
                    begin  
                        if Tidx !== nothing 
                            desc["Tidx"] = Tidx
                        end
                    end
                end
            end), name, "All") 
    tf.Tensor(tf.Operation(desc))
end

"""
     sparse_dense_cwise_div(sp_indices, sp_values, sp_shape, dense)

Component-wise divides a SparseTensor by a dense Tensor.

*Limitation*: this Op only broadcasts the dense side to the sparse side, but not
the other direction.
"""
function sparse_dense_cwise_div(v4606, v4607, v4608, v4609; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SparseDenseCwiseDiv") 
                begin  
                    begin  
                        if v4606 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4606)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4606)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4607 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4607)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4607)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4608 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4608)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4608)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4609 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4609)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4609)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "SparseDenseCwiseDiv") 
    tf.Tensor(tf.Operation(desc))
end

"""
     tensor_array_v3(size; element_shape=TensorShape[unknown], dynamic_size=false, clear_after_read=true, tensor_array_name=)

An array of Tensors of given size, with data written via Write and read

via Read or Pack.
"""
function tensor_array_v3(v4610; name=nothing, dtype=nothing, element_shape=nothing, dynamic_size=nothing, clear_after_read=nothing, tensor_array_name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("TensorArrayV3") 
                begin  
                    begin  
                        if v4610 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4610)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4610)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if dtype !== nothing 
                            desc["dtype"] = dtype
                        end
                    end
                    begin  
                        if element_shape !== nothing 
                            desc["element_shape"] = element_shape
                        end
                    end
                    begin  
                        if dynamic_size !== nothing 
                            desc["dynamic_size"] = dynamic_size
                        end
                    end
                    begin  
                        if clear_after_read !== nothing 
                            desc["clear_after_read"] = clear_after_read
                        end
                    end
                    begin  
                        if tensor_array_name !== nothing 
                            desc["tensor_array_name"] = tensor_array_name
                        end
                    end
                end
            end), name, "TensorArrayV3") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2))
    end
end

"""
     queue_close(handle; cancel_pending_enqueues=false)

Closes the given queue.

This operation signals that no more elements will be enqueued in the
given queue. Subsequent Enqueue(Many) operations will fail.
Subsequent Dequeue(Many) operations will continue to succeed if
sufficient elements remain in the queue. Subsequent Dequeue(Many)
operations that would block will fail immediately.
"""
function queue_close(v4611; name=nothing, cancel_pending_enqueues=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("QueueClose") 
                begin  
                    begin  
                        if v4611 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4611)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4611)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if cancel_pending_enqueues !== nothing 
                            desc["cancel_pending_enqueues"] = cancel_pending_enqueues
                        end
                    end
                end
            end), name, "QueueClose") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     var_handle_op(; container=, shared_name=)

Creates a handle to a Variable resource.


"""
function var_handle_op(; name=nothing, container=nothing, shared_name=nothing, dtype=nothing, shape=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("VarHandleOp") 
                begin  
                end 
                begin  
                    begin  
                        if container !== nothing 
                            desc["container"] = container
                        end
                    end
                    begin  
                        if shared_name !== nothing 
                            desc["shared_name"] = shared_name
                        end
                    end
                    begin  
                        if dtype !== nothing 
                            desc["dtype"] = dtype
                        end
                    end
                    begin  
                        if shape !== nothing 
                            desc["shape"] = shape
                        end
                    end
                end
            end), name, "VarHandleOp") 
    tf.Tensor(tf.Operation(desc))
end

"""
     in_top_k(predictions, targets; T=Int32)

Says whether the targets are in the top `K` predictions.

This outputs a `batch_size` bool array, an entry `out[i]` is `true` if the
prediction for the target class is among the top `k` predictions among
all predictions for example `i`. Note that the behavior of `InTopK` differs
from the `TopK` op in its handling of ties; if multiple classes have the
same prediction value and straddle the top-`k` boundary, all of those
classes are considered to be in the top `k`.

More formally, let

  \\(predictions_i\\) be the predictions for all classes for example `i`,
  \\(targets_i\\) be the target class for example `i`,
  \\(out_i\\) be the output for example `i`,

out_i = predictions_{i, targets_i} \in TopKIncludingTies(predictions_i)
"""
function in_top_k(v4612, v4613; name=nothing, k=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("InTopK") 
                begin  
                    begin  
                        if v4612 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4612)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4612)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4613 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4613)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4613)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if k !== nothing 
                            desc["k"] = k
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "InTopK") 
    tf.Tensor(tf.Operation(desc))
end

"""
     scatter_sub(ref, indices, updates; use_locking=false)

Subtracts sparse updates to a variable reference.

    # Scalar indices
    ref[indices, ...] -= updates[...]

    # Vector indices (for each i)
    ref[indices[i], ...] -= updates[i, ...]

    # High rank indices (for each i, ..., j)
    ref[indices[i, ..., j], ...] -= updates[i, ..., j, ...]

This operation outputs `ref` after the update is done.
This makes it easier to chain operations that need to use the reset value.

Duplicate entries are handled correctly: if multiple `indices` reference
the same location, their (negated) contributions add.

Requires `updates.shape = indices.shape + ref.shape[1:]`.

<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="../../images/ScatterSub.png" alt>
</div>
"""
function scatter_sub(v4614, v4615, v4616; name=nothing, T=nothing, Tindices=nothing, use_locking=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ScatterSub") 
                begin  
                    begin  
                        if v4614 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4614)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4614)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4615 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4615)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4615)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4616 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4616)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4616)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tindices !== nothing 
                            desc["Tindices"] = Tindices
                        end
                    end
                    begin  
                        if use_locking !== nothing 
                            desc["use_locking"] = use_locking
                        end
                    end
                end
            end), name, "ScatterSub") 
    tf.Tensor(tf.Operation(desc))
end

"""
     depthwise_conv_2d_native_backprop_filter(input, filter_sizes, out_backprop; data_format=NHWC)

Computes the gradients of depthwise convolution with respect to the filter.


"""
function depthwise_conv_2d_native_backprop_filter(v4617, v4618, v4619; name=nothing, T=nothing, strides=nothing, padding=nothing, data_format=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("DepthwiseConv2dNativeBackpropFilter") 
                begin  
                    begin  
                        if v4617 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4617)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4617)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4618 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4618)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4618)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4619 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4619)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4619)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if strides !== nothing 
                            desc["strides"] = strides
                        end
                    end
                    begin  
                        if padding !== nothing 
                            desc["padding"] = padding
                        end
                    end
                    begin  
                        if data_format !== nothing 
                            desc["data_format"] = data_format
                        end
                    end
                end
            end), name, "DepthwiseConv2dNativeBackpropFilter") 
    tf.Tensor(tf.Operation(desc))
end

"""
     priority_queue_v2(; component_types=Int64[], capacity=-1, container=, shared_name=)

A queue that produces elements sorted by the first component value.

Note that the PriorityQueue requires the first component of any element
to be a scalar int64, in addition to the other elements declared by
component_types.  Therefore calls to Enqueue and EnqueueMany (resp. Dequeue
and DequeueMany) on a PriorityQueue will all require (resp. output) one extra
entry in their input (resp. output) lists.
"""
function priority_queue_v2(; name=nothing, component_types=nothing, shapes=nothing, capacity=nothing, container=nothing, shared_name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("PriorityQueueV2") 
                begin  
                end 
                begin  
                    begin  
                        if component_types !== nothing 
                            desc["component_types"] = component_types
                        end
                    end
                    begin  
                        if shapes !== nothing 
                            desc["shapes"] = shapes
                        end
                    end
                    begin  
                        if capacity !== nothing 
                            desc["capacity"] = capacity
                        end
                    end
                    begin  
                        if container !== nothing 
                            desc["container"] = container
                        end
                    end
                    begin  
                        if shared_name !== nothing 
                            desc["shared_name"] = shared_name
                        end
                    end
                end
            end), name, "PriorityQueueV2") 
    tf.Tensor(tf.Operation(desc))
end

"""
     truncated_normal(shape; seed=0, seed2=0)

Outputs random values from a truncated normal distribution.

The generated values follow a normal distribution with mean 0 and standard
deviation 1, except that values whose magnitude is more than 2 standard
deviations from the mean are dropped and re-picked.
"""
function truncated_normal(v4620; name=nothing, seed=nothing, seed2=nothing, dtype=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("TruncatedNormal") 
                begin  
                    begin  
                        if v4620 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4620)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4620)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if seed !== nothing 
                            desc["seed"] = seed
                        end
                    end
                    begin  
                        if seed2 !== nothing 
                            desc["seed2"] = seed2
                        end
                    end
                    begin  
                        if dtype !== nothing 
                            desc["dtype"] = dtype
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "TruncatedNormal") 
    tf.Tensor(tf.Operation(desc))
end

"""
     cast(x)

Cast x of type SrcT to y of DstT.


"""
function cast(v4621; name=nothing, SrcT=nothing, DstT=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Cast") 
                begin  
                    begin  
                        if v4621 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4621)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4621)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if SrcT !== nothing 
                            desc["SrcT"] = SrcT
                        end
                    end
                    begin  
                        if DstT !== nothing 
                            desc["DstT"] = DstT
                        end
                    end
                end
            end), name, "Cast") 
    tf.Tensor(tf.Operation(desc))
end

"""
     quantize_v2(input, min_range, max_range; mode=MIN_COMBINED)

Quantize the 'input' tensor of type float to 'output' tensor of type 'T'.

[min_range, max_range] are scalar floats that specify the range for
the 'input' data. The 'mode' attribute controls exactly which calculations are
used to convert the float values to their quantized equivalents.

In 'MIN_COMBINED' mode, each value of the tensor will undergo the following:

```
out[i] = (in[i] - min_range) * range(T) / (max_range - min_range)
if T == qint8, out[i] -= (range(T) + 1) / 2.0
```
here `range(T) = numeric_limits<T>::max() - numeric_limits<T>::min()`

*MIN_COMBINED Mode Example*

Assume the input is type float and has a possible range of [0.0, 6.0] and the
output type is quint8 ([0, 255]). The min_range and max_range values should be
specified as 0.0 and 6.0. Quantizing from float to quint8 will multiply each
value of the input by 255/6 and cast to quint8.

If the output type was qint8 ([-128, 127]), the operation will additionally
subtract each value by 128 prior to casting, so that the range of values aligns
with the range of qint8.

If the mode is 'MIN_FIRST', then this approach is used:

```
number_of_steps = 1 << (# of bits in T)
range_adjust = number_of_steps / (number_of_steps - 1)
range = (range_max - range_min) * range_adjust
range_scale = number_of_steps / range
quantized = round(input * range_scale) - round(range_min * range_scale) +
  numeric_limits<T>::min()
quantized = max(quantized, numeric_limits<T>::min())
quantized = min(quantized, numeric_limits<T>::max())
```

The biggest difference between this and MIN_COMBINED is that the minimum range
is rounded first, before it's subtracted from the rounded value. With
MIN_COMBINED, a small bias is introduced where repeated iterations of quantizing
and dequantizing will introduce a larger and larger error.

One thing to watch out for is that the operator may choose to adjust the
requested minimum and maximum values slightly during the quantization process,
so you should always use the output ports as the range for further calculations.
For example, if the requested minimum and maximum values are close to equal,
they will be separated by a small epsilon value to prevent ill-formed quantized
buffers from being created. Otherwise, you can end up with buffers where all the
quantized values map to the same float value, which causes problems for
operations that have to perform further calculations on them.
"""
function quantize_v2(v4622, v4623, v4624; name=nothing, T=nothing, mode=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("QuantizeV2") 
                begin  
                    begin  
                        if v4622 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4622)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4622)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4623 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4623)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4623)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4624 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4624)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4624)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if mode !== nothing 
                            desc["mode"] = mode
                        end
                    end
                end
            end), name, "QuantizeV2") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2), tf.Tensor(op, 3))
    end
end

"""
     tensor_array_read_v3(handle, index, flow_in)

Read an element from the TensorArray into output `value`.


"""
function tensor_array_read_v3(v4625, v4626, v4627; name=nothing, dtype=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("TensorArrayReadV3") 
                begin  
                    begin  
                        if v4625 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4625)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4625)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4626 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4626)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4626)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4627 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4627)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4627)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if dtype !== nothing 
                            desc["dtype"] = dtype
                        end
                    end
                end
            end), name, "TensorArrayReadV3") 
    tf.Tensor(tf.Operation(desc))
end

"""
     list_diff(x, y; out_idx=Int32)

Computes the difference between two lists of numbers or strings.

Given a list `x` and a list `y`, this operation returns a list `out` that
represents all values that are in `x` but not in `y`. The returned list `out`
is sorted in the same order that the numbers appear in `x` (duplicates are
preserved). This operation also returns a list `idx` that represents the
position of each `out` element in `x`. In other words:

`out[i] = x[idx[i]] for i in [0, 1, ..., len(out) - 1]`

For example, given this input:

```prettyprint
x = [1, 2, 3, 4, 5, 6]
y = [1, 3, 5]
```

This operation would return:

```prettyprint
out ==> [2, 4, 6]
idx ==> [1, 3, 5]
```
"""
function list_diff(v4628, v4629; name=nothing, T=nothing, out_idx=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ListDiff") 
                begin  
                    begin  
                        if v4628 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4628)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4628)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4629 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4629)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4629)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if out_idx !== nothing 
                            desc["out_idx"] = out_idx
                        end
                    end
                end
            end), name, "ListDiff") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2))
    end
end

"""
     identity(input)

Return a tensor with the same shape and contents as the input tensor or value.


"""
function identity(v4630; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Identity") 
                begin  
                    begin  
                        if v4630 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4630)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4630)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Identity") 
    tf.Tensor(tf.Operation(desc))
end

"""
     print(input, data; message=, first_n=-1, summarize=3)

Prints a list of tensors.

Passes `input` through to `output` and prints `data` when evaluating.
"""
function print(v4631, v4632; name=nothing, T=nothing, U=nothing, message=nothing, first_n=nothing, summarize=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Print") 
                begin  
                    begin  
                        if v4631 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4631)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4631)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4632 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4632)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4632)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if U !== nothing 
                            desc["U"] = U
                        end
                    end
                    begin  
                        if message !== nothing 
                            desc["message"] = message
                        end
                    end
                    begin  
                        if first_n !== nothing 
                            desc["first_n"] = first_n
                        end
                    end
                    begin  
                        if summarize !== nothing 
                            desc["summarize"] = summarize
                        end
                    end
                end
            end), name, "Print") 
    tf.Tensor(tf.Operation(desc))
end

"""
     batch_matrix_inverse(input; adjoint=false)




"""
function batch_matrix_inverse(v4633; name=nothing, adjoint=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("BatchMatrixInverse") 
                begin  
                    begin  
                        if v4633 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4633)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4633)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if adjoint !== nothing 
                            desc["adjoint"] = adjoint
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "BatchMatrixInverse") 
    tf.Tensor(tf.Operation(desc))
end

"""
     list_to_array(input)

Converts a list of tensors to an array of tensors.


"""
function list_to_array(v4634; name=nothing, Tin=nothing, T=nothing, N=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("_ListToArray") 
                begin  
                    begin  
                        if v4634 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4634)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4634)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if Tin !== nothing 
                            desc["Tin"] = Tin
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if N !== nothing 
                            desc["N"] = N
                        end
                    end
                end
            end), name, "_ListToArray") 
    tf.Tensor(tf.Operation(desc))
end

"""
     neg_train(w_in, w_out, examples, labels, lr)

Training via negative sampling.


"""
function neg_train(v4635, v4636, v4637, v4638, v4639; name=nothing, vocab_count=nothing, num_negative_samples=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("NegTrain") 
                begin  
                    begin  
                        if v4635 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4635)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4635)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4636 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4636)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4636)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4637 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4637)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4637)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4638 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4638)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4638)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4639 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4639)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4639)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if vocab_count !== nothing 
                            desc["vocab_count"] = vocab_count
                        end
                    end
                    begin  
                        if num_negative_samples !== nothing 
                            desc["num_negative_samples"] = num_negative_samples
                        end
                    end
                end
            end), name, "NegTrain") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     reader_reset_v2(reader_handle)

Restore a Reader to its initial clean state.


"""
function reader_reset_v2(v4640; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ReaderResetV2") 
                begin  
                    begin  
                        if v4640 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4640)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4640)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "ReaderResetV2") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     merge_v_2c(checkpoint_prefixes, destination_prefix; delete_old_dirs=true)

V2 format specific: merges the metadata files of sharded checkpoints.  The

result is one logical checkpoint, with one physical metadata file and renamed
data files.

Intended for "grouping" multiple checkpoints in a sharded checkpoint setup.

If delete_old_dirs is true, attempts to delete recursively the dirname of each
path in the input checkpoint_prefixes.  This is useful when those paths are non
user-facing temporary locations.
"""
function merge_v_2c(v4641, v4642; name=nothing, delete_old_dirs=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("MergeV2Checkpoints") 
                begin  
                    begin  
                        if v4641 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4641)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4641)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4642 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4642)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4642)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if delete_old_dirs !== nothing 
                            desc["delete_old_dirs"] = delete_old_dirs
                        end
                    end
                end
            end), name, "MergeV2Checkpoints") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     accumulator_num_accumulated(handle)

Returns the number of gradients aggregated in the given accumulators.


"""
function accumulator_num_accumulated(v4643; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("AccumulatorNumAccumulated") 
                begin  
                    begin  
                        if v4643 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4643)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4643)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "AccumulatorNumAccumulated") 
    tf.Tensor(tf.Operation(desc))
end

"""
     rint(x)

Returns element-wise integer closest to x.

If the result is midway between two representable values,
the even representable is chosen.
For example:

```
rint(-1.5) ==> -2.0
rint(0.5000001) ==> 1.0
rint([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0]) ==> [-2., -2., -0., 0., 2., 2., 2.]
```
"""
function rint(v4644; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Rint") 
                begin  
                    begin  
                        if v4644 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4644)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4644)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Rint") 
    tf.Tensor(tf.Operation(desc))
end

"""
     control_trigger()

Does nothing. Serves as a control trigger for scheduling.

Only useful as a placeholder for control edges.
"""
function control_trigger(; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ControlTrigger") 
                begin  
                end 
                begin  
                end
            end), name, "ControlTrigger") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     tensor_array_close_v2(handle)

Deprecated. Use TensorArrayCloseV3


"""
function tensor_array_close_v2(v4645; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("TensorArrayCloseV2") 
                begin  
                    begin  
                        if v4645 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4645)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4645)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "TensorArrayCloseV2") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     hash_table(; container=, shared_name=, use_node_name_sharing=false)

Creates a non-initialized hash table.

This op creates a hash table, specifying the type of its keys and values.
Before using the table you will have to initialize it.  After initialization the
table will be immutable.
"""
function hash_table(; name=nothing, container=nothing, shared_name=nothing, use_node_name_sharing=nothing, key_dtype=nothing, value_dtype=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("HashTable") 
                begin  
                end 
                begin  
                    begin  
                        if container !== nothing 
                            desc["container"] = container
                        end
                    end
                    begin  
                        if shared_name !== nothing 
                            desc["shared_name"] = shared_name
                        end
                    end
                    begin  
                        if use_node_name_sharing !== nothing 
                            desc["use_node_name_sharing"] = use_node_name_sharing
                        end
                    end
                    begin  
                        if key_dtype !== nothing 
                            desc["key_dtype"] = key_dtype
                        end
                    end
                    begin  
                        if value_dtype !== nothing 
                            desc["value_dtype"] = value_dtype
                        end
                    end
                end
            end), name, "HashTable") 
    tf.Tensor(tf.Operation(desc))
end

"""
     softplus_grad(gradients, features)

Computes softplus gradients for a softplus operation.


"""
function softplus_grad(v4646, v4647; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SoftplusGrad") 
                begin  
                    begin  
                        if v4646 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4646)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4646)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4647 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4647)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4647)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "SoftplusGrad") 
    tf.Tensor(tf.Operation(desc))
end

"""
     fixed_length_record_reader(; header_bytes=0, footer_bytes=0, container=, shared_name=)

A Reader that outputs fixed-length records from a file.


"""
function fixed_length_record_reader(; name=nothing, header_bytes=nothing, record_bytes=nothing, footer_bytes=nothing, container=nothing, shared_name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("FixedLengthRecordReader") 
                begin  
                end 
                begin  
                    begin  
                        if header_bytes !== nothing 
                            desc["header_bytes"] = header_bytes
                        end
                    end
                    begin  
                        if record_bytes !== nothing 
                            desc["record_bytes"] = record_bytes
                        end
                    end
                    begin  
                        if footer_bytes !== nothing 
                            desc["footer_bytes"] = footer_bytes
                        end
                    end
                    begin  
                        if container !== nothing 
                            desc["container"] = container
                        end
                    end
                    begin  
                        if shared_name !== nothing 
                            desc["shared_name"] = shared_name
                        end
                    end
                end
            end), name, "FixedLengthRecordReader") 
    tf.Tensor(tf.Operation(desc))
end

"""
     tensor_array_scatter_v2(handle, indices, value, flow_in)

Deprecated. Use TensorArrayScatterV3


"""
function tensor_array_scatter_v2(v4648, v4649, v4650, v4651; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("TensorArrayScatterV2") 
                begin  
                    begin  
                        if v4648 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4648)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4648)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4649 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4649)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4649)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4650 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4650)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4650)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4651 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4651)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4651)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "TensorArrayScatterV2") 
    tf.Tensor(tf.Operation(desc))
end

"""
     stop_gradient(input)

Stops gradient computation.

When executed in a graph, this op outputs its input tensor as-is.

When building ops to compute gradients, this op prevents the contribution of
its inputs to be taken into account.  Normally, the gradient generator adds ops
to a graph to compute the derivatives of a specified 'loss' by recursively
finding out inputs that contributed to its computation.  If you insert this op
in the graph it inputs are masked from the gradient generator.  They are not
taken into account for computing gradients.

This is useful any time you want to compute a value with TensorFlow but need
to pretend that the value was a constant. Some examples include:

*  The *EM* algorithm where the *M-step* should not involve backpropagation
   through the output of the *E-step*.
*  Contrastive divergence training of Boltzmann machines where, when
   differentiating the energy function, the training must not backpropagate
   through the graph that generated the samples from the model.
*  Adversarial training, where no backprop should happen through the adversarial
   example generation process.
"""
function stop_gradient(v4652; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("StopGradient") 
                begin  
                    begin  
                        if v4652 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4652)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4652)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "StopGradient") 
    tf.Tensor(tf.Operation(desc))
end

"""
     extract_glimpse(input, size, offsets; centered=true, normalized=true, uniform_noise=true)

Extracts a glimpse from the input tensor.

Returns a set of windows called glimpses extracted at location
`offsets` from the input tensor. If the windows only partially
overlaps the inputs, the non overlapping areas will be filled with
random noise.

The result is a 4-D tensor of shape `[batch_size, glimpse_height,
glimpse_width, channels]`. The channels and batch dimensions are the
same as that of the input tensor. The height and width of the output
windows are specified in the `size` parameter.

The argument `normalized` and `centered` controls how the windows are built:

* If the coordinates are normalized but not centered, 0.0 and 1.0
  correspond to the minimum and maximum of each height and width
  dimension.
* If the coordinates are both normalized and centered, they range from
  -1.0 to 1.0. The coordinates (-1.0, -1.0) correspond to the upper
  left corner, the lower right corner is located at (1.0, 1.0) and the
  center is at (0, 0).
* If the coordinates are not normalized they are interpreted as
  numbers of pixels.
"""
function extract_glimpse(v4653, v4654, v4655; name=nothing, centered=nothing, normalized=nothing, uniform_noise=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ExtractGlimpse") 
                begin  
                    begin  
                        if v4653 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4653)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4653)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4654 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4654)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4654)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4655 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4655)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4655)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if centered !== nothing 
                            desc["centered"] = centered
                        end
                    end
                    begin  
                        if normalized !== nothing 
                            desc["normalized"] = normalized
                        end
                    end
                    begin  
                        if uniform_noise !== nothing 
                            desc["uniform_noise"] = uniform_noise
                        end
                    end
                end
            end), name, "ExtractGlimpse") 
    tf.Tensor(tf.Operation(desc))
end

"""
     decode_jsone(json_examples)

Convert JSON-encoded Example records to binary protocol buffer strings.

This op translates a tensor containing Example records, encoded using
the [standard JSON
mapping](https://developers.google.com/protocol-buffers/docs/proto3#json),
into a tensor containing the same records encoded as binary protocol
buffers. The resulting tensor can then be fed to any of the other
Example-parsing ops.
"""
function decode_jsone(v4656; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("DecodeJSONExample") 
                begin  
                    begin  
                        if v4656 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4656)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4656)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "DecodeJSONExample") 
    tf.Tensor(tf.Operation(desc))
end

"""
     reader_read_v2(reader_handle, queue_handle)

Returns the next record (key, value pair) produced by a Reader.

Will dequeue from the input queue if necessary (e.g. when the
Reader needs to start reading from a new file since it has finished
with the previous file).
"""
function reader_read_v2(v4657, v4658; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ReaderReadV2") 
                begin  
                    begin  
                        if v4657 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4657)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4657)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4658 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4658)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4658)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "ReaderReadV2") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2))
    end
end

"""
     string_to_hash_bucket_strong(input)

Converts each string in the input Tensor to its hash mod by a number of buckets.

The hash function is deterministic on the content of the string within the
process. The hash function is a keyed hash function, where attribute `key`
defines the key of the hash function. `key` is an array of 2 elements.

A strong hash is important when inputs may be malicious, e.g. URLs with
additional components. Adversaries could try to make their inputs hash to the
same bucket for a denial-of-service attack or to skew the results. A strong
hash prevents this by making it difficult, if not infeasible, to compute inputs
that hash to the same bucket. This comes at a cost of roughly 4x higher compute
time than `tf.string_to_hash_bucket_fast`.
"""
function string_to_hash_bucket_strong(v4659; name=nothing, num_buckets=nothing, key=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("StringToHashBucketStrong") 
                begin  
                    begin  
                        if v4659 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4659)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4659)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if num_buckets !== nothing 
                            desc["num_buckets"] = num_buckets
                        end
                    end
                    begin  
                        if key !== nothing 
                            desc["key"] = key
                        end
                    end
                end
            end), name, "StringToHashBucketStrong") 
    tf.Tensor(tf.Operation(desc))
end

"""
     split(split_dim, value)

Splits a tensor into `num_split` tensors along one dimension.


"""
function split(v4660, v4661; name=nothing, num_split=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Split") 
                begin  
                    begin  
                        if v4660 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4660)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4660)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4661 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4661)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4661)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if num_split !== nothing 
                            desc["num_split"] = num_split
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Split") 
    tf.Tensor(tf.Operation(desc))
end

"""
     mod(x, y)

Returns element-wise remainder of division.

*NOTE*: `Mod` supports broadcasting. More about broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
"""
function mod(v4662, v4663; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Mod") 
                begin  
                    begin  
                        if v4662 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4662)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4662)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4663 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4663)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4663)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Mod") 
    tf.Tensor(tf.Operation(desc))
end

"""
     resource_sparse_apply_momentum(var, accum, lr, grad, indices, momentum; use_locking=false, use_nesterov=false)

Update relevant entries in '*var' and '*accum' according to the momentum scheme.

Set use_nesterov = True if you want to use Nesterov momentum.

That is for rows we have grad for, we update var and accum as follows:

accum = accum * momentum + grad
var -= lr * accum
"""
function resource_sparse_apply_momentum(v4664, v4665, v4666, v4667, v4668, v4669; name=nothing, T=nothing, Tindices=nothing, use_locking=nothing, use_nesterov=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ResourceSparseApplyMomentum") 
                begin  
                    begin  
                        if v4664 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4664)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4664)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4665 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4665)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4665)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4666 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4666)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4666)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4667 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4667)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4667)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4668 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4668)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4668)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4669 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4669)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4669)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tindices !== nothing 
                            desc["Tindices"] = Tindices
                        end
                    end
                    begin  
                        if use_locking !== nothing 
                            desc["use_locking"] = use_locking
                        end
                    end
                    begin  
                        if use_nesterov !== nothing 
                            desc["use_nesterov"] = use_nesterov
                        end
                    end
                end
            end), name, "ResourceSparseApplyMomentum") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     save_slices(filename, tensor_names, shapes_and_slices, data)

Saves input tensors slices to disk.

This is like `Save` except that tensors can be listed in the saved file as being
a slice of a larger tensor.  `shapes_and_slices` specifies the shape of the
larger tensor and the slice that this tensor covers. `shapes_and_slices` must
have as many elements as `tensor_names`.

Elements of the `shapes_and_slices` input must either be:

*  The empty string, in which case the corresponding tensor is
   saved normally.
*  A string of the form `dim0 dim1 ... dimN-1 slice-spec` where the
   `dimI` are the dimensions of the larger tensor and `slice-spec`
   specifies what part is covered by the tensor to save.

`slice-spec` itself is a `:`-separated list: `slice0:slice1:...:sliceN-1`
where each `sliceI` is either:

*  The string `-` meaning that the slice covers all indices of this dimension
*  `start,length` where `start` and `length` are integers.  In that
   case the slice covers `length` indices starting at `start`.

See also `Save`.
"""
function save_slices(v4670, v4671, v4672, v4673; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SaveSlices") 
                begin  
                    begin  
                        if v4670 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4670)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4670)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4671 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4671)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4671)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4672 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4672)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4672)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4673 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4673)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4673)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "SaveSlices") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     unpack(value; axis=0)

Unpacks a given dimension of a rank-`R` tensor into `num` rank-`(R-1)` tensors.

Unpacks `num` tensors from `value` by chipping it along the `axis` dimension.
For example, given a tensor of shape `(A, B, C, D)`;

If `axis == 0` then the i'th tensor in `output` is the slice `value[i, :, :, :]`
  and each tensor in `output` will have shape `(B, C, D)`. (Note that the
  dimension unpacked along is gone, unlike `split`).

If `axis == 1` then the i'th tensor in `output` is the slice `value[:, i, :, :]`
  and each tensor in `output` will have shape `(A, C, D)`.
Etc.

This is the opposite of `pack`.
"""
function unpack(v4674; name=nothing, num=nothing, T=nothing, axis=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Unpack") 
                begin  
                    begin  
                        if v4674 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4674)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4674)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if num !== nothing 
                            desc["num"] = num
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if axis !== nothing 
                            desc["axis"] = axis
                        end
                    end
                end
            end), name, "Unpack") 
    tf.Tensor(tf.Operation(desc))
end

"""
     host_cast(x)

Cast x of type SrcT to y of DstT.

_HostCast requires its input and produces its output in host memory.
"""
function host_cast(v4675; name=nothing, SrcT=nothing, DstT=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("_HostCast") 
                begin  
                    begin  
                        if v4675 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4675)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4675)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if SrcT !== nothing 
                            desc["SrcT"] = SrcT
                        end
                    end
                    begin  
                        if DstT !== nothing 
                            desc["DstT"] = DstT
                        end
                    end
                end
            end), name, "_HostCast") 
    tf.Tensor(tf.Operation(desc))
end

"""
     tensor_array_write(handle, index, value, flow_in)




"""
function tensor_array_write(v4676, v4677, v4678, v4679; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("TensorArrayWrite") 
                begin  
                    begin  
                        if v4676 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4676)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4676)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4677 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4677)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4677)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4678 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4678)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4678)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4679 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4679)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4679)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "TensorArrayWrite") 
    tf.Tensor(tf.Operation(desc))
end

"""
     tfr_reader(; container=, shared_name=, compression_type=)

A Reader that outputs the records from a TensorFlow Records file.


"""
function tfr_reader(; name=nothing, container=nothing, shared_name=nothing, compression_type=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("TFRecordReader") 
                begin  
                end 
                begin  
                    begin  
                        if container !== nothing 
                            desc["container"] = container
                        end
                    end
                    begin  
                        if shared_name !== nothing 
                            desc["shared_name"] = shared_name
                        end
                    end
                    begin  
                        if compression_type !== nothing 
                            desc["compression_type"] = compression_type
                        end
                    end
                end
            end), name, "TFRecordReader") 
    tf.Tensor(tf.Operation(desc))
end

"""
     fill(dims, value)

Creates a tensor filled with a scalar value.

This operation creates a tensor of shape `dims` and fills it with `value`.

For example:

```prettyprint
# Output tensor has shape [2, 3].
fill([2, 3], 9) ==> [[9, 9, 9]
                     [9, 9, 9]]
```
"""
function fill(v4680, v4681; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Fill") 
                begin  
                    begin  
                        if v4680 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4680)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4680)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4681 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4681)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4681)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Fill") 
    tf.Tensor(tf.Operation(desc))
end

"""
     is_finite(x)

Returns which elements of x are finite.

@compatibility(numpy)
Equivalent to np.isfinite
@end_compatibility
"""
function is_finite(v4682; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("IsFinite") 
                begin  
                    begin  
                        if v4682 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4682)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4682)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "IsFinite") 
    tf.Tensor(tf.Operation(desc))
end

"""
     scatter_add(ref, indices, updates; use_locking=false)

Adds sparse updates to a variable reference.

This operation computes

    # Scalar indices
    ref[indices, ...] += updates[...]

    # Vector indices (for each i)
    ref[indices[i], ...] += updates[i, ...]

    # High rank indices (for each i, ..., j)
    ref[indices[i, ..., j], ...] += updates[i, ..., j, ...]

This operation outputs `ref` after the update is done.
This makes it easier to chain operations that need to use the reset value.

Duplicate entries are handled correctly: if multiple `indices` reference
the same location, their contributions add.

Requires `updates.shape = indices.shape + ref.shape[1:]`.

<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="../../images/ScatterAdd.png" alt>
</div>
"""
function scatter_add(v4683, v4684, v4685; name=nothing, T=nothing, Tindices=nothing, use_locking=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ScatterAdd") 
                begin  
                    begin  
                        if v4683 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4683)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4683)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4684 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4684)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4684)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4685 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4685)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4685)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tindices !== nothing 
                            desc["Tindices"] = Tindices
                        end
                    end
                    begin  
                        if use_locking !== nothing 
                            desc["use_locking"] = use_locking
                        end
                    end
                end
            end), name, "ScatterAdd") 
    tf.Tensor(tf.Operation(desc))
end

"""
     strided_slice_assign(ref, begin, end, strides, value; begin_mask=0, end_mask=0, ellipsis_mask=0, new_axis_mask=0, shrink_axis_mask=0)

Assign `value` to the sliced l-value reference of `ref`.

The values of `value` are assigned to the positions in the variable
`ref` that are selected by the slice parameters. The slice parameters
`begin, `end`, `strides`, etc. work exactly as in `StridedSlice`.

NOTE this op currently does not support broadcasting and so `value`'s
shape must be exactly the shape produced by the slice of `ref`.
"""
function strided_slice_assign(v4686, v4687, v4688, v4689, v4690; name=nothing, T=nothing, Index=nothing, begin_mask=nothing, end_mask=nothing, ellipsis_mask=nothing, new_axis_mask=nothing, shrink_axis_mask=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("StridedSliceAssign") 
                begin  
                    begin  
                        if v4686 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4686)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4686)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4687 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Int32}, v4687)
                        else  
                            converted = convert(TensorFlow.Tensor{Int32}, v4687)
                        end 
                        begin  
                            converted = converted - 1
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4688 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Int32}, v4688)
                        else  
                            converted = convert(TensorFlow.Tensor{Int32}, v4688)
                        end 
                        begin  
                            converted = converted - 1
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4689 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Int32}, v4689)
                        else  
                            converted = convert(TensorFlow.Tensor{Int32}, v4689)
                        end 
                        begin  
                            converted = converted - 1
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4690 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4690)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4690)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Index !== nothing 
                            desc["Index"] = Index
                        end
                    end
                    begin  
                        if begin_mask !== nothing 
                            desc["begin_mask"] = begin_mask
                        end
                    end
                    begin  
                        if end_mask !== nothing 
                            desc["end_mask"] = end_mask
                        end
                    end
                    begin  
                        if ellipsis_mask !== nothing 
                            desc["ellipsis_mask"] = ellipsis_mask
                        end
                    end
                    begin  
                        if new_axis_mask !== nothing 
                            desc["new_axis_mask"] = new_axis_mask
                        end
                    end
                    begin  
                        if shrink_axis_mask !== nothing 
                            desc["shrink_axis_mask"] = shrink_axis_mask
                        end
                    end
                end
            end), name, "StridedSliceAssign") 
    tf.Tensor(tf.Operation(desc))
end

"""
     conj(input; T=?)

Returns the complex conjugate of a complex number.

Given a tensor `input` of complex numbers, this operation returns a tensor of
complex numbers that are the complex conjugate of each element in `input`. The
complex numbers in `input` must be of the form \\(a + bj\\), where *a* is the
real part and *b* is the imaginary part.

The complex conjugate returned by this operation is of the form \\(a - bj\\).

For example:

```
# tensor 'input' is [-2.25 + 4.75j, 3.25 + 5.75j]
tf.conj(input) ==> [-2.25 - 4.75j, 3.25 - 5.75j]
```
"""
function conj(v4691; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Conj") 
                begin  
                    begin  
                        if v4691 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4691)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4691)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Conj") 
    tf.Tensor(tf.Operation(desc))
end

"""
     softmax(logits)

Computes softmax activations.

For each batch `i` and class `j` we have

    softmax[i, j] = exp(logits[i, j]) / sum_j(exp(logits[i, j]))
"""
function softmax(v4692; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Softmax") 
                begin  
                    begin  
                        if v4692 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4692)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4692)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Softmax") 
    tf.Tensor(tf.Operation(desc))
end

"""
     rfft_3d(input, fft_length)

Compute the 3-dimensional discrete Fourier Transform of a real-valued signal

over the inner-most 3 dimensions of `input`.

Since the DFT of a real signal is Hermitian-symmetric, `RFFT3D` only returns the
`fft_length / 2 + 1` unique components of the FFT for the inner-most dimension
of `output`: the zero-frequency term, followed by the `fft_length / 2`
positive-frequency terms.
"""
function rfft_3d(v4693, v4694; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("RFFT3D") 
                begin  
                    begin  
                        if v4693 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4693)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4693)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4694 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4694)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4694)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "RFFT3D") 
    tf.Tensor(tf.Operation(desc))
end

"""
     resize_bicubic(images, size; align_corners=false)

Resize `images` to `size` using bicubic interpolation.

Input images can be of different types but output images are always float.
"""
function resize_bicubic(v4695, v4696; name=nothing, T=nothing, align_corners=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ResizeBicubic") 
                begin  
                    begin  
                        if v4695 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4695)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4695)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4696 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4696)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4696)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if align_corners !== nothing 
                            desc["align_corners"] = align_corners
                        end
                    end
                end
            end), name, "ResizeBicubic") 
    tf.Tensor(tf.Operation(desc))
end

"""
     take_many_sparse_from_tensors_map(sparse_handles; container=, shared_name=)

Read `SparseTensors` from a `SparseTensorsMap` and concatenate them.

The input `sparse_handles` must be an `int64` matrix of shape `[N, 1]` where
`N` is the minibatch size and the rows correspond to the output handles of
`AddSparseToTensorsMap` or `AddManySparseToTensorsMap`.  The ranks of the
original `SparseTensor` objects that went into the given input ops must all
match.  When the final `SparseTensor` is created, it has rank one
higher than the ranks of the incoming `SparseTensor` objects
(they have been concatenated along a new row dimension on the left).

The output `SparseTensor` object's shape values for all dimensions but the
first are the max across the input `SparseTensor` objects' shape values
for the corresponding dimensions.  Its first shape value is `N`, the minibatch
size.

The input `SparseTensor` objects' indices are assumed ordered in
standard lexicographic order.  If this is not the case, after this
step run `SparseReorder` to restore index ordering.

For example, if the handles represent an input, which is a `[2, 3]` matrix
representing two original `SparseTensor` objects:

```
    index = [ 0]
            [10]
            [20]
    values = [1, 2, 3]
    shape = [50]
```

and

```
    index = [ 2]
            [10]
    values = [4, 5]
    shape = [30]
```

then the final `SparseTensor` will be:

```
    index = [0  0]
            [0 10]
            [0 20]
            [1  2]
            [1 10]
    values = [1, 2, 3, 4, 5]
    shape = [2 50]
```
"""
function take_many_sparse_from_tensors_map(v4697; name=nothing, dtype=nothing, container=nothing, shared_name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("TakeManySparseFromTensorsMap") 
                begin  
                    begin  
                        if v4697 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4697)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4697)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if dtype !== nothing 
                            desc["dtype"] = dtype
                        end
                    end
                    begin  
                        if container !== nothing 
                            desc["container"] = container
                        end
                    end
                    begin  
                        if shared_name !== nothing 
                            desc["shared_name"] = shared_name
                        end
                    end
                end
            end), name, "TakeManySparseFromTensorsMap") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2), tf.Tensor(op, 3))
    end
end

"""
     sparse_reduce_sum_sparse(input_indices, input_values, input_shape, reduction_axes; keep_dims=false)

Computes the sum of elements across dimensions of a SparseTensor.

This Op takes a SparseTensor and is the sparse counterpart to
`tf.reduce_sum()`.  In contrast to SparseReduceSum, this Op returns a
SparseTensor.

Reduces `sp_input` along the dimensions given in `reduction_axes`.  Unless
`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in
`reduction_axes`. If `keep_dims` is true, the reduced dimensions are retained
with length 1.

If `reduction_axes` has no entries, all dimensions are reduced, and a tensor
with a single element is returned.  Additionally, the axes can be negative,
which are interpreted according to the indexing rules in Python.
"""
function sparse_reduce_sum_sparse(v4698, v4699, v4700, v4701; name=nothing, keep_dims=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SparseReduceSumSparse") 
                begin  
                    begin  
                        if v4698 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4698)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4698)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4699 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4699)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4699)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4700 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4700)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4700)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4701 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4701)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4701)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if keep_dims !== nothing 
                            desc["keep_dims"] = keep_dims
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "SparseReduceSumSparse") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2), tf.Tensor(op, 3))
    end
end

"""
     batch_matrix_diag_part(input)




"""
function batch_matrix_diag_part(v4702; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("BatchMatrixDiagPart") 
                begin  
                    begin  
                        if v4702 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4702)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4702)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "BatchMatrixDiagPart") 
    tf.Tensor(tf.Operation(desc))
end

"""
     stack_push(handle, elem; swap_memory=false)

Push an element onto the stack.


"""
function stack_push(v4703, v4704; name=nothing, T=nothing, swap_memory=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("StackPush") 
                begin  
                    begin  
                        if v4703 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4703)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4703)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4704 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4704)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4704)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if swap_memory !== nothing 
                            desc["swap_memory"] = swap_memory
                        end
                    end
                end
            end), name, "StackPush") 
    tf.Tensor(tf.Operation(desc))
end

"""
     placeholder_v2()

A placeholder op for a value that will be fed into the computation.

N.B. This operation will fail with an error if it is executed. It is
intended as a way to represent a value that will always be fed, and to
provide attrs that enable the fed value to be checked at runtime.
"""
function placeholder_v2(; name=nothing, dtype=nothing, shape=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("PlaceholderV2") 
                begin  
                end 
                begin  
                    begin  
                        if dtype !== nothing 
                            desc["dtype"] = dtype
                        end
                    end
                    begin  
                        if shape !== nothing 
                            desc["shape"] = shape
                        end
                    end
                end
            end), name, "PlaceholderV2") 
    tf.Tensor(tf.Operation(desc))
end

"""
     queue_dequeue_v2(handle; timeout_ms=-1)

Dequeues a tuple of one or more tensors from the given queue.

This operation has k outputs, where k is the number of components
in the tuples stored in the given queue, and output i is the ith
component of the dequeued tuple.

N.B. If the queue is empty, this operation will block until an element
has been dequeued (or 'timeout_ms' elapses, if specified).
"""
function queue_dequeue_v2(v4705; name=nothing, component_types=nothing, timeout_ms=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("QueueDequeueV2") 
                begin  
                    begin  
                        if v4705 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4705)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4705)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if component_types !== nothing 
                            desc["component_types"] = component_types
                        end
                    end
                    begin  
                        if timeout_ms !== nothing 
                            desc["timeout_ms"] = timeout_ms
                        end
                    end
                end
            end), name, "QueueDequeueV2") 
    tf.Tensor(tf.Operation(desc))
end

"""
     transpose(x, perm; Tperm=Int32)

Shuffle dimensions of x according to a permutation.

The output `y` has the same rank as `x`. The shapes of `x` and `y` satisfy:
  `y.shape[i] == x.shape[perm[i]] for i in [0, 1, ..., rank(x) - 1]`
"""
function transpose(v4706, v4707; name=nothing, T=nothing, Tperm=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Transpose") 
                begin  
                    begin  
                        if v4706 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4706)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4706)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4707 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4707)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4707)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tperm !== nothing 
                            desc["Tperm"] = Tperm
                        end
                    end
                end
            end), name, "Transpose") 
    tf.Tensor(tf.Operation(desc))
end

"""
     decode_csv(records, record_defaults; field_delim=,)

Convert CSV records to tensors. Each column maps to one tensor.

RFC 4180 format is expected for the CSV records.
(https://tools.ietf.org/html/rfc4180)
Note that we allow leading and trailing spaces with int or float field.
"""
function decode_csv(v4708, v4709; name=nothing, OUT_TYPE=nothing, field_delim=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("DecodeCSV") 
                begin  
                    begin  
                        if v4708 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4708)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4708)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4709 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4709)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4709)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if OUT_TYPE !== nothing 
                            desc["OUT_TYPE"] = OUT_TYPE
                        end
                    end
                    begin  
                        if field_delim !== nothing 
                            desc["field_delim"] = field_delim
                        end
                    end
                end
            end), name, "DecodeCSV") 
    tf.Tensor(tf.Operation(desc))
end

"""
     ifft(input)

Compute the inverse 1-dimensional discrete Fourier Transform over the inner-most

dimension of `input`.
"""
function ifft(v4710; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("IFFT") 
                begin  
                    begin  
                        if v4710 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4710)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4710)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "IFFT") 
    tf.Tensor(tf.Operation(desc))
end

"""
     lookup_table_find(table_handle, keys, default_value)

Looks up keys in a table, outputs the corresponding values.

The tensor `keys` must of the same type as the keys of the table.
The output `values` is of the type of the table values.

The scalar `default_value` is the value output for keys not present in the
table. It must also be of the same type as the table values.
"""
function lookup_table_find(v4711, v4712, v4713; name=nothing, Tin=nothing, Tout=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("LookupTableFind") 
                begin  
                    begin  
                        if v4711 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4711)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4711)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4712 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4712)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4712)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4713 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4713)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4713)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if Tin !== nothing 
                            desc["Tin"] = Tin
                        end
                    end
                    begin  
                        if Tout !== nothing 
                            desc["Tout"] = Tout
                        end
                    end
                end
            end), name, "LookupTableFind") 
    tf.Tensor(tf.Operation(desc))
end

"""
     sparse_add(a_indices, a_values, a_shape, b_indices, b_values, b_shape, thresh)

Adds two `SparseTensor` objects to produce another `SparseTensor`.

The input `SparseTensor` objects' indices are assumed ordered in standard
lexicographic order.  If this is not the case, before this step run
`SparseReorder` to restore index ordering.

By default, if two values sum to zero at some index, the output `SparseTensor`
would still include that particular location in its index, storing a zero in the
corresponding value slot.  To override this, callers can specify `thresh`,
indicating that if the sum has a magnitude strictly smaller than `thresh`, its
corresponding value and index would then not be included.  In particular,
`thresh == 0` (default) means everything is kept and actual thresholding happens
only for a positive value.

In the following shapes, `nnz` is the count after taking `thresh` into account.
"""
function sparse_add(v4714, v4715, v4716, v4717, v4718, v4719, v4720; name=nothing, T=nothing, Treal=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SparseAdd") 
                begin  
                    begin  
                        if v4714 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4714)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4714)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4715 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4715)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4715)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4716 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4716)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4716)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4717 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4717)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4717)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4718 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4718)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4718)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4719 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4719)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4719)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4720 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4720)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4720)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Treal !== nothing 
                            desc["Treal"] = Treal
                        end
                    end
                end
            end), name, "SparseAdd") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2), tf.Tensor(op, 3))
    end
end

"""
     quantized_relu_6(features, min_features, max_features; out_type=?)

Computes Quantized Rectified Linear 6: `min(max(features, 0), 6)`


"""
function quantized_relu_6(v4721, v4722, v4723; name=nothing, Tinput=nothing, out_type=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("QuantizedRelu6") 
                begin  
                    begin  
                        if v4721 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4721)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4721)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4722 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4722)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4722)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4723 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4723)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4723)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if Tinput !== nothing 
                            desc["Tinput"] = Tinput
                        end
                    end
                    begin  
                        if out_type !== nothing 
                            desc["out_type"] = out_type
                        end
                    end
                end
            end), name, "QuantizedRelu6") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2), tf.Tensor(op, 3))
    end
end

"""
     ctcg_decoder(inputs, sequence_length; merge_repeated=false)

Performs greedy decoding on the logits given in inputs.

A note about the attribute merge_repeated: if enabled, when
consecutive logits' maximum indices are the same, only the first of
these is emitted.  Labeling the blank '*', the sequence "A B B * B B"
becomes "A B B" if merge_repeated = True and "A B B B B" if
merge_repeated = False.

Regardless of the value of merge_repeated, if the maximum index of a given
time and batch corresponds to the blank, index `(num_classes - 1)`, no new
element is emitted.
"""
function ctcg_decoder(v4724, v4725; name=nothing, merge_repeated=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("CTCGreedyDecoder") 
                begin  
                    begin  
                        if v4724 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4724)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4724)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4725 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4725)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4725)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if merge_repeated !== nothing 
                            desc["merge_repeated"] = merge_repeated
                        end
                    end
                end
            end), name, "CTCGreedyDecoder") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2), tf.Tensor(op, 3), tf.Tensor(op, 4))
    end
end

"""
     sparse_sparse_maximum(a_indices, a_values, a_shape, b_indices, b_values, b_shape)

Returns the element-wise max of two SparseTensors.

Assumes the two SparseTensors have the same shape, i.e., no broadcasting.
"""
function sparse_sparse_maximum(v4726, v4727, v4728, v4729, v4730, v4731; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SparseSparseMaximum") 
                begin  
                    begin  
                        if v4726 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4726)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4726)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4727 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4727)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4727)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4728 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4728)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4728)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4729 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4729)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4729)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4730 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4730)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4730)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4731 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4731)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4731)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "SparseSparseMaximum") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2))
    end
end

"""
     immutable_const_()

Returns immutable tensor from memory region.

The current implementation memmaps the tensor from a file.
"""
function immutable_const_(; name=nothing, dtype=nothing, shape=nothing, memory_region_name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ImmutableConst") 
                begin  
                end 
                begin  
                    begin  
                        if dtype !== nothing 
                            desc["dtype"] = dtype
                        end
                    end
                    begin  
                        if shape !== nothing 
                            desc["shape"] = shape
                        end
                    end
                    begin  
                        if memory_region_name !== nothing 
                            desc["memory_region_name"] = memory_region_name
                        end
                    end
                end
            end), name, "ImmutableConst") 
    tf.Tensor(tf.Operation(desc))
end

"""
     batch_norm_with_global_normalization(t, m, v, beta, gamma)

Batch normalization.

This op is deprecated. Prefer `tf.nn.batch_normalization`.
"""
function batch_norm_with_global_normalization(v4732, v4733, v4734, v4735, v4736; name=nothing, T=nothing, variance_epsilon=nothing, scale_after_normalization=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("BatchNormWithGlobalNormalization") 
                begin  
                    begin  
                        if v4732 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4732)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4732)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4733 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4733)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4733)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4734 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4734)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4734)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4735 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4735)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4735)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4736 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4736)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4736)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if variance_epsilon !== nothing 
                            desc["variance_epsilon"] = variance_epsilon
                        end
                    end
                    begin  
                        if scale_after_normalization !== nothing 
                            desc["scale_after_normalization"] = scale_after_normalization
                        end
                    end
                end
            end), name, "BatchNormWithGlobalNormalization") 
    tf.Tensor(tf.Operation(desc))
end

"""
     cholesky(input)

Computes the Cholesky decomposition of one or more square matrices.

The input is a tensor of shape `[..., M, M]` whose inner-most 2 dimensions
form square matrices, with the same constraints as the single matrix Cholesky
decomposition above. The output is a tensor of the same shape as the input
containing the Cholesky decompositions for all input submatrices `[..., :, :]`.
"""
function cholesky(v4737; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Cholesky") 
                begin  
                    begin  
                        if v4737 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4737)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4737)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Cholesky") 
    tf.Tensor(tf.Operation(desc))
end

"""
     avg_pool_3d_grad(orig_input_shape, grad)

Computes gradients of average pooling function.


"""
function avg_pool_3d_grad(v4738, v4739; name=nothing, ksize=nothing, strides=nothing, padding=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("AvgPool3DGrad") 
                begin  
                    begin  
                        if v4738 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4738)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4738)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4739 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4739)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4739)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if ksize !== nothing 
                            desc["ksize"] = ksize
                        end
                    end
                    begin  
                        if strides !== nothing 
                            desc["strides"] = strides
                        end
                    end
                    begin  
                        if padding !== nothing 
                            desc["padding"] = padding
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "AvgPool3DGrad") 
    tf.Tensor(tf.Operation(desc))
end

"""
     resource_apply_centered_rmsp(var, mg, ms, mom, lr, rho, momentum, epsilon, grad; use_locking=false)

Update '*var' according to the centered RMSProp algorithm.

The centered RMSProp algorithm uses an estimate of the centered second moment
(i.e., the variance) for normalization, as opposed to regular RMSProp, which
uses the (uncentered) second moment. This often helps with training, but is
slightly more expensive in terms of computation and memory.

Note that in dense implementation of this algorithm, mg, ms, and mom will
update even if the grad is zero, but in this sparse implementation, mg, ms,
and mom will not update in iterations during which the grad is zero.

mean_square = decay * mean_square + (1-decay) * gradient ** 2
mean_grad = decay * mean_grad + (1-decay) * gradient

Delta = learning_rate * gradient / sqrt(mean_square + epsilon - mean_grad ** 2)

mg <- rho * mg_{t-1} + (1-rho) * grad
ms <- rho * ms_{t-1} + (1-rho) * grad * grad
mom <- momentum * mom_{t-1} + lr * grad / sqrt(ms - mg * mg + epsilon)
var <- var - mom
"""
function resource_apply_centered_rmsp(v4740, v4741, v4742, v4743, v4744, v4745, v4746, v4747, v4748; name=nothing, T=nothing, use_locking=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ResourceApplyCenteredRMSProp") 
                begin  
                    begin  
                        if v4740 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4740)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4740)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4741 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4741)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4741)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4742 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4742)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4742)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4743 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4743)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4743)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4744 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4744)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4744)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4745 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4745)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4745)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4746 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4746)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4746)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4747 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4747)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4747)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4748 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4748)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4748)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if use_locking !== nothing 
                            desc["use_locking"] = use_locking
                        end
                    end
                end
            end), name, "ResourceApplyCenteredRMSProp") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     parameterized_truncated_normal(shape, means, stdevs, minvals, maxvals; seed=0, seed2=0)

Outputs random values from a normal distribution. The parameters may each be a

scalar which applies to the entire output, or a vector of length shape[0] which
stores the parameters for each batch.
"""
function parameterized_truncated_normal(v4749, v4750, v4751, v4752, v4753; name=nothing, seed=nothing, seed2=nothing, dtype=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ParameterizedTruncatedNormal") 
                begin  
                    begin  
                        if v4749 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4749)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4749)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4750 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4750)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4750)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4751 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4751)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4751)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4752 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4752)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4752)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4753 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4753)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4753)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if seed !== nothing 
                            desc["seed"] = seed
                        end
                    end
                    begin  
                        if seed2 !== nothing 
                            desc["seed2"] = seed2
                        end
                    end
                    begin  
                        if dtype !== nothing 
                            desc["dtype"] = dtype
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "ParameterizedTruncatedNormal") 
    tf.Tensor(tf.Operation(desc))
end

"""
     greater_equal(x, y)

Returns the truth value of (x >= y) element-wise.

*NOTE*: `GreaterEqual` supports broadcasting. More about broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
"""
function greater_equal(v4754, v4755; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("GreaterEqual") 
                begin  
                    begin  
                        if v4754 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4754)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4754)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4755 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4755)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4755)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "GreaterEqual") 
    tf.Tensor(tf.Operation(desc))
end

"""
     diag_part(input)

Returns the diagonal part of the tensor.

This operation returns a tensor with the `diagonal` part
of the `input`. The `diagonal` part is computed as follows:

Assume `input` has dimensions `[D1,..., Dk, D1,..., Dk]`, then the output is a
tensor of rank `k` with dimensions `[D1,..., Dk]` where:

`diagonal[i1,..., ik] = input[i1, ..., ik, i1,..., ik]`.

For example:

```prettyprint
# 'input' is [[1, 0, 0, 0]
              [0, 2, 0, 0]
              [0, 0, 3, 0]
              [0, 0, 0, 4]]

tf.diag_part(input) ==> [1, 2, 3, 4]
```
"""
function diag_part(v4756; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("DiagPart") 
                begin  
                    begin  
                        if v4756 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4756)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4756)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "DiagPart") 
    tf.Tensor(tf.Operation(desc))
end

"""
     placeholder_with_default(input)

A placeholder op that passes through `input` when its output is not fed.


"""
function placeholder_with_default(v4757; name=nothing, dtype=nothing, shape=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("PlaceholderWithDefault") 
                begin  
                    begin  
                        if v4757 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4757)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4757)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if dtype !== nothing 
                            desc["dtype"] = dtype
                        end
                    end
                    begin  
                        if shape !== nothing 
                            desc["shape"] = shape
                        end
                    end
                end
            end), name, "PlaceholderWithDefault") 
    tf.Tensor(tf.Operation(desc))
end

"""
     resource_apply_adagrad(var, accum, lr, grad; use_locking=false)

Update '*var' according to the adagrad scheme.

accum += grad * grad
var -= lr * grad * (1 / sqrt(accum))
"""
function resource_apply_adagrad(v4758, v4759, v4760, v4761; name=nothing, T=nothing, use_locking=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ResourceApplyAdagrad") 
                begin  
                    begin  
                        if v4758 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4758)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4758)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4759 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4759)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4759)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4760 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4760)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4760)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4761 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4761)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4761)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if use_locking !== nothing 
                            desc["use_locking"] = use_locking
                        end
                    end
                end
            end), name, "ResourceApplyAdagrad") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     queue_dequeue(handle; timeout_ms=-1)

Dequeues a tuple of one or more tensors from the given queue.

This operation has k outputs, where k is the number of components
in the tuples stored in the given queue, and output i is the ith
component of the dequeued tuple.

N.B. If the queue is empty, this operation will block until an element
has been dequeued (or 'timeout_ms' elapses, if specified).
"""
function queue_dequeue(v4762; name=nothing, component_types=nothing, timeout_ms=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("QueueDequeue") 
                begin  
                    begin  
                        if v4762 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4762)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4762)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if component_types !== nothing 
                            desc["component_types"] = component_types
                        end
                    end
                    begin  
                        if timeout_ms !== nothing 
                            desc["timeout_ms"] = timeout_ms
                        end
                    end
                end
            end), name, "QueueDequeue") 
    tf.Tensor(tf.Operation(desc))
end

"""
     sparse_tensor_dense_mat_mul(a_indices, a_values, a_shape, b; adjoint_a=false, adjoint_b=false)

Multiply SparseTensor (of rank 2) "A" by dense matrix "B".

No validity checking is performed on the indices of A.  However, the following
input format is recommended for optimal behavior:

if adjoint_a == false:
  A should be sorted in lexicographically increasing order.  Use SparseReorder
  if you're not sure.
if adjoint_a == true:
  A should be sorted in order of increasing dimension 1 (i.e., "column major"
  order instead of "row major" order).
"""
function sparse_tensor_dense_mat_mul(v4763, v4764, v4765, v4766; name=nothing, T=nothing, adjoint_a=nothing, adjoint_b=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SparseTensorDenseMatMul") 
                begin  
                    begin  
                        if v4763 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4763)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4763)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4764 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4764)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4764)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4765 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4765)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4765)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4766 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4766)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4766)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if adjoint_a !== nothing 
                            desc["adjoint_a"] = adjoint_a
                        end
                    end
                    begin  
                        if adjoint_b !== nothing 
                            desc["adjoint_b"] = adjoint_b
                        end
                    end
                end
            end), name, "SparseTensorDenseMatMul") 
    tf.Tensor(tf.Operation(desc))
end

"""
     equal(x, y)

Returns the truth value of (x == y) element-wise.

*NOTE*: `Equal` supports broadcasting. More about broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
"""
function equal(v4767, v4768; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Equal") 
                begin  
                    begin  
                        if v4767 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4767)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4767)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4768 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4768)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4768)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Equal") 
    tf.Tensor(tf.Operation(desc))
end

"""
     fractional_max_pool(value; pseudo_random=false, overlapping=false, deterministic=false, seed=0, seed2=0)

Performs fractional max pooling on the input.

Fractional max pooling is slightly different than regular max pooling.  In
regular max pooling, you downsize an input set by taking the maximum value of
smaller N x N subsections of the set (often 2x2), and try to reduce the set by
a factor of N, where N is an integer.  Fractional max pooling, as you might
expect from the word "fractional", means that the overall reduction ratio N
does not have to be an integer.

The sizes of the pooling regions are generated randomly but are fairly uniform.
For example, let's look at the height dimension, and the constraints on the
list of rows that will be pool boundaries.

First we define the following:

1.  input_row_length : the number of rows from the input set
2.  output_row_length : which will be smaller than the input
3.  alpha = input_row_length / output_row_length : our reduction ratio
4.  K = floor(alpha)
5.  row_pooling_sequence : this is the result list of pool boundary rows

Then, row_pooling_sequence should satisfy:

1.  a[0] = 0 : the first value of the sequence is 0
2.  a[end] = input_row_length : the last value of the sequence is the size
3.  K <= (a[i+1] - a[i]) <= K+1 : all intervals are K or K+1 size
4.  length(row_pooling_sequence) = output_row_length+1

For more details on fractional max pooling, see this paper:
[Benjamin Graham, Fractional Max-Pooling](http://arxiv.org/abs/1412.6071)
"""
function fractional_max_pool(v4769; name=nothing, pooling_ratio=nothing, pseudo_random=nothing, overlapping=nothing, deterministic=nothing, seed=nothing, seed2=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("FractionalMaxPool") 
                begin  
                    begin  
                        if v4769 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4769)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4769)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if pooling_ratio !== nothing 
                            desc["pooling_ratio"] = pooling_ratio
                        end
                    end
                    begin  
                        if pseudo_random !== nothing 
                            desc["pseudo_random"] = pseudo_random
                        end
                    end
                    begin  
                        if overlapping !== nothing 
                            desc["overlapping"] = overlapping
                        end
                    end
                    begin  
                        if deterministic !== nothing 
                            desc["deterministic"] = deterministic
                        end
                    end
                    begin  
                        if seed !== nothing 
                            desc["seed"] = seed
                        end
                    end
                    begin  
                        if seed2 !== nothing 
                            desc["seed2"] = seed2
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "FractionalMaxPool") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2), tf.Tensor(op, 3))
    end
end

"""
     scatter_nd(indices, updates, shape)

Creates a new tensor by applying sparse `updates` to individual

values or slices within a zero tensor of the given `shape` tensor according to
indices.  This operator is the inverse of the [tf.gather_nd](#gather_nd)
operator which extracts values or slices from a given tensor.

TODO(simister): Add a link to Variable.__getitem__ documentation on slice
syntax.

`shape` is a `TensorShape` with rank `P` and `indices` is a `Tensor` of rank
`Q`.

`indices` must be integer tensor, containing indices into `shape`.
It must be shape `[d_0, ..., d_{Q-2}, K]` where `0 < K <= P`.

The innermost dimension of `indices` (with length `K`) corresponds to
indices into elements (if `K = P`) or slices (if `K < P`) along the `K`th
dimension of `shape`.

`updates` is Tensor of rank `Q-1+P-K` with shape:

```
[d_0, ..., d_{Q-2}, shape[K], ..., shape[P-1]].
```

The simplest form of scatter is to insert individual elements in a tensor by
index. For example, say we want to insert 4 scattered elements in a rank-1
tensor with 8 elements.

<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="../../images/ScatterNd1.png" alt>
</div>

In Python, this scatter operation would look like this:

    indices = tf.constant([[4], [3], [1], [7]])
    updates = tf.constant([9, 10, 11, 12])
    shape = tf.constant([8])
    scatter = tf.scatter_nd(indices, updates, shape)
    with tf.Session() as sess:
      print sess.run(scatter)

The resulting tensor would look like this:

    [0, 11, 0, 10, 9, 0, 0, 12]

We can also, insert entire slices of a higher rank tensor all at once. For
example, if we wanted to insert two slices in the first dimension of a
rank-3 tensor with two matrices of new values.

<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="../../images/ScatterNd2.png" alt>
</div>

In Python, this scatter operation would look like this:

    indices = tf.constant([[0], [2]])
    updates = tf.constant([[[5, 5, 5, 5], [6, 6, 6, 6],
                            [7, 7, 7, 7], [8, 8, 8, 8]],
                           [[5, 5, 5, 5], [6, 6, 6, 6],
                            [7, 7, 7, 7], [8, 8, 8, 8]]])
    shape = tf.constant([4, 4, 4])
    scatter = tf.scatter_nd(indices, updates, shape)
    with tf.Session() as sess:
      print sess.run(scatter)

The resulting tensor would look like this:

    [[[5, 5, 5, 5], [6, 6, 6, 6], [7, 7, 7, 7], [8, 8, 8, 8]],
     [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]],
     [[5, 5, 5, 5], [6, 6, 6, 6], [7, 7, 7, 7], [8, 8, 8, 8]],
     [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]]
"""
function scatter_nd(v4770, v4771, v4772; name=nothing, T=nothing, Tindices=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ScatterNd") 
                begin  
                    begin  
                        if v4770 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4770)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4770)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4771 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4771)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4771)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4772 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4772)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4772)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tindices !== nothing 
                            desc["Tindices"] = Tindices
                        end
                    end
                end
            end), name, "ScatterNd") 
    tf.Tensor(tf.Operation(desc))
end

"""
     thread_unsafe_unigram_candidate_sampler(true_classes; seed=0, seed2=0)

Generates labels for candidate sampling with a learned unigram distribution.

See explanations of candidate sampling and the data formats at
go/candidate-sampling.

For each batch, this op picks a single set of sampled candidate labels.

The advantages of sampling candidates per-batch are simplicity and the
possibility of efficient dense matrix multiplication. The disadvantage is that
the sampled candidates must be chosen independently of the context and of the
true labels.
"""
function thread_unsafe_unigram_candidate_sampler(v4773; name=nothing, num_true=nothing, num_sampled=nothing, unique=nothing, range_max=nothing, seed=nothing, seed2=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ThreadUnsafeUnigramCandidateSampler") 
                begin  
                    begin  
                        if v4773 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4773)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4773)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if num_true !== nothing 
                            desc["num_true"] = num_true
                        end
                    end
                    begin  
                        if num_sampled !== nothing 
                            desc["num_sampled"] = num_sampled
                        end
                    end
                    begin  
                        if unique !== nothing 
                            desc["unique"] = unique
                        end
                    end
                    begin  
                        if range_max !== nothing 
                            desc["range_max"] = range_max
                        end
                    end
                    begin  
                        if seed !== nothing 
                            desc["seed"] = seed
                        end
                    end
                    begin  
                        if seed2 !== nothing 
                            desc["seed2"] = seed2
                        end
                    end
                end
            end), name, "ThreadUnsafeUnigramCandidateSampler") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2), tf.Tensor(op, 3))
    end
end

"""
     batch_self_adjoint_eig(input)




"""
function batch_self_adjoint_eig(v4774; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("BatchSelfAdjointEig") 
                begin  
                    begin  
                        if v4774 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4774)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4774)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "BatchSelfAdjointEig") 
    tf.Tensor(tf.Operation(desc))
end

"""
     sparse_softmax(sp_indices, sp_values, sp_shape)

Applies softmax to a batched N-D `SparseTensor`.

The inputs represent an N-D SparseTensor  with logical shape `[..., B, C]`
(where `N >= 2`), and with indices sorted in the canonical lexicographic order.

This op is equivalent to applying the normal `tf.nn.softmax()` to each innermost
logical submatrix with shape `[B, C]`, but with the catch that *the implicitly
zero elements do not participate*.  Specifically, the algorithm is equivalent
to the following:

  (1) Applies `tf.nn.softmax()` to a densified view of each innermost submatrix
      with shape `[B, C]`, along the size-C dimension;
  (2) Masks out the original implicitly-zero locations;
  (3) Renormalizes the remaining elements.

Hence, the `SparseTensor` result has exactly the same non-zero indices and
shape.
"""
function sparse_softmax(v4775, v4776, v4777; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SparseSoftmax") 
                begin  
                    begin  
                        if v4775 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4775)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4775)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4776 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4776)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4776)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4777 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4777)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4777)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "SparseSoftmax") 
    tf.Tensor(tf.Operation(desc))
end

"""
     set_size(set_indices, set_values, set_shape; validate_indices=true)

Number of unique elements along last dimension of input `set`.

Input `set` is a `SparseTensor` represented by `set_indices`, `set_values`,
and `set_shape`. The last dimension contains values in a set, duplicates are
allowed but ignored.

If `validate_indices` is `True`, this op validates the order and range of `set`
indices.
"""
function set_size(v4778, v4779, v4780; name=nothing, validate_indices=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SetSize") 
                begin  
                    begin  
                        if v4778 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4778)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4778)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4779 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4779)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4779)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4780 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4780)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4780)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if validate_indices !== nothing 
                            desc["validate_indices"] = validate_indices
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "SetSize") 
    tf.Tensor(tf.Operation(desc))
end

"""
     assert(condition, data; summarize=3)

Asserts that the given condition is true.

If `condition` evaluates to false, print the list of tensors in `data`.
`summarize` determines how many entries of the tensors to print.
"""
function assert(v4781, v4782; name=nothing, T=nothing, summarize=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Assert") 
                begin  
                    begin  
                        if v4781 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4781)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4781)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4782 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4782)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4782)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if summarize !== nothing 
                            desc["summarize"] = summarize
                        end
                    end
                end
            end), name, "Assert") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     parallel_concat(values)

Concatenates a list of `N` tensors along the first dimension.

The input tensors are all required to have size 1 in the first dimension.

For example:

```prettyprint
# 'x' is [[1, 4]]
# 'y' is [[2, 5]]
# 'z' is [[3, 6]]
parallel_concat([x, y, z]) => [[1, 4], [2, 5], [3, 6]]  # Pack along first dim.
```

The difference between concat and parallel_concat is that concat requires all
of the inputs be computed before the operation will begin but doesn't require
that the input shapes be known during graph construction.  Parallel concat
will copy pieces of the input into the output as they become available, in
some situations this can provide a performance benefit.
"""
function parallel_concat(v4783; name=nothing, N=nothing, T=nothing, shape=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ParallelConcat") 
                begin  
                    begin  
                        if v4783 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4783)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4783)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if N !== nothing 
                            desc["N"] = N
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if shape !== nothing 
                            desc["shape"] = shape
                        end
                    end
                end
            end), name, "ParallelConcat") 
    tf.Tensor(tf.Operation(desc))
end

"""
     select(condition, t, e)

Selects elements from `t` or `e`, depending on `condition`.

The `t`, and `e` tensors must all have the same shape, and the
output will also have that shape.

The `condition` tensor must be a scalar if `t` and `e` are scalars.
If `t` and `e` are vectors or higher rank, then `condition` must be either a
scalar, a vector with size matching the first dimension of `t`, or must have
the same shape as `t`.

The `condition` tensor acts as a mask that chooses, based on the value at each
element, whether the corresponding element / row in the output should be
taken from `t` (if true) or `e` (if false).

If `condition` is a vector and `t` and `e` are higher rank matrices, then
it chooses which row (outer dimension) to copy from `t` and `e`.
If `condition` has the same shape as `t` and `e`, then it chooses which
element to copy from `t` and `e`.

For example:

```prettyprint
# 'condition' tensor is [[True,  False]
#                        [False, True]]
# 't' is [[1, 2],
#         [3, 4]]
# 'e' is [[5, 6],
#         [7, 8]]
select(condition, t, e) ==> [[1, 6],
                             [7, 4]]


# 'condition' tensor is [True, False]
# 't' is [[1, 2],
#         [3, 4]]
# 'e' is [[5, 6],
#         [7, 8]]
select(condition, t, e) ==> [[1, 2],
                             [7, 8]]

```
"""
function select(v4784, v4785, v4786; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Select") 
                begin  
                    begin  
                        if v4784 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4784)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4784)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4785 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4785)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4785)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4786 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4786)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4786)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Select") 
    tf.Tensor(tf.Operation(desc))
end

"""
     matrix_inverse(input; adjoint=false)

Computes the inverse of one or more square invertible matrices or their

adjoints (conjugate transposes).

The input is a tensor of shape `[..., M, M]` whose inner-most 2 dimensions
form square matrices. The output is a tensor of the same shape as the input
containing the inverse for all input submatrices `[..., :, :]`.

The op uses LU decomposition with partial pivoting to compute the inverses.

If a matrix is not invertible there is no guarantee what the op does. It
may detect the condition and raise an exception or it may simply return a
garbage result.
"""
function matrix_inverse(v4787; name=nothing, adjoint=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("MatrixInverse") 
                begin  
                    begin  
                        if v4787 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4787)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4787)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if adjoint !== nothing 
                            desc["adjoint"] = adjoint
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "MatrixInverse") 
    tf.Tensor(tf.Operation(desc))
end

"""
     requantize(input, input_min, input_max, requested_output_min, requested_output_max)

Convert the quantized 'input' tensor into a lower-precision 'output', using the

output range specified with 'requested_output_min' and 'requested_output_max'.

[input_min, input_max] are scalar floats that specify the range for the float
interpretation of the 'input' data. For example, if input_min is -1.0f and
input_max is 1.0f, and we are dealing with quint16 quantized data, then a 0
value in the 16-bit data should be interpreted as -1.0f, and a 65535 means 1.0f.
"""
function requantize(v4788, v4789, v4790, v4791, v4792; name=nothing, Tinput=nothing, out_type=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Requantize") 
                begin  
                    begin  
                        if v4788 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4788)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4788)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4789 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4789)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4789)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4790 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4790)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4790)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4791 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4791)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4791)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4792 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4792)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4792)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if Tinput !== nothing 
                            desc["Tinput"] = Tinput
                        end
                    end
                    begin  
                        if out_type !== nothing 
                            desc["out_type"] = out_type
                        end
                    end
                end
            end), name, "Requantize") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2), tf.Tensor(op, 3))
    end
end

"""
     initialize_table_from_text_file(table_handle, filename; vocab_size=-1, delimiter=	)

Initializes a table from a text file.

It inserts one key-value pair into the table for each line of the file.
The key and value is extracted from the whole line content, elements from the
split line based on `delimiter` or the line number (starting from zero).
Where to extract the key and value from a line is specified by `key_index` and
`value_index`.

- A value of -1 means use the line number(starting from zero), expects `int64`.
- A value of -2 means use the whole line content, expects `string`.
- A value >= 0 means use the index (starting at zero) of the split line based
  on `delimiter`.
"""
function initialize_table_from_text_file(v4793, v4794; name=nothing, key_index=nothing, value_index=nothing, vocab_size=nothing, delimiter=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("InitializeTableFromTextFile") 
                begin  
                    begin  
                        if v4793 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4793)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4793)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4794 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4794)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4794)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if key_index !== nothing 
                            desc["key_index"] = key_index
                        end
                    end
                    begin  
                        if value_index !== nothing 
                            desc["value_index"] = value_index
                        end
                    end
                    begin  
                        if vocab_size !== nothing 
                            desc["vocab_size"] = vocab_size
                        end
                    end
                    begin  
                        if delimiter !== nothing 
                            desc["delimiter"] = delimiter
                        end
                    end
                end
            end), name, "InitializeTableFromTextFile") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     unstage(; container=, shared_name=)

Op is similar to a lightweight Dequeue.  The basic funtionality is similar to

dequeue with many fewer capabilities and options.  This Op is optimized for
performance.
"""
function unstage(; name=nothing, dtypes=nothing, container=nothing, shared_name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Unstage") 
                begin  
                end 
                begin  
                    begin  
                        if dtypes !== nothing 
                            desc["dtypes"] = dtypes
                        end
                    end
                    begin  
                        if container !== nothing 
                            desc["container"] = container
                        end
                    end
                    begin  
                        if shared_name !== nothing 
                            desc["shared_name"] = shared_name
                        end
                    end
                end
            end), name, "Unstage") 
    tf.Tensor(tf.Operation(desc))
end

"""
     sparse_apply_adagrad_da(var, gradient_accumulator, gradient_squared_accumulator, grad, indices, lr, l1, l2, global_step; use_locking=false)

Update entries in '*var' and '*accum' according to the proximal adagrad scheme.


"""
function sparse_apply_adagrad_da(v4795, v4796, v4797, v4798, v4799, v4800, v4801, v4802, v4803; name=nothing, T=nothing, Tindices=nothing, use_locking=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SparseApplyAdagradDA") 
                begin  
                    begin  
                        if v4795 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4795)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4795)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4796 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4796)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4796)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4797 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4797)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4797)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4798 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4798)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4798)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4799 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4799)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4799)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4800 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4800)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4800)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4801 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4801)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4801)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4802 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4802)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4802)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4803 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4803)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4803)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tindices !== nothing 
                            desc["Tindices"] = Tindices
                        end
                    end
                    begin  
                        if use_locking !== nothing 
                            desc["use_locking"] = use_locking
                        end
                    end
                end
            end), name, "SparseApplyAdagradDA") 
    tf.Tensor(tf.Operation(desc))
end

"""
     min(input, reduction_indices; keep_dims=false, Tidx=Int32)

Computes the minimum of elements across dimensions of a tensor.

Reduces `input` along the dimensions given in `reduction_indices`. Unless
`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in
`reduction_indices`. If `keep_dims` is true, the reduced dimensions are
retained with length 1.
"""
function min(v4804, v4805; name=nothing, keep_dims=nothing, T=nothing, Tidx=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Min") 
                begin  
                    begin  
                        if v4804 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4804)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4804)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4805 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4805)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4805)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if keep_dims !== nothing 
                            desc["keep_dims"] = keep_dims
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tidx !== nothing 
                            desc["Tidx"] = Tidx
                        end
                    end
                end
            end), name, "Min") 
    tf.Tensor(tf.Operation(desc))
end

"""
     lookup_table_size(table_handle)

Computes the number of elements in the given table.


"""
function lookup_table_size(v4806; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("LookupTableSize") 
                begin  
                    begin  
                        if v4806 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4806)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4806)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "LookupTableSize") 
    tf.Tensor(tf.Operation(desc))
end

"""
     fft(input)

Compute the 1-dimensional discrete Fourier Transform over the inner-most

dimension of `input`.
"""
function fft(v4807; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("FFT") 
                begin  
                    begin  
                        if v4807 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4807)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4807)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "FFT") 
    tf.Tensor(tf.Operation(desc))
end

"""
     fake_quant_with_min_max_args(inputs; min=nothing, max=nothing)

Fake-quantize the 'inputs' tensor, type float to 'outputs' tensor of same type.

Attributes [min; max] define the clamping range for the 'inputs' data.  Op
divides this range into 255 steps (total of 256 values), then replaces each
'inputs' value with the closest of the quantized step values.

Quantization is called fake since the output is still in floating point.
"""
function fake_quant_with_min_max_args(v4808; name=nothing, min=nothing, max=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("FakeQuantWithMinMaxArgs") 
                begin  
                    begin  
                        if v4808 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4808)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4808)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if min !== nothing 
                            desc["min"] = min
                        end
                    end
                    begin  
                        if max !== nothing 
                            desc["max"] = max
                        end
                    end
                end
            end), name, "FakeQuantWithMinMaxArgs") 
    tf.Tensor(tf.Operation(desc))
end

"""
     resource_apply_gradient_descent(var, alpha, delta; use_locking=false)

Update '*var' by subtracting 'alpha' * 'delta' from it.


"""
function resource_apply_gradient_descent(v4809, v4810, v4811; name=nothing, T=nothing, use_locking=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ResourceApplyGradientDescent") 
                begin  
                    begin  
                        if v4809 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4809)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4809)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4810 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4810)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4810)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4811 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4811)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4811)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if use_locking !== nothing 
                            desc["use_locking"] = use_locking
                        end
                    end
                end
            end), name, "ResourceApplyGradientDescent") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     relu_6g(gradients, features)

Computes rectified linear 6 gradients for a Relu6 operation.


"""
function relu_6g(v4812, v4813; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Relu6Grad") 
                begin  
                    begin  
                        if v4812 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4812)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4812)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4813 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4813)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4813)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Relu6Grad") 
    tf.Tensor(tf.Operation(desc))
end

"""
     lrng(input_grads, input_image, output_image; depth_radius=5, bias=nothing, alpha=nothing, beta=nothing, T=Float32)

Gradients for Local Response Normalization.


"""
function lrng(v4814, v4815, v4816; name=nothing, depth_radius=nothing, bias=nothing, alpha=nothing, beta=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("LRNGrad") 
                begin  
                    begin  
                        if v4814 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4814)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4814)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4815 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4815)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4815)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4816 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4816)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4816)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if depth_radius !== nothing 
                            desc["depth_radius"] = depth_radius
                        end
                    end
                    begin  
                        if bias !== nothing 
                            desc["bias"] = bias
                        end
                    end
                    begin  
                        if alpha !== nothing 
                            desc["alpha"] = alpha
                        end
                    end
                    begin  
                        if beta !== nothing 
                            desc["beta"] = beta
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "LRNGrad") 
    tf.Tensor(tf.Operation(desc))
end

"""
     broadcast_gradient_args(s0, s1; T=Int32)

Return the reduction indices for computing gradients of s0 op s1 with broadcast.

This is typically used by gradient computations for a broadcasting operation.
"""
function broadcast_gradient_args(v4817, v4818; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("BroadcastGradientArgs") 
                begin  
                    begin  
                        if v4817 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4817)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4817)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4818 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4818)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4818)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "BroadcastGradientArgs") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2))
    end
end

"""
     decode_raw(bytes; little_endian=true)

Reinterpret the bytes of a string as a vector of numbers.


"""
function decode_raw(v4819; name=nothing, out_type=nothing, little_endian=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("DecodeRaw") 
                begin  
                    begin  
                        if v4819 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4819)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4819)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if out_type !== nothing 
                            desc["out_type"] = out_type
                        end
                    end
                    begin  
                        if little_endian !== nothing 
                            desc["little_endian"] = little_endian
                        end
                    end
                end
            end), name, "DecodeRaw") 
    tf.Tensor(tf.Operation(desc))
end

"""
     fake_quant_with_min_max_vars_per_channel_gradient(gradients, inputs, min, max)

Compute gradients for a FakeQuantWithMinMaxVarsPerChannel operation.


"""
function fake_quant_with_min_max_vars_per_channel_gradient(v4820, v4821, v4822, v4823; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("FakeQuantWithMinMaxVarsPerChannelGradient") 
                begin  
                    begin  
                        if v4820 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4820)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4820)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4821 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4821)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4821)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4822 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4822)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4822)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4823 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4823)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4823)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "FakeQuantWithMinMaxVarsPerChannelGradient") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2), tf.Tensor(op, 3))
    end
end

"""
     initialize_table(table_handle, keys, values)

Table initializer that takes two tensors for keys and values respectively.


"""
function initialize_table(v4824, v4825, v4826; name=nothing, Tkey=nothing, Tval=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("InitializeTable") 
                begin  
                    begin  
                        if v4824 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4824)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4824)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4825 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4825)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4825)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4826 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4826)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4826)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if Tkey !== nothing 
                            desc["Tkey"] = Tkey
                        end
                    end
                    begin  
                        if Tval !== nothing 
                            desc["Tval"] = Tval
                        end
                    end
                end
            end), name, "InitializeTable") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     array_to_list(input)

Converts an array of tensors to a list of tensors.


"""
function array_to_list(v4827; name=nothing, T=nothing, N=nothing, out_types=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("_ArrayToList") 
                begin  
                    begin  
                        if v4827 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4827)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4827)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if N !== nothing 
                            desc["N"] = N
                        end
                    end
                    begin  
                        if out_types !== nothing 
                            desc["out_types"] = out_types
                        end
                    end
                end
            end), name, "_ArrayToList") 
    tf.Tensor(tf.Operation(desc))
end

"""
     fifoq(; shapes=Int64[], capacity=-1, container=, shared_name=)

A queue that produces elements in first-in first-out order.


"""
function fifoq(; name=nothing, component_types=nothing, shapes=nothing, capacity=nothing, container=nothing, shared_name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("FIFOQueue") 
                begin  
                end 
                begin  
                    begin  
                        if component_types !== nothing 
                            desc["component_types"] = component_types
                        end
                    end
                    begin  
                        if shapes !== nothing 
                            desc["shapes"] = shapes
                        end
                    end
                    begin  
                        if capacity !== nothing 
                            desc["capacity"] = capacity
                        end
                    end
                    begin  
                        if container !== nothing 
                            desc["container"] = container
                        end
                    end
                    begin  
                        if shared_name !== nothing 
                            desc["shared_name"] = shared_name
                        end
                    end
                end
            end), name, "FIFOQueue") 
    tf.Tensor(tf.Operation(desc))
end

"""
     expand_dims(input, dim; Tdim=Int32)

Inserts a dimension of 1 into a tensor's shape.

Given a tensor `input`, this operation inserts a dimension of 1 at the
dimension index `dim` of `input`'s shape. The dimension index `dim` starts at
zero; if you specify a negative number for `dim` it is counted backward from
the end.

This operation is useful if you want to add a batch dimension to a single
element. For example, if you have a single image of shape `[height, width,
channels]`, you can make it a batch of 1 image with `expand_dims(image, 0)`,
which will make the shape `[1, height, width, channels]`.

Other examples:

```prettyprint
# 't' is a tensor of shape [2]
shape(expand_dims(t, 0)) ==> [1, 2]
shape(expand_dims(t, 1)) ==> [2, 1]
shape(expand_dims(t, -1)) ==> [2, 1]

# 't2' is a tensor of shape [2, 3, 5]
shape(expand_dims(t2, 0)) ==> [1, 2, 3, 5]
shape(expand_dims(t2, 2)) ==> [2, 3, 1, 5]
shape(expand_dims(t2, 3)) ==> [2, 3, 5, 1]
```

This operation requires that:

`-1-input.dims() <= dim <= input.dims()`

This operation is related to `squeeze()`, which removes dimensions of
size 1.
"""
function expand_dims(v4828, v4829; name=nothing, T=nothing, Tdim=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ExpandDims") 
                begin  
                    begin  
                        if v4828 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4828)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4828)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4829 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4829)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4829)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tdim !== nothing 
                            desc["Tdim"] = Tdim
                        end
                    end
                end
            end), name, "ExpandDims") 
    tf.Tensor(tf.Operation(desc))
end

"""
     resource_sparse_apply_proximal_gradient_descent(var, alpha, l1, l2, grad, indices; use_locking=false)

Sparse update '*var' as FOBOS algorithm with fixed learning rate.

That is for rows we have grad for, we update var as follows:
prox_v = var - alpha * grad
var = sign(prox_v)/(1+alpha*l2) * max{|prox_v|-alpha*l1,0}
"""
function resource_sparse_apply_proximal_gradient_descent(v4830, v4831, v4832, v4833, v4834, v4835; name=nothing, T=nothing, Tindices=nothing, use_locking=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ResourceSparseApplyProximalGradientDescent") 
                begin  
                    begin  
                        if v4830 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4830)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4830)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4831 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4831)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4831)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4832 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4832)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4832)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4833 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4833)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4833)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4834 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4834)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4834)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4835 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4835)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4835)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tindices !== nothing 
                            desc["Tindices"] = Tindices
                        end
                    end
                    begin  
                        if use_locking !== nothing 
                            desc["use_locking"] = use_locking
                        end
                    end
                end
            end), name, "ResourceSparseApplyProximalGradientDescent") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     dilation_2d_backprop_filter(input, filter, out_backprop)

Computes the gradient of morphological 2-D dilation with respect to the filter.


"""
function dilation_2d_backprop_filter(v4836, v4837, v4838; name=nothing, T=nothing, strides=nothing, rates=nothing, padding=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Dilation2DBackpropFilter") 
                begin  
                    begin  
                        if v4836 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4836)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4836)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4837 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4837)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4837)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4838 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4838)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4838)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if strides !== nothing 
                            desc["strides"] = strides
                        end
                    end
                    begin  
                        if rates !== nothing 
                            desc["rates"] = rates
                        end
                    end
                    begin  
                        if padding !== nothing 
                            desc["padding"] = padding
                        end
                    end
                end
            end), name, "Dilation2DBackpropFilter") 
    tf.Tensor(tf.Operation(desc))
end

"""
     enter(data; is_constant=false, parallel_iterations=10)

Creates or finds a child frame, and makes `data` available to the child frame.

This op is used together with `Exit` to create loops in the graph.
The unique `frame_name` is used by the `Executor` to identify frames. If
`is_constant` is true, `output` is a constant in the child frame; otherwise
it may be changed in the child frame. At most `parallel_iterations` iterations
are run in parallel in the child frame.
"""
function enter(v4839; name=nothing, T=nothing, frame_name=nothing, is_constant=nothing, parallel_iterations=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Enter") 
                begin  
                    begin  
                        if v4839 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4839)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4839)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if frame_name !== nothing 
                            desc["frame_name"] = frame_name
                        end
                    end
                    begin  
                        if is_constant !== nothing 
                            desc["is_constant"] = is_constant
                        end
                    end
                    begin  
                        if parallel_iterations !== nothing 
                            desc["parallel_iterations"] = parallel_iterations
                        end
                    end
                end
            end), name, "Enter") 
    tf.Tensor(tf.Operation(desc))
end

"""
     inv_grad(x, y)

Computes the gradient for the inverse of `x` wrt its input.

Specifically, `grad = -dy * y*y`, where `y = 1/x`, and `dy`
is the corresponding input gradient.
"""
function inv_grad(v4840, v4841; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("InvGrad") 
                begin  
                    begin  
                        if v4840 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4840)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4840)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4841 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4841)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4841)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "InvGrad") 
    tf.Tensor(tf.Operation(desc))
end

"""
     non_max_suppression(boxes, scores, max_output_size; iou_threshold=nothing)

Greedily selects a subset of bounding boxes in descending order of score,

pruning away boxes that have high intersection-over-union (IOU) overlap
with previously selected boxes.  Bounding boxes are supplied as
[y1, x1, y2, x2], where (y1, x1) and (y2, x2) are the coordinates of any
diagonal pair of box corners and the coordinates can be provided as normalized
(i.e., lying in the interval [0, 1]) or absolute.  Note that this algorithm
is agnostic to where the origin is in the coordinate system.  Note that this
algorithm is invariant to orthogonal transformations and translations
of the coordinate system; thus translating or reflections of the coordinate
system result in the same boxes being selected by the algorithm.

The output of this operation is a set of integers indexing into the input
collection of bounding boxes representing the selected boxes.  The bounding
box coordinates corresponding to the selected indices can then be obtained
using the `tf.gather operation`.  For example:

  selected_indices = tf.image.non_max_suppression(
      boxes, scores, max_output_size, iou_threshold)
  selected_boxes = tf.gather(boxes, selected_indices)
"""
function non_max_suppression(v4842, v4843, v4844; name=nothing, iou_threshold=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("NonMaxSuppression") 
                begin  
                    begin  
                        if v4842 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4842)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4842)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4843 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4843)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4843)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4844 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4844)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4844)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if iou_threshold !== nothing 
                            desc["iou_threshold"] = iou_threshold
                        end
                    end
                end
            end), name, "NonMaxSuppression") 
    tf.Tensor(tf.Operation(desc))
end

"""
     tanh(x)

Computes hyperbolic tangent of `x` element-wise.


"""
function tanh(v4845; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Tanh") 
                begin  
                    begin  
                        if v4845 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4845)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4845)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Tanh") 
    tf.Tensor(tf.Operation(desc))
end

"""
     tan(x)

Computes tan of x element-wise.


"""
function tan(v4846; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Tan") 
                begin  
                    begin  
                        if v4846 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4846)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4846)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Tan") 
    tf.Tensor(tf.Operation(desc))
end

"""
     bias_add_grad(out_backprop; data_format=NHWC)

The backward operation for "BiasAdd" on the "bias" tensor.

It accumulates all the values from out_backprop into the feature dimension.
For NHWC data format, the feature dimension is the last. For NCHW data format,
the feature dimension is the third-to-last.
"""
function bias_add_grad(v4847; name=nothing, T=nothing, data_format=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("BiasAddGrad") 
                begin  
                    begin  
                        if v4847 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4847)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4847)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if data_format !== nothing 
                            desc["data_format"] = data_format
                        end
                    end
                end
            end), name, "BiasAddGrad") 
    tf.Tensor(tf.Operation(desc))
end

"""
     symbolic_gradient(input)

Computes the gradient function for function f via backpropagation.


"""
function symbolic_gradient(v4848; name=nothing, Tin=nothing, Tout=nothing, f=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SymbolicGradient") 
                begin  
                    begin  
                        if v4848 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4848)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4848)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if Tin !== nothing 
                            desc["Tin"] = Tin
                        end
                    end
                    begin  
                        if Tout !== nothing 
                            desc["Tout"] = Tout
                        end
                    end
                    begin  
                        if f !== nothing 
                            desc["f"] = f
                        end
                    end
                end
            end), name, "SymbolicGradient") 
    tf.Tensor(tf.Operation(desc))
end

"""
     reader_serialize_state_v2(reader_handle)

Produce a string tensor that encodes the state of a Reader.

Not all Readers support being serialized, so this can produce an
Unimplemented error.
"""
function reader_serialize_state_v2(v4849; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ReaderSerializeStateV2") 
                begin  
                    begin  
                        if v4849 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4849)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4849)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "ReaderSerializeStateV2") 
    tf.Tensor(tf.Operation(desc))
end

"""
     square(x)

Computes square of x element-wise.

I.e., \\(y = x * x = x^2\\).
"""
function square(v4850; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Square") 
                begin  
                    begin  
                        if v4850 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4850)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4850)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Square") 
    tf.Tensor(tf.Operation(desc))
end

"""
     l_2l(t)

L2 Loss.

Computes half the L2 norm of a tensor without the `sqrt`:

    output = sum(t ** 2) / 2
"""
function l_2l(v4851; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("L2Loss") 
                begin  
                    begin  
                        if v4851 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4851)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4851)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "L2Loss") 
    tf.Tensor(tf.Operation(desc))
end

"""
     resize_area(images, size; align_corners=false)

Resize `images` to `size` using area interpolation.

Input images can be of different types but output images are always float.
"""
function resize_area(v4852, v4853; name=nothing, T=nothing, align_corners=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ResizeArea") 
                begin  
                    begin  
                        if v4852 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4852)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4852)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4853 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4853)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4853)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if align_corners !== nothing 
                            desc["align_corners"] = align_corners
                        end
                    end
                end
            end), name, "ResizeArea") 
    tf.Tensor(tf.Operation(desc))
end

"""
     batch_fft_3d(input)




"""
function batch_fft_3d(v4854; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("BatchFFT3D") 
                begin  
                    begin  
                        if v4854 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4854)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4854)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "BatchFFT3D") 
    tf.Tensor(tf.Operation(desc))
end

"""
     apply_adadelta(var, accum, accum_update, lr, rho, epsilon, grad; use_locking=false)

Update '*var' according to the adadelta scheme.

accum = rho() * accum + (1 - rho()) * grad.square();
update = (update_accum + epsilon).sqrt() * (accum + epsilon()).rsqrt() * grad;
update_accum = rho() * update_accum + (1 - rho()) * update.square();
var -= update;
"""
function apply_adadelta(v4855, v4856, v4857, v4858, v4859, v4860, v4861; name=nothing, T=nothing, use_locking=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ApplyAdadelta") 
                begin  
                    begin  
                        if v4855 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4855)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4855)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4856 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4856)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4856)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4857 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4857)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4857)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4858 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4858)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4858)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4859 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4859)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4859)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4860 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4860)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4860)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4861 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4861)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4861)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if use_locking !== nothing 
                            desc["use_locking"] = use_locking
                        end
                    end
                end
            end), name, "ApplyAdadelta") 
    tf.Tensor(tf.Operation(desc))
end

"""
     depthwise_conv_2d_native_backprop_input(input_sizes, filter, out_backprop; data_format=NHWC)

Computes the gradients of depthwise convolution with respect to the input.


"""
function depthwise_conv_2d_native_backprop_input(v4862, v4863, v4864; name=nothing, T=nothing, strides=nothing, padding=nothing, data_format=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("DepthwiseConv2dNativeBackpropInput") 
                begin  
                    begin  
                        if v4862 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4862)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4862)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4863 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4863)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4863)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4864 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4864)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4864)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if strides !== nothing 
                            desc["strides"] = strides
                        end
                    end
                    begin  
                        if padding !== nothing 
                            desc["padding"] = padding
                        end
                    end
                    begin  
                        if data_format !== nothing 
                            desc["data_format"] = data_format
                        end
                    end
                end
            end), name, "DepthwiseConv2dNativeBackpropInput") 
    tf.Tensor(tf.Operation(desc))
end

"""
     resource_apply_rmsp(var, ms, mom, lr, rho, momentum, epsilon, grad; use_locking=false)

Update '*var' according to the RMSProp algorithm.

Note that in dense implementation of this algorithm, ms and mom will
update even if the grad is zero, but in this sparse implementation, ms
and mom will not update in iterations during which the grad is zero.

mean_square = decay * mean_square + (1-decay) * gradient ** 2
Delta = learning_rate * gradient / sqrt(mean_square + epsilon)

ms <- rho * ms_{t-1} + (1-rho) * grad * grad
mom <- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)
var <- var - mom
"""
function resource_apply_rmsp(v4865, v4866, v4867, v4868, v4869, v4870, v4871, v4872; name=nothing, T=nothing, use_locking=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ResourceApplyRMSProp") 
                begin  
                    begin  
                        if v4865 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4865)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4865)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4866 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4866)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4866)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4867 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4867)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4867)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4868 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4868)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4868)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4869 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4869)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4869)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4870 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4870)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4870)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4871 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4871)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4871)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4872 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4872)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4872)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if use_locking !== nothing 
                            desc["use_locking"] = use_locking
                        end
                    end
                end
            end), name, "ResourceApplyRMSProp") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     audio_summary(tag, tensor; max_outputs=3)

Outputs a `Summary` protocol buffer with audio.

The summary has up to `max_outputs` summary values containing audio. The
audio is built from `tensor` which must be 3-D with shape `[batch_size,
frames, channels]` or 2-D with shape `[batch_size, frames]`. The values are
assumed to be in the range of `[-1.0, 1.0]` with a sample rate of `sample_rate`.

The `tag` argument is a scalar `Tensor` of type `string`.  It is used to
build the `tag` of the summary values:

*  If `max_outputs` is 1, the summary value tag is '*tag*/audio'.
*  If `max_outputs` is greater than 1, the summary value tags are
   generated sequentially as '*tag*/audio/0', '*tag*/audio/1', etc.
"""
function audio_summary(v4873, v4874; name=nothing, sample_rate=nothing, max_outputs=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("AudioSummary") 
                begin  
                    begin  
                        if v4873 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4873)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4873)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4874 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4874)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4874)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if sample_rate !== nothing 
                            desc["sample_rate"] = sample_rate
                        end
                    end
                    begin  
                        if max_outputs !== nothing 
                            desc["max_outputs"] = max_outputs
                        end
                    end
                end
            end), name, "AudioSummary") 
    tf.Tensor(tf.Operation(desc))
end

"""
     squared_difference(x, y)

Returns (x - y)(x - y) element-wise.

*NOTE*: `SquaredDifference` supports broadcasting. More about broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
"""
function squared_difference(v4875, v4876; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SquaredDifference") 
                begin  
                    begin  
                        if v4875 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4875)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4875)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4876 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4876)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4876)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "SquaredDifference") 
    tf.Tensor(tf.Operation(desc))
end

"""
     apply_momentum(var, accum, lr, grad, momentum; use_locking=false, use_nesterov=false)

Update '*var' according to the momentum scheme. Set use_nesterov = True if you

want to use Nesterov momentum.

accum = accum * momentum + grad
var -= lr * accum
"""
function apply_momentum(v4877, v4878, v4879, v4880, v4881; name=nothing, T=nothing, use_locking=nothing, use_nesterov=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ApplyMomentum") 
                begin  
                    begin  
                        if v4877 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4877)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4877)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4878 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4878)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4878)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4879 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4879)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4879)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4880 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4880)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4880)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4881 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4881)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4881)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if use_locking !== nothing 
                            desc["use_locking"] = use_locking
                        end
                    end
                    begin  
                        if use_nesterov !== nothing 
                            desc["use_nesterov"] = use_nesterov
                        end
                    end
                end
            end), name, "ApplyMomentum") 
    tf.Tensor(tf.Operation(desc))
end

"""
     reader_read(reader_handle, queue_handle)

Returns the next record (key, value pair) produced by a Reader.

Will dequeue from the input queue if necessary (e.g. when the
Reader needs to start reading from a new file since it has finished
with the previous file).
"""
function reader_read(v4882, v4883; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ReaderRead") 
                begin  
                    begin  
                        if v4882 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4882)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4882)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4883 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4883)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4883)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "ReaderRead") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2))
    end
end

"""
     scatter_nd_update(ref, indices, updates; use_locking=true)

Applies sparse `updates` to individual values or slices within a given

variable according to `indices`.

`ref` is a `Tensor` with rank `P` and `indices` is a `Tensor` of rank `Q`.

`indices` must be integer tensor, containing indices into `ref`.
It must be shape `[d_0, ..., d_{Q-2}, K]` where `0 < K <= P`.

The innermost dimension of `indices` (with length `K`) corresponds to
indices into elements (if `K = P`) or slices (if `K < P`) along the `K`th
dimension of `ref`.

`updates` is `Tensor` of rank `Q-1+P-K` with shape:

```
[d_0, ..., d_{Q-2}, ref.shape[K], ..., ref.shape[P-1]].
```

For example, say we want to update 4 scattered elements to a rank-1 tensor to
8 elements. In Python, that update would look like this:

    ref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8])
    indices = tf.constant([[4], [3], [1] ,[7]])
    updates = tf.constant([9, 10, 11, 12])
    update = tf.scatter_nd_update(ref, indices, updates)
    with tf.Session() as sess:
      print sess.run(update)

The resulting update to ref would look like this:

    [1, 11, 3, 10, 9, 6, 7, 12]

See [tf.scatter_nd](#scatter_nd) for more details about how to make updates to
slices.
"""
function scatter_nd_update(v4884, v4885, v4886; name=nothing, T=nothing, Tindices=nothing, use_locking=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ScatterNdUpdate") 
                begin  
                    begin  
                        if v4884 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4884)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4884)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4885 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4885)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4885)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4886 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4886)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4886)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tindices !== nothing 
                            desc["Tindices"] = Tindices
                        end
                    end
                    begin  
                        if use_locking !== nothing 
                            desc["use_locking"] = use_locking
                        end
                    end
                end
            end), name, "ScatterNdUpdate") 
    tf.Tensor(tf.Operation(desc))
end

"""
     dynamic_stitch(indices, data)

Interleave the values from the `data` tensors into a single tensor.

Builds a merged tensor such that

```python
    merged[indices[m][i, ..., j], ...] = data[m][i, ..., j, ...]
```

For example, if each `indices[m]` is scalar or vector, we have

```python
    # Scalar indices:
    merged[indices[m], ...] = data[m][...]

    # Vector indices:
    merged[indices[m][i], ...] = data[m][i, ...]
```

Each `data[i].shape` must start with the corresponding `indices[i].shape`,
and the rest of `data[i].shape` must be constant w.r.t. `i`.  That is, we
must have `data[i].shape = indices[i].shape + constant`.  In terms of this
`constant`, the output shape is

    merged.shape = [max(indices)] + constant

Values are merged in order, so if an index appears in both `indices[m][i]` and
`indices[n][j]` for `(m,i) < (n,j)` the slice `data[n][j]` will appear in the
merged result.

For example:

```python
    indices[0] = 6
    indices[1] = [4, 1]
    indices[2] = [[5, 2], [0, 3]]
    data[0] = [61, 62]
    data[1] = [[41, 42], [11, 12]]
    data[2] = [[[51, 52], [21, 22]], [[1, 2], [31, 32]]]
    merged = [[1, 2], [11, 12], [21, 22], [31, 32], [41, 42],
              [51, 52], [61, 62]]
```

<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="../../images/DynamicStitch.png" alt>
</div>
"""
function dynamic_stitch(v4887, v4888; name=nothing, N=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("DynamicStitch") 
                begin  
                    begin  
                        if v4887 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4887)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4887)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4888 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4888)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4888)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if N !== nothing 
                            desc["N"] = N
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "DynamicStitch") 
    tf.Tensor(tf.Operation(desc))
end

"""
     sparse_accumulator_take_gradient(handle, num_required)

Extracts the average sparse gradient in the given SparseConditionalAccumulator,

provided that sufficient (i.e., more than num_required) gradients have been
accumulated. The op will blocks until sufficient gradients have been
accumulated. If the accumulator has already aggregated more than num_required
gradients, it will return its average of the accumulated gradients.
Also automatically increments the recorded global_step in the accumulator by 1,
and resets the aggregate to 0.
"""
function sparse_accumulator_take_gradient(v4889, v4890; name=nothing, dtype=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SparseAccumulatorTakeGradient") 
                begin  
                    begin  
                        if v4889 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4889)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4889)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4890 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4890)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4890)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if dtype !== nothing 
                            desc["dtype"] = dtype
                        end
                    end
                end
            end), name, "SparseAccumulatorTakeGradient") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2), tf.Tensor(op, 3))
    end
end

"""
     fractional_max_pool_grad(orig_input, orig_output, out_backprop, row_pooling_sequence, col_pooling_sequence; overlapping=false)

Computes gradient of the FractionalMaxPool function.


"""
function fractional_max_pool_grad(v4891, v4892, v4893, v4894, v4895; name=nothing, overlapping=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("FractionalMaxPoolGrad") 
                begin  
                    begin  
                        if v4891 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4891)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4891)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4892 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4892)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4892)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4893 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4893)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4893)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4894 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4894)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4894)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4895 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4895)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4895)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if overlapping !== nothing 
                            desc["overlapping"] = overlapping
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "FractionalMaxPoolGrad") 
    tf.Tensor(tf.Operation(desc))
end

"""
     accumulator_set_global_step(handle, new_global_step)

Updates the accumulator with a new value for global_step. Logs warning if the

accumulator's value is already higher than new_global_step.
"""
function accumulator_set_global_step(v4896, v4897; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("AccumulatorSetGlobalStep") 
                begin  
                    begin  
                        if v4896 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4896)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4896)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4897 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4897)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4897)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "AccumulatorSetGlobalStep") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     random_standard_normal(shape; seed=0, seed2=0)

Outputs random values from a normal distribution.

The generated values will have mean 0 and standard deviation 1.
"""
function random_standard_normal(v4898; name=nothing, seed=nothing, seed2=nothing, dtype=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("RandomStandardNormal") 
                begin  
                    begin  
                        if v4898 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4898)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4898)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if seed !== nothing 
                            desc["seed"] = seed
                        end
                    end
                    begin  
                        if seed2 !== nothing 
                            desc["seed2"] = seed2
                        end
                    end
                    begin  
                        if dtype !== nothing 
                            desc["dtype"] = dtype
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "RandomStandardNormal") 
    tf.Tensor(tf.Operation(desc))
end

"""
     gather(params, indices; validate_indices=true)

Gather slices from `params` according to `indices`.

`indices` must be an integer tensor of any dimension (usually 0-D or 1-D).
Produces an output tensor with shape `indices.shape + params.shape[1:]` where:

```python
    # Scalar indices
    output[:, ..., :] = params[indices, :, ... :]

    # Vector indices
    output[i, :, ..., :] = params[indices[i], :, ... :]

    # Higher rank indices
    output[i, ..., j, :, ... :] = params[indices[i, ..., j], :, ..., :]
```

If `indices` is a permutation and `len(indices) == params.shape[0]` then
this operation will permute `params` accordingly.

<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="../../images/Gather.png" alt>
</div>
"""
function gather(v4899, v4900; name=nothing, validate_indices=nothing, Tparams=nothing, Tindices=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Gather") 
                begin  
                    begin  
                        if v4899 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4899)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4899)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4900 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4900)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4900)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if validate_indices !== nothing 
                            desc["validate_indices"] = validate_indices
                        end
                    end
                    begin  
                        if Tparams !== nothing 
                            desc["Tparams"] = Tparams
                        end
                    end
                    begin  
                        if Tindices !== nothing 
                            desc["Tindices"] = Tindices
                        end
                    end
                end
            end), name, "Gather") 
    tf.Tensor(tf.Operation(desc))
end

"""
     quantized_mat_mul(a, b, min_a, max_a, min_b, max_b; Toutput=?, transpose_a=false, transpose_b=false, Tactivation=?)

Perform a quantized matrix multiplication of  `a` by the matrix `b`.

The inputs must be two-dimensional matrices and the inner dimension of
`a` (after being transposed if `transpose_a` is non-zero) must match the
outer dimension of `b` (after being transposed if `transposed_b` is
non-zero).
"""
function quantized_mat_mul(v4901, v4902, v4903, v4904, v4905, v4906; name=nothing, T1=nothing, T2=nothing, Toutput=nothing, transpose_a=nothing, transpose_b=nothing, Tactivation=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("QuantizedMatMul") 
                begin  
                    begin  
                        if v4901 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4901)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4901)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4902 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4902)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4902)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4903 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4903)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4903)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4904 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4904)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4904)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4905 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4905)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4905)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4906 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4906)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4906)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T1 !== nothing 
                            desc["T1"] = T1
                        end
                    end
                    begin  
                        if T2 !== nothing 
                            desc["T2"] = T2
                        end
                    end
                    begin  
                        if Toutput !== nothing 
                            desc["Toutput"] = Toutput
                        end
                    end
                    begin  
                        if transpose_a !== nothing 
                            desc["transpose_a"] = transpose_a
                        end
                    end
                    begin  
                        if transpose_b !== nothing 
                            desc["transpose_b"] = transpose_b
                        end
                    end
                    begin  
                        if Tactivation !== nothing 
                            desc["Tactivation"] = Tactivation
                        end
                    end
                end
            end), name, "QuantizedMatMul") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2), tf.Tensor(op, 3))
    end
end

"""
     resource_apply_adagrad_da(var, gradient_accumulator, gradient_squared_accumulator, grad, lr, l1, l2, global_step; use_locking=false)

Update '*var' according to the proximal adagrad scheme.


"""
function resource_apply_adagrad_da(v4907, v4908, v4909, v4910, v4911, v4912, v4913, v4914; name=nothing, T=nothing, use_locking=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ResourceApplyAdagradDA") 
                begin  
                    begin  
                        if v4907 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4907)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4907)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4908 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4908)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4908)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4909 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4909)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4909)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4910 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4910)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4910)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4911 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4911)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4911)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4912 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4912)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4912)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4913 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4913)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4913)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4914 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4914)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4914)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if use_locking !== nothing 
                            desc["use_locking"] = use_locking
                        end
                    end
                end
            end), name, "ResourceApplyAdagradDA") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     accumulator_apply_gradient(handle, local_step, gradient)

Applies a gradient to a given accumulator. Does not add if local_step is lesser

than the accumulator's global_step.
"""
function accumulator_apply_gradient(v4915, v4916, v4917; name=nothing, dtype=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("AccumulatorApplyGradient") 
                begin  
                    begin  
                        if v4915 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4915)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4915)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4916 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4916)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4916)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4917 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4917)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4917)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if dtype !== nothing 
                            desc["dtype"] = dtype
                        end
                    end
                end
            end), name, "AccumulatorApplyGradient") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     squeeze(input; squeeze_dims=Int64[])

Removes dimensions of size 1 from the shape of a tensor.

Given a tensor `input`, this operation returns a tensor of the same type with
all dimensions of size 1 removed. If you don't want to remove all size 1
dimensions, you can remove specific size 1 dimensions by specifying
`squeeze_dims`.

For example:

```prettyprint
# 't' is a tensor of shape [1, 2, 1, 3, 1, 1]
shape(squeeze(t)) ==> [2, 3]
```

Or, to remove specific size 1 dimensions:

```prettyprint
# 't' is a tensor of shape [1, 2, 1, 3, 1, 1]
shape(squeeze(t, [2, 4])) ==> [1, 2, 3, 1]
```
"""
function squeeze(v4918; name=nothing, T=nothing, squeeze_dims=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Squeeze") 
                begin  
                    begin  
                        if v4918 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4918)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4918)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if squeeze_dims !== nothing 
                            desc["squeeze_dims"] = squeeze_dims
                        end
                    end
                end
            end), name, "Squeeze") 
    tf.Tensor(tf.Operation(desc))
end

"""
     sdca_optimizer(sparse_example_indices, sparse_feature_indices, sparse_feature_values, dense_features, example_weights, example_labels, sparse_indices, sparse_weights, dense_weights, example_state_data; adaptative=false)

Distributed version of Stochastic Dual Coordinate Ascent (SDCA) optimizer for

linear models with L1 + L2 regularization. As global optimization objective is
strongly-convex, the optimizer optimizes the dual objective at each step. The
optimizer applies each update one example at a time. Examples are sampled
uniformly, and the optimizer is learning rate free and enjoys linear convergence
rate.

Proximal Stochastic Dual Coordinate Ascent, Shalev-Shwartz, Shai; Zhang, Tong.
2012 arXiv1211.2717S: http://arxiv.org/pdf/1211.2717v1.pdf

  Loss objective = \sum f_{i}(wx_{i}) + (l2 / 2) * |w|^2 + l1 * |w|

Adding vs. Averaging in Distributed Primal-Dual Optimization.
Chenxin Ma, Virginia Smith, Martin Jaggi, Michael I. Jordan, Peter Richtarik,
Martin Takac http://arxiv.org/abs/1502.03508

Stochastic Dual Coordinate Ascent with Adaptive Probabilities
Dominik Csiba, Zheng Qu, Peter Richtarik https://arxiv.org/abs/1502.08053
"""
function sdca_optimizer(v4919, v4920, v4921, v4922, v4923, v4924, v4925, v4926, v4927, v4928; name=nothing, loss_type=nothing, adaptative=nothing, num_sparse_features=nothing, num_sparse_features_with_values=nothing, num_dense_features=nothing, l1=nothing, l2=nothing, num_loss_partitions=nothing, num_inner_iterations=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SdcaOptimizer") 
                begin  
                    begin  
                        if v4919 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4919)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4919)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4920 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4920)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4920)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4921 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4921)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4921)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4922 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4922)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4922)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4923 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4923)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4923)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4924 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4924)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4924)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4925 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4925)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4925)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4926 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4926)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4926)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4927 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4927)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4927)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4928 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4928)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4928)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if loss_type !== nothing 
                            desc["loss_type"] = loss_type
                        end
                    end
                    begin  
                        if adaptative !== nothing 
                            desc["adaptative"] = adaptative
                        end
                    end
                    begin  
                        if num_sparse_features !== nothing 
                            desc["num_sparse_features"] = num_sparse_features
                        end
                    end
                    begin  
                        if num_sparse_features_with_values !== nothing 
                            desc["num_sparse_features_with_values"] = num_sparse_features_with_values
                        end
                    end
                    begin  
                        if num_dense_features !== nothing 
                            desc["num_dense_features"] = num_dense_features
                        end
                    end
                    begin  
                        if l1 !== nothing 
                            desc["l1"] = l1
                        end
                    end
                    begin  
                        if l2 !== nothing 
                            desc["l2"] = l2
                        end
                    end
                    begin  
                        if num_loss_partitions !== nothing 
                            desc["num_loss_partitions"] = num_loss_partitions
                        end
                    end
                    begin  
                        if num_inner_iterations !== nothing 
                            desc["num_inner_iterations"] = num_inner_iterations
                        end
                    end
                end
            end), name, "SdcaOptimizer") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2), tf.Tensor(op, 3))
    end
end

"""
     matrix_diag_part(input)

Returns the batched diagonal part of a batched tensor.

This operation returns a tensor with the `diagonal` part
of the batched `input`. The `diagonal` part is computed as follows:

Assume `input` has `k` dimensions `[I, J, K, ..., M, N]`, then the output is a
tensor of rank `k - 1` with dimensions `[I, J, K, ..., min(M, N)]` where:

`diagonal[i, j, k, ..., n] = input[i, j, k, ..., n, n]`.

The input must be at least a matrix.

For example:

```prettyprint
# 'input' is [[[1, 0, 0, 0]
               [0, 2, 0, 0]
               [0, 0, 3, 0]
               [0, 0, 0, 4]],
              [[5, 0, 0, 0]
               [0, 6, 0, 0]
               [0, 0, 7, 0]
               [0, 0, 0, 8]]]

and input.shape = (2, 4, 4)

tf.matrix_diag_part(input) ==> [[1, 2, 3, 4], [5, 6, 7, 8]]

which has shape (2, 4)
```
"""
function matrix_diag_part(v4929; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("MatrixDiagPart") 
                begin  
                    begin  
                        if v4929 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4929)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4929)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "MatrixDiagPart") 
    tf.Tensor(tf.Operation(desc))
end

"""
     no_op()

Does nothing. Only useful as a placeholder for control edges.


"""
function no_op(; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("NoOp") 
                begin  
                end 
                begin  
                end
            end), name, "NoOp") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     quantized_conv_2d(input, filter, min_input, max_input, min_filter, max_filter; out_type=?)

Computes a 2D convolution given quantized 4D input and filter tensors.

The inputs are quantized tensors where the lowest value represents the real
number of the associated minimum, and the highest represents the maximum.
This means that you can only interpret the quantized output in the same way, by
taking the returned minimum and maximum values into account.
"""
function quantized_conv_2d(v4930, v4931, v4932, v4933, v4934, v4935; name=nothing, Tinput=nothing, Tfilter=nothing, out_type=nothing, strides=nothing, padding=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("QuantizedConv2D") 
                begin  
                    begin  
                        if v4930 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4930)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4930)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4931 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4931)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4931)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4932 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4932)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4932)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4933 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4933)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4933)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4934 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4934)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4934)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4935 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4935)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4935)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if Tinput !== nothing 
                            desc["Tinput"] = Tinput
                        end
                    end
                    begin  
                        if Tfilter !== nothing 
                            desc["Tfilter"] = Tfilter
                        end
                    end
                    begin  
                        if out_type !== nothing 
                            desc["out_type"] = out_type
                        end
                    end
                    begin  
                        if strides !== nothing 
                            desc["strides"] = strides
                        end
                    end
                    begin  
                        if padding !== nothing 
                            desc["padding"] = padding
                        end
                    end
                end
            end), name, "QuantizedConv2D") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2), tf.Tensor(op, 3))
    end
end

"""
     identity_reader_v2(; container=, shared_name=)

A Reader that outputs the queued work as both the key and value.

To use, enqueue strings in a Queue.  ReaderRead will take the front
work string and output (work, work).
"""
function identity_reader_v2(; name=nothing, container=nothing, shared_name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("IdentityReaderV2") 
                begin  
                end 
                begin  
                    begin  
                        if container !== nothing 
                            desc["container"] = container
                        end
                    end
                    begin  
                        if shared_name !== nothing 
                            desc["shared_name"] = shared_name
                        end
                    end
                end
            end), name, "IdentityReaderV2") 
    tf.Tensor(tf.Operation(desc))
end

"""
     zeta(x, q)

Compute the Hurwitz zeta function \\(\zeta(x, q)\\).

The Hurwitz zeta function is defined as:

```
\zeta(x, q) = \sum_{n=0}^{\infty} (q + n)^{-x}
```
"""
function zeta(v4936, v4937; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Zeta") 
                begin  
                    begin  
                        if v4936 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4936)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4936)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4937 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4937)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4937)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Zeta") 
    tf.Tensor(tf.Operation(desc))
end

"""
     reader_num_work_units_completed_v2(reader_handle)

Returns the number of work units this Reader has finished processing.


"""
function reader_num_work_units_completed_v2(v4938; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ReaderNumWorkUnitsCompletedV2") 
                begin  
                    begin  
                        if v4938 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4938)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4938)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "ReaderNumWorkUnitsCompletedV2") 
    tf.Tensor(tf.Operation(desc))
end

"""
     resource_apply_momentum(var, accum, lr, grad, momentum; use_locking=false, use_nesterov=false)

Update '*var' according to the momentum scheme. Set use_nesterov = True if you

want to use Nesterov momentum.

accum = accum * momentum + grad
var -= lr * accum
"""
function resource_apply_momentum(v4939, v4940, v4941, v4942, v4943; name=nothing, T=nothing, use_locking=nothing, use_nesterov=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("ResourceApplyMomentum") 
                begin  
                    begin  
                        if v4939 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4939)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4939)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4940 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4940)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4940)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4941 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4941)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4941)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4942 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4942)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4942)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4943 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4943)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4943)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if use_locking !== nothing 
                            desc["use_locking"] = use_locking
                        end
                    end
                    begin  
                        if use_nesterov !== nothing 
                            desc["use_nesterov"] = use_nesterov
                        end
                    end
                end
            end), name, "ResourceApplyMomentum") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     log_1p(x)

Computes natural logarithm of (1 + x) element-wise.

I.e., \\(y = \log_e (1 + x)\\).
"""
function log_1p(v4944; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Log1p") 
                begin  
                    begin  
                        if v4944 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4944)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4944)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Log1p") 
    tf.Tensor(tf.Operation(desc))
end

"""
     sparse_to_dense(sparse_indices, output_shape, sparse_values, default_value; validate_indices=true)

Converts a sparse representation into a dense tensor.

Builds an array `dense` with shape `output_shape` such that

```prettyprint
# If sparse_indices is scalar
dense[i] = (i == sparse_indices ? sparse_values : default_value)

# If sparse_indices is a vector, then for each i
dense[sparse_indices[i]] = sparse_values[i]

# If sparse_indices is an n by d matrix, then for each i in [0, n)
dense[sparse_indices[i][0], ..., sparse_indices[i][d-1]] = sparse_values[i]
```

All other values in `dense` are set to `default_value`.  If `sparse_values` is a
scalar, all sparse indices are set to this single value.

Indices should be sorted in lexicographic order, and indices must not
contain any repeats. If `validate_indices` is true, these properties
are checked during execution.
"""
function sparse_to_dense(v4945, v4946, v4947, v4948; name=nothing, validate_indices=nothing, T=nothing, Tindices=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SparseToDense") 
                begin  
                    begin  
                        if v4945 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4945)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4945)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4946 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4946)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4946)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4947 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4947)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4947)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4948 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4948)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4948)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if validate_indices !== nothing 
                            desc["validate_indices"] = validate_indices
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tindices !== nothing 
                            desc["Tindices"] = Tindices
                        end
                    end
                end
            end), name, "SparseToDense") 
    tf.Tensor(tf.Operation(desc))
end

"""
     sample_distorted_bounding_box(image_size, bounding_boxes; seed=0, seed2=0, min_object_covered=nothing, aspect_ratio_range=Int64[], area_range=Int64[], max_attempts=100, use_image_if_no_bounding_boxes=false)

Generate a single randomly distorted bounding box for an image.

Bounding box annotations are often supplied in addition to ground-truth labels
in image recognition or object localization tasks. A common technique for
training such a system is to randomly distort an image while preserving
its content, i.e. *data augmentation*. This Op outputs a randomly distorted
localization of an object, i.e. bounding box, given an `image_size`,
`bounding_boxes` and a series of constraints.

The output of this Op is a single bounding box that may be used to crop the
original image. The output is returned as 3 tensors: `begin`, `size` and
`bboxes`. The first 2 tensors can be fed directly into `tf.slice` to crop the
image. The latter may be supplied to `tf.image.draw_bounding_boxes` to visualize
what the bounding box looks like.

Bounding boxes are supplied and returned as `[y_min, x_min, y_max, x_max]`. The
bounding box coordinates are floats in `[0.0, 1.0]` relative to the width and
height of the underlying image.

For example,

```python
    # Generate a single distorted bounding box.
    begin, size, bbox_for_draw = tf.image.sample_distorted_bounding_box(
        tf.shape(image),
        bounding_boxes=bounding_boxes)

    # Draw the bounding box in an image summary.
    image_with_box = tf.image.draw_bounding_boxes(tf.expand_dims(image, 0),
                                                  bbox_for_draw)
    tf.image_summary('images_with_box', image_with_box)

    # Employ the bounding box to distort the image.
    distorted_image = tf.slice(image, begin, size)
```

Note that if no bounding box information is available, setting
`use_image_if_no_bounding_boxes = true` will assume there is a single implicit
bounding box covering the whole image. If `use_image_if_no_bounding_boxes` is
false and no bounding boxes are supplied, an error is raised.
"""
function sample_distorted_bounding_box(v4949, v4950; name=nothing, T=nothing, seed=nothing, seed2=nothing, min_object_covered=nothing, aspect_ratio_range=nothing, area_range=nothing, max_attempts=nothing, use_image_if_no_bounding_boxes=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SampleDistortedBoundingBox") 
                begin  
                    begin  
                        if v4949 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4949)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4949)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4950 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4950)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4950)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if seed !== nothing 
                            desc["seed"] = seed
                        end
                    end
                    begin  
                        if seed2 !== nothing 
                            desc["seed2"] = seed2
                        end
                    end
                    begin  
                        if min_object_covered !== nothing 
                            desc["min_object_covered"] = min_object_covered
                        end
                    end
                    begin  
                        if aspect_ratio_range !== nothing 
                            desc["aspect_ratio_range"] = aspect_ratio_range
                        end
                    end
                    begin  
                        if area_range !== nothing 
                            desc["area_range"] = area_range
                        end
                    end
                    begin  
                        if max_attempts !== nothing 
                            desc["max_attempts"] = max_attempts
                        end
                    end
                    begin  
                        if use_image_if_no_bounding_boxes !== nothing 
                            desc["use_image_if_no_bounding_boxes"] = use_image_if_no_bounding_boxes
                        end
                    end
                end
            end), name, "SampleDistortedBoundingBox") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2), tf.Tensor(op, 3))
    end
end

"""
     tensor_array_split_v3(handle, value, lengths, flow_in)

Split the data from the input value into TensorArray elements.

Assuming that `lengths` takes on values

  ```(n0, n1, ..., n(T-1))```

and that `value` has shape

  ```(n0 + n1 + ... + n(T-1) x d0 x d1 x ...)```,

this splits values into a TensorArray with T tensors.

TensorArray index t will be the subtensor of values with starting position

  ```(n0 + n1 + ... + n(t-1), 0, 0, ...)```

and having size

  ```nt x d0 x d1 x ...```
"""
function tensor_array_split_v3(v4951, v4952, v4953, v4954; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("TensorArraySplitV3") 
                begin  
                    begin  
                        if v4951 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4951)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4951)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4952 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4952)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4952)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4953 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4953)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4953)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4954 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4954)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4954)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "TensorArraySplitV3") 
    tf.Tensor(tf.Operation(desc))
end

"""
     sdca_shrink_l_1(weights)

Applies L1 regularization shrink step on the parameters.


"""
function sdca_shrink_l_1(v4955; name=nothing, num_features=nothing, l1=nothing, l2=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SdcaShrinkL1") 
                begin  
                    begin  
                        if v4955 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4955)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4955)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if num_features !== nothing 
                            desc["num_features"] = num_features
                        end
                    end
                    begin  
                        if l1 !== nothing 
                            desc["l1"] = l1
                        end
                    end
                    begin  
                        if l2 !== nothing 
                            desc["l2"] = l2
                        end
                    end
                end
            end), name, "SdcaShrinkL1") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     tfr_reader_v2(; container=, shared_name=, compression_type=)

A Reader that outputs the records from a TensorFlow Records file.


"""
function tfr_reader_v2(; name=nothing, container=nothing, shared_name=nothing, compression_type=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("TFRecordReaderV2") 
                begin  
                end 
                begin  
                    begin  
                        if container !== nothing 
                            desc["container"] = container
                        end
                    end
                    begin  
                        if shared_name !== nothing 
                            desc["shared_name"] = shared_name
                        end
                    end
                    begin  
                        if compression_type !== nothing 
                            desc["compression_type"] = compression_type
                        end
                    end
                end
            end), name, "TFRecordReaderV2") 
    tf.Tensor(tf.Operation(desc))
end

"""
     stack_close(handle)

Delete the stack from its resource container.


"""
function stack_close(v4956; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("StackClose") 
                begin  
                    begin  
                        if v4956 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4956)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4956)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "StackClose") 
    begin  
        op = tf.Operation(desc) 
        ()
    end
end

"""
     mirror_pad_grad(input, paddings; Tpaddings=Int32)

Gradient op for `MirrorPad` op. This op folds a mirror-padded tensor.

This operation folds the padded areas of `input` by `MirrorPad` according to the
`paddings` you specify. `paddings` must be the same as `paddings` argument
given to the corresponding `MirrorPad` op.

The folded size of each dimension D of the output is:

`input.dim_size(D) - paddings(D, 0) - paddings(D, 1)`

For example:

```prettyprint
# 't' is [[1, 2, 3], [4, 5, 6], [7, 8, 9]].
# 'paddings' is [[0, 1]], [0, 1]].
# 'mode' is SYMMETRIC.
# rank of 't' is 2.
pad(t, paddings) ==> [[ 1,  5]
                      [11, 28]]
```
"""
function mirror_pad_grad(v4957, v4958; name=nothing, T=nothing, Tpaddings=nothing, mode=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("MirrorPadGrad") 
                begin  
                    begin  
                        if v4957 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4957)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4957)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4958 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4958)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4958)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tpaddings !== nothing 
                            desc["Tpaddings"] = Tpaddings
                        end
                    end
                    begin  
                        if mode !== nothing 
                            desc["mode"] = mode
                        end
                    end
                end
            end), name, "MirrorPadGrad") 
    tf.Tensor(tf.Operation(desc))
end

"""
     broadcast_args(s0, s1; T=Int32)

Return the shape of s0 op s1 with broadcast.

Given `s0` and `s1`, tensors that represent shapes, compute `r0`, the
broadcasted shape. `s0`, `s1` and `r0` are all integer vectors.
"""
function broadcast_args(v4959, v4960; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("BroadcastArgs") 
                begin  
                    begin  
                        if v4959 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4959)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4959)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4960 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4960)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4960)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "BroadcastArgs") 
    tf.Tensor(tf.Operation(desc))
end

"""
     deserialize_many_sparse(serialized_sparse)

Deserialize and concatenate `SparseTensors` from a serialized minibatch.

The input `serialized_sparse` must be a string matrix of shape `[N x 3]` where
`N` is the minibatch size and the rows correspond to packed outputs of
`SerializeSparse`.  The ranks of the original `SparseTensor` objects
must all match.  When the final `SparseTensor` is created, it has rank one
higher than the ranks of the incoming `SparseTensor` objects
(they have been concatenated along a new row dimension).

The output `SparseTensor` object's shape values for all dimensions but the
first are the max across the input `SparseTensor` objects' shape values
for the corresponding dimensions.  Its first shape value is `N`, the minibatch
size.

The input `SparseTensor` objects' indices are assumed ordered in
standard lexicographic order.  If this is not the case, after this
step run `SparseReorder` to restore index ordering.

For example, if the serialized input is a `[2 x 3]` matrix representing two
original `SparseTensor` objects:

    index = [ 0]
            [10]
            [20]
    values = [1, 2, 3]
    shape = [50]

and

    index = [ 2]
            [10]
    values = [4, 5]
    shape = [30]

then the final deserialized `SparseTensor` will be:

    index = [0  0]
            [0 10]
            [0 20]
            [1  2]
            [1 10]
    values = [1, 2, 3, 4, 5]
    shape = [2 50]
"""
function deserialize_many_sparse(v4961; name=nothing, dtype=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("DeserializeManySparse") 
                begin  
                    begin  
                        if v4961 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4961)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4961)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if dtype !== nothing 
                            desc["dtype"] = dtype
                        end
                    end
                end
            end), name, "DeserializeManySparse") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2), tf.Tensor(op, 3))
    end
end

"""
     tensor_array_size(handle, flow_in)




"""
function tensor_array_size(v4962, v4963; name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("TensorArraySize") 
                begin  
                    begin  
                        if v4962 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4962)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4962)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4963 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4963)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4963)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                end
            end), name, "TensorArraySize") 
    tf.Tensor(tf.Operation(desc))
end

"""
     segment_max(data, segment_ids)

Computes the maximum along segments of a tensor.

Read [the section on Segmentation](../../api_docs/python/math_ops.md#segmentation)
for an explanation of segments.

Computes a tensor such that
\\(output_i = \max_j(data_j)\\) where `max` is over `j` such
that `segment_ids[j] == i`.

If the max is empty for a given segment ID `i`, `output[i] = 0`.

<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="../../images/SegmentMax.png" alt>
</div>
"""
function segment_max(v4964, v4965; name=nothing, T=nothing, Tindices=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SegmentMax") 
                begin  
                    begin  
                        if v4964 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4964)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4964)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4965 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4965)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4965)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tindices !== nothing 
                            desc["Tindices"] = Tindices
                        end
                    end
                end
            end), name, "SegmentMax") 
    tf.Tensor(tf.Operation(desc))
end

"""
     range(start, limit, delta; Tidx=Int32)

Creates a sequence of numbers.

This operation creates a sequence of numbers that begins at `start` and
extends by increments of `delta` up to but not including `limit`.

For example:

```
# 'start' is 3
# 'limit' is 18
# 'delta' is 3
tf.range(start, limit, delta) ==> [3, 6, 9, 12, 15]
```
"""
function range(v4966, v4967, v4968; name=nothing, Tidx=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Range") 
                begin  
                    begin  
                        if v4966 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4966)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4966)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4967 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4967)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4967)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4968 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4968)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4968)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if Tidx !== nothing 
                            desc["Tidx"] = Tidx
                        end
                    end
                end
            end), name, "Range") 
    tf.Tensor(tf.Operation(desc))
end

"""
     barrier_take_many(handle, num_elements; allow_small_batch=false, wait_for_incomplete=false, timeout_ms=-1)

Takes the given number of completed elements from a barrier.

This operation concatenates completed-element component tensors along
the 0th dimension to make a single component tensor.

Elements come out of the barrier when they are complete, and in the order
in which they were placed into the barrier.  The indices output provides
information about the batch in which each element was originally inserted
into the barrier.
"""
function barrier_take_many(v4969, v4970; name=nothing, component_types=nothing, allow_small_batch=nothing, wait_for_incomplete=nothing, timeout_ms=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("BarrierTakeMany") 
                begin  
                    begin  
                        if v4969 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4969)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4969)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4970 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4970)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4970)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if component_types !== nothing 
                            desc["component_types"] = component_types
                        end
                    end
                    begin  
                        if allow_small_batch !== nothing 
                            desc["allow_small_batch"] = allow_small_batch
                        end
                    end
                    begin  
                        if wait_for_incomplete !== nothing 
                            desc["wait_for_incomplete"] = wait_for_incomplete
                        end
                    end
                    begin  
                        if timeout_ms !== nothing 
                            desc["timeout_ms"] = timeout_ms
                        end
                    end
                end
            end), name, "BarrierTakeMany") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2), tf.Tensor(op, 3))
    end
end

"""
     sparse_to_sparse_set_operation(set1_indices, set1_values, set1_shape, set2_indices, set2_values, set2_shape; validate_indices=true)

Applies set operation along last dimension of 2 `SparseTensor` inputs.

See SetOperationOp::SetOperationFromContext for values of `set_operation`.

If `validate_indices` is `True`, `SparseToSparseSetOperation` validates the
order and range of `set1` and `set2` indices.

Input `set1` is a `SparseTensor` represented by `set1_indices`, `set1_values`,
and `set1_shape`. For `set1` ranked `n`, 1st `n-1` dimensions must be the same
as `set2`. Dimension `n` contains values in a set, duplicates are allowed but
ignored.

Input `set2` is a `SparseTensor` represented by `set2_indices`, `set2_values`,
and `set2_shape`. For `set2` ranked `n`, 1st `n-1` dimensions must be the same
as `set1`. Dimension `n` contains values in a set, duplicates are allowed but
ignored.

If `validate_indices` is `True`, this op validates the order and range of `set1`
and `set2` indices.

Output `result` is a `SparseTensor` represented by `result_indices`,
`result_values`, and `result_shape`. For `set1` and `set2` ranked `n`, this
has rank `n` and the same 1st `n-1` dimensions as `set1` and `set2`. The `nth`
dimension contains the result of `set_operation` applied to the corresponding
`[0...n-1]` dimension of `set`.
"""
function sparse_to_sparse_set_operation(v4971, v4972, v4973, v4974, v4975, v4976; name=nothing, set_operation=nothing, validate_indices=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SparseToSparseSetOperation") 
                begin  
                    begin  
                        if v4971 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4971)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4971)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4972 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4972)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4972)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4973 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4973)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4973)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4974 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4974)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4974)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4975 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4975)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4975)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4976 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4976)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4976)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if set_operation !== nothing 
                            desc["set_operation"] = set_operation
                        end
                    end
                    begin  
                        if validate_indices !== nothing 
                            desc["validate_indices"] = validate_indices
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "SparseToSparseSetOperation") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2), tf.Tensor(op, 3))
    end
end

"""
     tensor_summary(tensor; description=, labels=Int64[], display_name=)

Outputs a `Summary` protocol buffer with a tensor.


"""
function tensor_summary(v4977; name=nothing, T=nothing, description=nothing, labels=nothing, display_name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("TensorSummary") 
                begin  
                    begin  
                        if v4977 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4977)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4977)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if description !== nothing 
                            desc["description"] = description
                        end
                    end
                    begin  
                        if labels !== nothing 
                            desc["labels"] = labels
                        end
                    end
                    begin  
                        if display_name !== nothing 
                            desc["display_name"] = display_name
                        end
                    end
                end
            end), name, "TensorSummary") 
    tf.Tensor(tf.Operation(desc))
end

"""
     remote_fused_graph_execute(values)

Execute a sub graph on a remote processor transferred by GraphTransferer.

The graph specifications are serialized by protobuf as graph_transfer_info.
The implementation / limitations may differ for each platform
and each available peripheral.
"""
function remote_fused_graph_execute(v4978; name=nothing, M=nothing, N=nothing, T=nothing, U=nothing, serialized_graph_transfer_info=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("RemoteFusedGraphExecute") 
                begin  
                    begin  
                        if v4978 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4978)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4978)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if M !== nothing 
                            desc["M"] = M
                        end
                    end
                    begin  
                        if N !== nothing 
                            desc["N"] = N
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if U !== nothing 
                            desc["U"] = U
                        end
                    end
                    begin  
                        if serialized_graph_transfer_info !== nothing 
                            desc["serialized_graph_transfer_info"] = serialized_graph_transfer_info
                        end
                    end
                end
            end), name, "RemoteFusedGraphExecute") 
    tf.Tensor(tf.Operation(desc))
end

"""
     sparse_tensor_dense_add(a_indices, a_values, a_shape, b)

Adds up a `SparseTensor` and a dense `Tensor`, producing a dense `Tensor`.

This Op does not require `a_indices` be sorted in standard lexicographic order.
"""
function sparse_tensor_dense_add(v4979, v4980, v4981, v4982; name=nothing, T=nothing, Tindices=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("SparseTensorDenseAdd") 
                begin  
                    begin  
                        if v4979 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4979)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4979)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4980 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4980)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4980)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4981 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4981)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4981)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4982 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4982)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4982)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tindices !== nothing 
                            desc["Tindices"] = Tindices
                        end
                    end
                end
            end), name, "SparseTensorDenseAdd") 
    tf.Tensor(tf.Operation(desc))
end

"""
     quantized_avg_pool(input, min_input, max_input)

Produces the average pool of the input tensor for quantized types.


"""
function quantized_avg_pool(v4983, v4984, v4985; name=nothing, T=nothing, ksize=nothing, strides=nothing, padding=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("QuantizedAvgPool") 
                begin  
                    begin  
                        if v4983 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4983)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4983)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4984 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4984)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4984)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4985 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4985)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4985)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if ksize !== nothing 
                            desc["ksize"] = ksize
                        end
                    end
                    begin  
                        if strides !== nothing 
                            desc["strides"] = strides
                        end
                    end
                    begin  
                        if padding !== nothing 
                            desc["padding"] = padding
                        end
                    end
                end
            end), name, "QuantizedAvgPool") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2), tf.Tensor(op, 3))
    end
end

"""
     dequantize(input, min_range, max_range; mode=MIN_COMBINED)

Dequantize the 'input' tensor into a float Tensor.

[min_range, max_range] are scalar floats that specify the range for
the 'input' data. The 'mode' attribute controls exactly which calculations are
used to convert the float values to their quantized equivalents.

In 'MIN_COMBINED' mode, each value of the tensor will undergo the following:

```
if T == qint8, in[i] += (range(T) + 1)/ 2.0
out[i] = min_range + (in[i]* (max_range - min_range) / range(T))
```
here `range(T) = numeric_limits<T>::max() - numeric_limits<T>::min()`

*MIN_COMBINED Mode Example*

If the input comes from a QuantizedRelu6, the output type is
quint8 (range of 0-255) but the possible range of QuantizedRelu6 is
0-6.  The min_range and max_range values are therefore 0.0 and 6.0.
Dequantize on quint8 will take each value, cast to float, and multiply
by 6 / 255.
Note that if quantizedtype is qint8, the operation will additionally add
each value by 128 prior to casting.

If the mode is 'MIN_FIRST', then this approach is used:

```
number_of_steps = 1 << (# of bits in T)
range_adjust = number_of_steps / (number_of_steps - 1)
range = (range_max - range_min) * range_adjust
range_scale = range / number_of_steps
const double offset_input = static_cast<double>(input) - lowest_quantized;
result = range_min + ((input - numeric_limits<T>::min()) * range_scale)
```
"""
function dequantize(v4986, v4987, v4988; name=nothing, T=nothing, mode=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Dequantize") 
                begin  
                    begin  
                        if v4986 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4986)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4986)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4987 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4987)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4987)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4988 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4988)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4988)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if mode !== nothing 
                            desc["mode"] = mode
                        end
                    end
                end
            end), name, "Dequantize") 
    tf.Tensor(tf.Operation(desc))
end

"""
     prevent_gradient(input; message=)

An identity op that triggers an error if a gradient is requested.

When executed in a graph, this op outputs its input tensor as-is.

When building ops to compute gradients, the TensorFlow gradient system
will return an error when trying to lookup the gradient of this op,
because no gradient must ever be registered for this function.  This
op exists to prevent subtle bugs from silently returning unimplemented
gradients in some corner cases.
"""
function prevent_gradient(v4989; name=nothing, T=nothing, message=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("PreventGradient") 
                begin  
                    begin  
                        if v4989 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4989)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4989)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if message !== nothing 
                            desc["message"] = message
                        end
                    end
                end
            end), name, "PreventGradient") 
    tf.Tensor(tf.Operation(desc))
end

"""
     cumsum(x, axis; exclusive=false, reverse=false, Tidx=Int32)

Compute the cumulative sum of the tensor `x` along `axis`.

By default, this op performs an inclusive cumsum, which means that the first
element of the input is identical to the first element of the output:
```prettyprint
tf.cumsum([a, b, c]) ==> [a, a + b, a + b + c]
```

By setting the `exclusive` kwarg to `True`, an exclusive cumsum is
performed instead:
```prettyprint
tf.cumsum([a, b, c], exclusive=True) ==> [0, a, a + b]
```

By setting the `reverse` kwarg to `True`, the cumsum is performed in the
opposite direction:
```prettyprint
tf.cumsum([a, b, c], reverse=True) ==> [a + b + c, b + c, c]
```
This is more efficient than using separate `tf.reverse` ops.

The `reverse` and `exclusive` kwargs can also be combined:
```prettyprint
tf.cumsum([a, b, c], exclusive=True, reverse=True) ==> [b + c, c, 0]
```
"""
function cumsum(v4990, v4991; name=nothing, exclusive=nothing, reverse=nothing, T=nothing, Tidx=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Cumsum") 
                begin  
                    begin  
                        if v4990 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4990)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4990)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4991 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4991)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4991)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if exclusive !== nothing 
                            desc["exclusive"] = exclusive
                        end
                    end
                    begin  
                        if reverse !== nothing 
                            desc["reverse"] = reverse
                        end
                    end
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if Tidx !== nothing 
                            desc["Tidx"] = Tidx
                        end
                    end
                end
            end), name, "Cumsum") 
    tf.Tensor(tf.Operation(desc))
end

"""
     barrier(; shapes=Int64[], capacity=-1, container=, shared_name=)

Defines a barrier that persists across different graph executions.

A barrier represents a key-value map, where each key is a string, and
each value is a tuple of tensors.

At runtime, the barrier contains 'complete' and 'incomplete'
elements. A complete element has defined tensors for all components of
its value tuple, and may be accessed using BarrierTakeMany. An
incomplete element has some undefined components in its value tuple,
and may be updated using BarrierInsertMany.
"""
function barrier(; name=nothing, component_types=nothing, shapes=nothing, capacity=nothing, container=nothing, shared_name=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Barrier") 
                begin  
                end 
                begin  
                    begin  
                        if component_types !== nothing 
                            desc["component_types"] = component_types
                        end
                    end
                    begin  
                        if shapes !== nothing 
                            desc["shapes"] = shapes
                        end
                    end
                    begin  
                        if capacity !== nothing 
                            desc["capacity"] = capacity
                        end
                    end
                    begin  
                        if container !== nothing 
                            desc["container"] = container
                        end
                    end
                    begin  
                        if shared_name !== nothing 
                            desc["shared_name"] = shared_name
                        end
                    end
                end
            end), name, "Barrier") 
    tf.Tensor(tf.Operation(desc))
end

"""
     div(x, y)

Returns x / y element-wise.

*NOTE*: `Div` supports broadcasting. More about broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
"""
function div(v4992, v4993; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("Div") 
                begin  
                    begin  
                        if v4992 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4992)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4992)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4993 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4993)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4993)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "Div") 
    tf.Tensor(tf.Operation(desc))
end

"""
     truncate_div(x, y)

Returns x / y element-wise for integer types.

Truncation designates that negative numbers will round fractional quantities
toward zero. I.e. -7 / 5 = 1. This matches C semantics but it is different
than Python semantics. See `FloorDiv` for a division function that matches
Python Semantics.

*NOTE*: `TruncateDiv` supports broadcasting. More about broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
"""
function truncate_div(v4994, v4995; name=nothing, T=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("TruncateDiv") 
                begin  
                    begin  
                        if v4994 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4994)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4994)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4995 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4995)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4995)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                end
            end), name, "TruncateDiv") 
    tf.Tensor(tf.Operation(desc))
end

"""
     lookup_table_export(table_handle)

Outputs all keys and values in the table.


"""
function lookup_table_export(v4996; name=nothing, Tkeys=nothing, Tvalues=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("LookupTableExport") 
                begin  
                    begin  
                        if v4996 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4996)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4996)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if Tkeys !== nothing 
                            desc["Tkeys"] = Tkeys
                        end
                    end
                    begin  
                        if Tvalues !== nothing 
                            desc["Tvalues"] = Tvalues
                        end
                    end
                end
            end), name, "LookupTableExport") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2))
    end
end

"""
     batch_norm_with_global_normalization_grad(t, m, v, gamma, backprop)

Gradients for batch normalization.

This op is deprecated. See `tf.nn.batch_normalization`.
"""
function batch_norm_with_global_normalization_grad(v4997, v4998, v4999, v5000, v5001; name=nothing, T=nothing, variance_epsilon=nothing, scale_after_normalization=nothing) 
    local desc 
    tf.with_op_name((()->begin  
                desc = tf.NodeDescription("BatchNormWithGlobalNormalizationGrad") 
                begin  
                    begin  
                        if v4997 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4997)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4997)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4998 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4998)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4998)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v4999 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v4999)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v4999)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v5000 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v5000)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v5000)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                    begin  
                        if v5001 isa AbstractArray 
                            converted = convert.(TensorFlow.Tensor{Any}, v5001)
                        else  
                            converted = convert(TensorFlow.Tensor{Any}, v5001)
                        end 
                        begin  
                        end 
                        tf.add_input(desc, converted)
                    end
                end 
                begin  
                    begin  
                        if T !== nothing 
                            desc["T"] = T
                        end
                    end
                    begin  
                        if variance_epsilon !== nothing 
                            desc["variance_epsilon"] = variance_epsilon
                        end
                    end
                    begin  
                        if scale_after_normalization !== nothing 
                            desc["scale_after_normalization"] = scale_after_normalization
                        end
                    end
                end
            end), name, "BatchNormWithGlobalNormalizationGrad") 
    begin  
        op = tf.Operation(desc) 
        (tf.Tensor(op, 1), tf.Tensor(op, 2), tf.Tensor(op, 3), tf.Tensor(op, 4), tf.Tensor(op, 5))
    end
end

end
